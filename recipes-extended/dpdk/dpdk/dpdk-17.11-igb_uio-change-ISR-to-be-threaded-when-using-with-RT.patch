From f78be4561de9e22ebff252feb1bdb37875d63093 Mon Sep 17 00:00:00 2001
From: Yongxin Liu <yongxin.liu@windriver.com>
Date: Wed, 18 Sep 2019 15:23:32 +0800
Subject: [PATCH] igb_uio: change ISR to be threaded when using with RT kernel

Non-thread ISR shouldn't call rt_spin_lock which might sleep.

Here is the calltrace.

[ 2034.457805] Call Trace:
[ 2034.460818]  <IRQ>
[ 2034.463397]  dump_stack+0x70/0x9a
[ 2034.467281]  ___might_sleep.cold+0xe1/0xf2
[ 2034.471943]  rt_spin_lock+0x55/0x70
[ 2034.475994]  ? __wake_up_common_lock+0x61/0xb0
[ 2034.481004]  __wake_up_common_lock+0x61/0xb0
[ 2034.485842]  __wake_up+0x13/0x20
[ 2034.489635]  uio_event_notify+0x2c/0x50 [uio]
[ 2034.494560]  igbuio_pci_irqhandler+0x1f/0x40 [igb_uio]
[ 2034.500262]  __handle_irq_event_percpu+0x5f/0x3f0
[ 2034.505532]  ? cpuidle_enter_state+0xd3/0x500
[ 2034.510454]  handle_irq_event_percpu+0x4b/0x90
[ 2034.515462]  handle_irq_event+0x3c/0x5b
[ 2034.519864]  handle_edge_irq+0xbb/0x210
[ 2034.524264]  handle_irq+0x23/0x30
[ 2034.528143]  do_IRQ+0x7e/0x150
[ 2034.531764]  common_interrupt+0xf/0xf
[ 2034.535990]  </IRQ>

Upstream-Status: Inappropriate

Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
---
 lib/librte_eal/linuxapp/igb_uio/igb_uio.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/lib/librte_eal/linuxapp/igb_uio/igb_uio.c b/lib/librte_eal/linuxapp/igb_uio/igb_uio.c
index 3073bca31..3b1e1d553 100644
--- a/lib/librte_eal/linuxapp/igb_uio/igb_uio.c
+++ b/lib/librte_eal/linuxapp/igb_uio/igb_uio.c
@@ -239,7 +239,6 @@ igbuio_pci_enable_interrupts(struct rte_uio_pci_dev *udev)
 		msix_entry.entry = 0;
 		if (pci_enable_msix(udev->pdev, &msix_entry, 1) == 0) {
 			dev_dbg(&udev->pdev->dev, "using MSI-X");
-			udev->info.irq_flags = IRQF_NO_THREAD;
 			udev->info.irq = msix_entry.vector;
 			udev->mode = RTE_INTR_MODE_MSIX;
 			break;
@@ -247,7 +246,6 @@ igbuio_pci_enable_interrupts(struct rte_uio_pci_dev *udev)
 #else
 		if (pci_alloc_irq_vectors(udev->pdev, 1, 1, PCI_IRQ_MSIX) == 1) {
 			dev_dbg(&udev->pdev->dev, "using MSI-X");
-			udev->info.irq_flags = IRQF_NO_THREAD;
 			udev->info.irq = pci_irq_vector(udev->pdev, 0);
 			udev->mode = RTE_INTR_MODE_MSIX;
 			break;
@@ -259,7 +257,6 @@ igbuio_pci_enable_interrupts(struct rte_uio_pci_dev *udev)
 #ifndef HAVE_ALLOC_IRQ_VECTORS
 		if (pci_enable_msi(udev->pdev) == 0) {
 			dev_dbg(&udev->pdev->dev, "using MSI");
-			udev->info.irq_flags = IRQF_NO_THREAD;
 			udev->info.irq = udev->pdev->irq;
 			udev->mode = RTE_INTR_MODE_MSI;
 			break;
@@ -267,7 +264,6 @@ igbuio_pci_enable_interrupts(struct rte_uio_pci_dev *udev)
 #else
 		if (pci_alloc_irq_vectors(udev->pdev, 1, 1, PCI_IRQ_MSI) == 1) {
 			dev_dbg(&udev->pdev->dev, "using MSI");
-			udev->info.irq_flags = IRQF_NO_THREAD;
 			udev->info.irq = pci_irq_vector(udev->pdev, 0);
 			udev->mode = RTE_INTR_MODE_MSI;
 			break;
@@ -277,7 +273,7 @@ igbuio_pci_enable_interrupts(struct rte_uio_pci_dev *udev)
 	case RTE_INTR_MODE_LEGACY:
 		if (pci_intx_mask_supported(udev->pdev)) {
 			dev_dbg(&udev->pdev->dev, "using INTX");
-			udev->info.irq_flags = IRQF_SHARED | IRQF_NO_THREAD;
+			udev->info.irq_flags = IRQF_SHARED;
 			udev->info.irq = udev->pdev->irq;
 			udev->mode = RTE_INTR_MODE_LEGACY;
 			break;
-- 
2.14.4

