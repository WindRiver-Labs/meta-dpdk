From a15cd386575331b6f5568f6cee0c150eb5d04a3e Mon Sep 17 00:00:00 2001
From: Alok Makhariya <alok.makhariya@nxp.com>
Date: Thu, 18 Jan 2018 01:36:42 +0530
Subject: [PATCH 104/166] PVT: net/dpaa: add support for dynamic queue based
 distribution

Signed-off-by: Alok Makhariya <alok.makhariya@nxp.com>
---
 drivers/net/dpaa/Makefile                 |    3 +
 drivers/net/dpaa/dpaa_ethdev.c            |  114 +-
 drivers/net/dpaa/dpaa_ethdev.h            |    4 +
 drivers/net/dpaa/dpaa_flow.c              |  745 +++++
 drivers/net/dpaa/dpaa_flow.h              |   41 +
 drivers/net/dpaa/fmlib/dpaa_integration.h |   84 +
 drivers/net/dpaa/fmlib/fm_ext.h           | 1206 +++++++
 drivers/net/dpaa/fmlib/fm_lib.c           |  608 ++++
 drivers/net/dpaa/fmlib/fm_pcd_ext.h       | 4980 +++++++++++++++++++++++++++++
 drivers/net/dpaa/fmlib/fm_port_ext.h      | 3448 ++++++++++++++++++++
 drivers/net/dpaa/fmlib/ncsw_ext.h         |  190 ++
 drivers/net/dpaa/fmlib/net_ext.h          |  435 +++
 12 files changed, 11853 insertions(+), 5 deletions(-)
 create mode 100644 drivers/net/dpaa/dpaa_flow.c
 create mode 100644 drivers/net/dpaa/dpaa_flow.h
 create mode 100644 drivers/net/dpaa/fmlib/dpaa_integration.h
 create mode 100644 drivers/net/dpaa/fmlib/fm_ext.h
 create mode 100644 drivers/net/dpaa/fmlib/fm_lib.c
 create mode 100644 drivers/net/dpaa/fmlib/fm_pcd_ext.h
 create mode 100644 drivers/net/dpaa/fmlib/fm_port_ext.h
 create mode 100644 drivers/net/dpaa/fmlib/ncsw_ext.h
 create mode 100644 drivers/net/dpaa/fmlib/net_ext.h

diff --git a/drivers/net/dpaa/Makefile b/drivers/net/dpaa/Makefile
index 389614420d39..361c82cd4b86 100644
--- a/drivers/net/dpaa/Makefile
+++ b/drivers/net/dpaa/Makefile
@@ -41,6 +41,7 @@ CFLAGS += -O3 $(WERROR_FLAGS)
 CFLAGS += -Wno-pointer-arith
 CFLAGS += -I$(RTE_SDK_DPAA)/
 CFLAGS += -I$(RTE_SDK_DPAA)/include
+CFLAGS += -I$(RTE_SDK_DPAA)/fmlib
 CFLAGS += -I$(RTE_SDK)/drivers/bus/dpaa
 CFLAGS += -I$(RTE_SDK)/drivers/bus/dpaa/include/
 CFLAGS += -I$(RTE_SDK)/drivers/bus/dpaa/base/qbman
@@ -54,7 +55,9 @@ EXPORT_MAP := rte_pmd_dpaa_version.map
 LIBABIVER := 1
 
 # Interfaces with DPDK
+SRCS-$(CONFIG_RTE_LIBRTE_DPAA_PMD) += fmlib/fm_lib.c
 SRCS-$(CONFIG_RTE_LIBRTE_DPAA_PMD) += dpaa_ethdev.c
+SRCS-$(CONFIG_RTE_LIBRTE_DPAA_PMD) += dpaa_flow.c
 SRCS-$(CONFIG_RTE_LIBRTE_DPAA_PMD) += dpaa_rxtx.c
 
 LDLIBS += -lrte_bus_dpaa
diff --git a/drivers/net/dpaa/dpaa_ethdev.c b/drivers/net/dpaa/dpaa_ethdev.c
index 7abe7647821e..c978006d756b 100644
--- a/drivers/net/dpaa/dpaa_ethdev.c
+++ b/drivers/net/dpaa/dpaa_ethdev.c
@@ -64,6 +64,7 @@
 
 #include <dpaa_ethdev.h>
 #include <dpaa_rxtx.h>
+#include <dpaa_flow.h>
 #include <rte_pmd_dpaa.h>
 
 #include <fsl_usd.h>
@@ -73,6 +74,8 @@
 
 /* Keep track of whether QMAN and BMAN have been globally initialized */
 static int is_global_init;
+static int fmc_q = 1;	/* Indicates the uses of FMC tool for distribution */
+static int default_q;	/* use default queue - FMC is not executed*/
 /* At present we only allow up to 4 push mode queues - as each of this queue
  * need dedicated portal and we are short of portals.
  */
@@ -162,6 +165,7 @@ dpaa_mtu_set(struct rte_eth_dev *dev, uint16_t mtu)
 static int
 dpaa_eth_dev_configure(struct rte_eth_dev *dev __rte_unused)
 {
+	struct rte_eth_conf *eth_conf = &dev->data->dev_conf;
 	struct dpaa_if *dpaa_intf = dev->data->dev_private;
 
 	PMD_INIT_FUNC_TRACE();
@@ -176,6 +180,15 @@ dpaa_eth_dev_configure(struct rte_eth_dev *dev __rte_unused)
 			return -1;
 		}
 	}
+
+	if (!(default_q || fmc_q)) {
+		if (dpaa_fm_config(dev, eth_conf->
+					rx_adv_conf.rss_conf.rss_hf)) {
+			DPAA_PMD_ERR("FM port configuration: Failed\n");
+			return -1;
+		}
+	}
+
 	return 0;
 }
 
@@ -208,6 +221,9 @@ static int dpaa_eth_dev_start(struct rte_eth_dev *dev)
 
 	PMD_INIT_FUNC_TRACE();
 
+	if (!(default_q || fmc_q))
+		dpaa_write_fm_config_to_file();
+
 	/* Change tx callback to the real one */
 	if (getenv("DPAA_FMAN_UCODE_SUPPORT"))
 		dev->tx_pkt_burst = dpaa_eth_ucode_queue_tx;
@@ -859,6 +875,41 @@ dpaa_dev_set_mac_addr(struct rte_eth_dev *dev,
 		RTE_LOG(ERR, PMD, "error: Setting the MAC ADDR failed %d", ret);
 }
 
+static int
+dpaa_dev_rss_hash_update(struct rte_eth_dev *dev,
+			 struct rte_eth_rss_conf *rss_conf)
+{
+	struct rte_eth_dev_data *data = dev->data;
+	struct rte_eth_conf *eth_conf = &data->dev_conf;
+
+	PMD_INIT_FUNC_TRACE();
+
+	if (!(default_q || fmc_q)) {
+		if (dpaa_fm_config(dev, rss_conf->rss_hf)) {
+			DPAA_PMD_ERR("FM port configuration: Failed\n");
+			return -1;
+		}
+		eth_conf->rx_adv_conf.rss_conf.rss_hf = rss_conf->rss_hf;
+	} else {
+		DPAA_PMD_ERR("Function not supported\n");
+		return -ENOTSUP;
+	}
+	return 0;
+}
+
+static int
+dpaa_dev_rss_hash_conf_get(struct rte_eth_dev *dev,
+                           struct rte_eth_rss_conf *rss_conf)
+{
+	struct rte_eth_dev_data *data = dev->data;
+	struct rte_eth_conf *eth_conf = &data->dev_conf;
+
+	/* dpaa does not support rss_key, so length should be 0*/
+	rss_conf->rss_key_len = 0;
+	rss_conf->rss_hf = eth_conf->rx_adv_conf.rss_conf.rss_hf;
+	return 0;
+}
+
 static struct eth_dev_ops dpaa_devops = {
 	.dev_configure		  = dpaa_eth_dev_configure,
 	.dev_start		  = dpaa_eth_dev_start,
@@ -896,6 +947,8 @@ static struct eth_dev_ops dpaa_devops = {
 	.mac_addr_set		  = dpaa_dev_set_mac_addr,
 
 	.fw_version_get		  = dpaa_fw_version_get,
+	.rss_hash_update	  = dpaa_dev_rss_hash_update,
+	.rss_hash_conf_get        = dpaa_dev_rss_hash_conf_get,
 };
 
 static bool
@@ -1122,10 +1175,17 @@ dpaa_dev_init(struct rte_eth_dev *eth_dev)
 	dpaa_intf->cfg = cfg;
 
 	/* Initialize Rx FQ's */
-	if (getenv("DPAA_NUM_RX_QUEUES"))
-		num_rx_fqs = atoi(getenv("DPAA_NUM_RX_QUEUES"));
-	else
+	if (default_q) {
 		num_rx_fqs = DPAA_DEFAULT_NUM_PCD_QUEUES;
+	} else if (fmc_q) {
+		if (getenv("DPAA_NUM_RX_QUEUES"))
+			num_rx_fqs = atoi(getenv("DPAA_NUM_RX_QUEUES"));
+		else
+			num_rx_fqs = 1;
+	} else {
+		num_rx_fqs = DPAA_MAX_NUM_PCD_QUEUES;
+	}
+
 
 	/* if push mode queues to be enabled. Currenly we are allowing only
 	 * one queue per thread.
@@ -1167,8 +1227,11 @@ dpaa_dev_init(struct rte_eth_dev *eth_dev)
 	}
 
 	for (loop = 0; loop < num_rx_fqs; loop++) {
-		fqid = DPAA_PCD_FQID_START + dpaa_intf->ifid *
-			DPAA_PCD_FQID_MULTIPLIER + loop;
+		if (default_q)
+			fqid = cfg->rx_def;
+		else
+			fqid = DPAA_PCD_FQID_START + dpaa_intf->ifid *
+				DPAA_PCD_FQID_MULTIPLIER + loop;
 
 		if (dpaa_intf->cgr_rx)
 			dpaa_intf->cgr_rx[loop].cgrid = cgrid[loop];
@@ -1292,6 +1355,12 @@ dpaa_dev_uninit(struct rte_eth_dev *dev)
 		return -1;
 	}
 
+	/* DPAA FM deconfig */
+	if (!(default_q || fmc_q)) {
+		if (dpaa_fm_deconfig(dpaa_intf))
+			DPAA_PMD_WARN("DPAA FM deconfig failed\n");
+	}
+
 	dpaa_eth_dev_close(dev);
 
 	/* release configuration memory */
@@ -1363,6 +1432,19 @@ rte_dpaa_probe(struct rte_dpaa_driver *dpaa_drv,
 			return ret;
 		}
 
+		if (getenv("DPAA_DEFAULT_Q_ONLY"))
+			default_q = 1;
+
+		if (getenv("DPAA_DYNAMIC_DIST"))
+			fmc_q = 0;
+
+		if (!(default_q || fmc_q)) {
+			if (dpaa_fm_init()) {
+				DPAA_PMD_ERR("FM init failed\n");
+				return -1;
+			}
+		}
+
 		is_global_init = 1;
 	}
 
@@ -1422,6 +1504,28 @@ rte_dpaa_remove(struct rte_dpaa_device *dpaa_dev)
 	return 0;
 }
 
+static void __attribute__((destructor(102))) dpaa_finish(void)
+{
+	if (!(default_q || fmc_q)) {
+		unsigned i;
+
+		for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
+			if (rte_eth_devices[i].dev_ops == &dpaa_devops) {
+				struct dpaa_if *dpaa_intf =
+					rte_eth_devices[i].data->dev_private;
+
+				if (dpaa_intf->valid)
+					if (dpaa_fm_deconfig(dpaa_intf))
+						DPAA_PMD_WARN("DPAA FM "
+							"deconfig failed\n");
+			}
+		}
+		if (is_global_init)
+			if (dpaa_fm_term())
+				DPAA_PMD_WARN("DPAA FM term failed\n");
+	}
+}
+
 static struct rte_dpaa_driver rte_dpaa_pmd = {
 	.drv_type = FSL_DPAA_ETH,
 	.probe = rte_dpaa_probe,
diff --git a/drivers/net/dpaa/dpaa_ethdev.h b/drivers/net/dpaa/dpaa_ethdev.h
index 3831bc825cf9..cfc45e9bf1bf 100644
--- a/drivers/net/dpaa/dpaa_ethdev.h
+++ b/drivers/net/dpaa/dpaa_ethdev.h
@@ -144,6 +144,10 @@ struct dpaa_if {
 	struct fman_if *fif;
 	struct dpaa_bp_info *bp_info;
 	struct rte_eth_fc_conf *fc_conf;
+	void *port_handle;
+	void *netenv_handle;
+	void *scheme_handle;
+	uint32_t scheme_count;
 };
 
 struct dpaa_if_stats {
diff --git a/drivers/net/dpaa/dpaa_flow.c b/drivers/net/dpaa/dpaa_flow.c
new file mode 100644
index 000000000000..cca49dc2932b
--- /dev/null
+++ b/drivers/net/dpaa/dpaa_flow.c
@@ -0,0 +1,745 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright 2017 NXP
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of NXP nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* System headers */
+#include <stdio.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <dpaa_ethdev.h>
+#include <dpaa_flow.h>
+#include <rte_dpaa_logs.h>
+#include <fm_port_ext.h>
+
+#define DPAA_MAX_NUM_ETH_DEV	8
+
+#define SCH_EXT_ARR(scheme_params, hdr_idx) \
+	scheme_params->key_extract_and_hash_params.extract_array[hdr_idx]
+
+#define SCH_EXT_HDR(scheme_params, hdr_idx) \
+	SCH_EXT_ARR(scheme_params, hdr_idx).extract_params.extract_by_hdr
+
+#define SCH_EXT_FULL_FLD(scheme_params, hdr_idx) \
+	SCH_EXT_HDR(scheme_params, hdr_idx).extract_by_hdr_type.full_field
+
+/* FM global info */
+struct dpaa_fm_info {
+	t_Handle fman_handle;
+	t_Handle pcd_handle;
+};
+
+/*FM model to read and write from file */
+struct dpaa_fm_model {
+	uint32_t dev_count;
+	t_FmPortParams fm_port_params[DPAA_MAX_NUM_ETH_DEV];
+	t_Handle scheme_devid[DPAA_MAX_NUM_ETH_DEV];
+	t_Handle netenv_devid[DPAA_MAX_NUM_ETH_DEV];
+};
+
+struct dpaa_fm_info fm_info;
+struct dpaa_fm_model fm_model;
+const char *fm_log = "/tmp/fm.bin";
+
+static void fm_prev_cleanup(void)
+{
+	uint32_t fman_id = 0, i = 0;
+	struct dpaa_if dpaa_intf;
+	t_FmPcdParams fmPcdParams = {0};
+
+	fm_info.fman_handle = FM_Open(fman_id);
+	if (!fm_info.fman_handle)
+		return;
+
+	fmPcdParams.h_Fm = fm_info.fman_handle;
+	fmPcdParams.prsSupport = true;
+	fmPcdParams.kgSupport = true;
+	/* FM PCD Open */
+	fm_info.pcd_handle = FM_PCD_Open(&fmPcdParams);
+	if (!fm_info.pcd_handle)
+		return;
+
+	while (i < fm_model.dev_count) {
+		/* FM Port Open */
+		fm_model.fm_port_params[i].h_Fm = fm_info.fman_handle;
+		dpaa_intf.port_handle =
+				FM_PORT_Open(&fm_model.fm_port_params[i]);
+
+		dpaa_intf.scheme_handle = CreateDevice
+				(fm_info.pcd_handle, fm_model.scheme_devid[i]);
+
+		dpaa_intf.netenv_handle = CreateDevice
+				(fm_info.pcd_handle, fm_model.netenv_devid[i]);
+
+		i++;
+		if (!dpaa_intf.netenv_handle || !dpaa_intf.scheme_handle ||
+							!dpaa_intf.port_handle)
+			continue;
+
+		if (dpaa_fm_deconfig(&dpaa_intf))
+			DPAA_PMD_ERR("DPAA FM deconfig failed\n");
+	}
+
+	if (dpaa_fm_term())
+		DPAA_PMD_WARN("DPAA FM term failed\n");
+
+	memset(&fm_model, 0, sizeof(struct dpaa_fm_model));
+}
+
+void dpaa_write_fm_config_to_file(void)
+{
+	size_t bytes_write;
+	FILE *fp = fopen(fm_log, "wb");
+	if (!fp)
+		DPAA_PMD_ERR("File open failed\n");
+	bytes_write = fwrite(&fm_model, sizeof(struct dpaa_fm_model), 1, fp);
+	if (!bytes_write) {
+		DPAA_PMD_WARN("No bytes write\n");
+		fclose(fp);
+		return;
+	}
+	fclose(fp);
+}
+
+static void dpaa_read_fm_config_from_file(void)
+{
+	size_t bytes_read;
+	FILE *fp = fopen(fm_log, "rb");
+	if (!fp)
+		return;
+	bytes_read = fread(&fm_model, sizeof(struct dpaa_fm_model), 1, fp);
+	if (!bytes_read) {
+		DPAA_PMD_WARN("No bytes read\n");
+		fclose(fp);
+		return;
+	}
+	fclose(fp);
+
+	/*FM cleanup from previous configured app */
+	fm_prev_cleanup();
+}
+
+static inline int set_hashParams_eth(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+						HEADER_TYPE_ETH;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).eth =
+						IOC_NET_HEADER_FIELD_ETH_SA;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).eth =
+						IOC_NET_HEADER_FIELD_ETH_DA;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+static inline int set_hashParams_ipv4(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+						HEADER_TYPE_IPv4;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).ipv4 =
+					IOC_NET_HEADER_FIELD_IPv4_SRC_IP;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).ipv4 =
+					IOC_NET_HEADER_FIELD_IPv4_DST_IP;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+static inline int set_hashParams_ipv6(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+							HEADER_TYPE_IPv6;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).ipv6 =
+					IOC_NET_HEADER_FIELD_IPv6_SRC_IP;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).ipv6 =
+					IOC_NET_HEADER_FIELD_IPv6_DST_IP;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+static inline int set_hashParams_udp(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+						HEADER_TYPE_UDP;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).udp =
+					IOC_NET_HEADER_FIELD_UDP_PORT_SRC;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).udp =
+					IOC_NET_HEADER_FIELD_UDP_PORT_DST;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+static inline int set_hashParams_tcp(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+						HEADER_TYPE_TCP;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).tcp =
+					IOC_NET_HEADER_FIELD_TCP_PORT_SRC;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).tcp =
+					IOC_NET_HEADER_FIELD_TCP_PORT_DST;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+static inline int set_hashParams_sctp(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params, int hdr_idx)
+{
+	int k;
+
+	for (k = 0; k < 2; k++) {
+		SCH_EXT_ARR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_BY_HDR;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr =
+						HEADER_TYPE_SCTP;
+		SCH_EXT_HDR(scheme_params, hdr_idx).hdr_index =
+						e_IOC_FM_PCD_HDR_INDEX_NONE;
+		SCH_EXT_HDR(scheme_params, hdr_idx).type =
+						e_IOC_FM_PCD_EXTRACT_FULL_FIELD;
+		if (k == 0)
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).sctp =
+					IOC_NET_HEADER_FIELD_SCTP_PORT_SRC;
+		else
+			SCH_EXT_FULL_FLD(scheme_params, hdr_idx).sctp =
+					IOC_NET_HEADER_FIELD_SCTP_PORT_DST;
+		hdr_idx++;
+	}
+	return hdr_idx;
+}
+
+/* Set scheme params for hash distribution */
+static int set_scheme_params(
+	ioc_fm_pcd_kg_scheme_params_t *scheme_params,
+	ioc_fm_pcd_net_env_params_t *dist_units,
+	struct dpaa_if *dpaa_intf)
+{
+	int dist_idx, hdr_idx = 0;
+
+	scheme_params->use_hash = 1;
+	scheme_params->modify = false;
+	scheme_params->always_direct = false;
+	scheme_params->scheme_counter.update = 1;
+	scheme_params->scheme_counter.value = 0;
+	scheme_params->next_engine = e_IOC_FM_PCD_DONE;
+	scheme_params->base_fqid = DPAA_PCD_FQID_START + (dpaa_intf->ifid *
+						DPAA_PCD_FQID_MULTIPLIER);
+	scheme_params->net_env_params.net_env_id = dpaa_intf->netenv_handle;
+	scheme_params->net_env_params.num_of_distinction_units =
+					dist_units->num_of_distinction_units;
+
+	scheme_params->key_extract_and_hash_params.
+		hash_distribution_num_of_fqids = dpaa_intf->nb_rx_queues;
+	scheme_params->key_extract_and_hash_params.
+		num_of_used_extracts = 2 * dist_units->num_of_distinction_units;
+
+	for (dist_idx = 0; dist_idx < dist_units->num_of_distinction_units;
+	     dist_idx++) {
+
+		switch (dist_units->units[dist_idx].hdrs[0].hdr) {
+		case HEADER_TYPE_ETH:
+			hdr_idx = set_hashParams_eth(scheme_params, hdr_idx);
+			break;
+
+		case HEADER_TYPE_IPv4:
+			hdr_idx = set_hashParams_ipv4(scheme_params, hdr_idx);
+			break;
+
+		case HEADER_TYPE_IPv6:
+			hdr_idx = set_hashParams_ipv6(scheme_params, hdr_idx);
+			break;
+
+		case HEADER_TYPE_UDP:
+			hdr_idx = set_hashParams_udp(scheme_params, hdr_idx);
+			break;
+
+		case HEADER_TYPE_TCP:
+			hdr_idx = set_hashParams_tcp(scheme_params, hdr_idx);
+			break;
+
+		case HEADER_TYPE_SCTP:
+			hdr_idx = set_hashParams_sctp(scheme_params, hdr_idx);
+			break;
+
+		default:
+			DPAA_PMD_ERR("Invalid Distinction Unit\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void set_dist_units(ioc_fm_pcd_net_env_params_t *dist_units,
+			   uint64_t req_dist_set)
+{
+	uint32_t loop = 0, dist_idx = 0, dist_field = 0;
+	int l2_configured = 0, ipv4_configured = 0, ipv6_configured = 0;
+	int udp_configured = 0, tcp_configured = 0, sctp_configured = 0;
+
+	if (!req_dist_set)
+		dist_units->units[dist_idx++].hdrs[0].hdr = HEADER_TYPE_IPv4;
+
+	while (req_dist_set) {
+		if (req_dist_set % 2 != 0) {
+			dist_field = 1U << loop;
+			switch (dist_field) {
+			case ETH_RSS_L2_PAYLOAD:
+
+				if (l2_configured)
+					break;
+				l2_configured = 1;
+
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+								HEADER_TYPE_ETH;
+				break;
+
+			case ETH_RSS_IPV4:
+			case ETH_RSS_FRAG_IPV4:
+			case ETH_RSS_NONFRAG_IPV4_OTHER:
+
+				if (ipv4_configured)
+					break;
+				ipv4_configured = 1;
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+							HEADER_TYPE_IPv4;
+				break;
+
+			case ETH_RSS_IPV6:
+			case ETH_RSS_FRAG_IPV6:
+			case ETH_RSS_NONFRAG_IPV6_OTHER:
+			case ETH_RSS_IPV6_EX:
+
+				if (ipv6_configured)
+					break;
+				ipv6_configured = 1;
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+							HEADER_TYPE_IPv6;
+				break;
+
+			case ETH_RSS_NONFRAG_IPV4_TCP:
+			case ETH_RSS_NONFRAG_IPV6_TCP:
+			case ETH_RSS_IPV6_TCP_EX:
+
+				if (tcp_configured)
+					break;
+				tcp_configured = 1;
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+							HEADER_TYPE_TCP;
+				break;
+
+			case ETH_RSS_NONFRAG_IPV4_UDP:
+			case ETH_RSS_NONFRAG_IPV6_UDP:
+			case ETH_RSS_IPV6_UDP_EX:
+
+				if (udp_configured)
+					break;
+				udp_configured = 1;
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+							HEADER_TYPE_UDP;
+				break;
+
+			case ETH_RSS_NONFRAG_IPV4_SCTP:
+			case ETH_RSS_NONFRAG_IPV6_SCTP:
+
+				if (sctp_configured)
+					break;
+				sctp_configured = 1;
+
+				dist_units->units[dist_idx++].hdrs[0].hdr =
+							HEADER_TYPE_SCTP;
+				break;
+
+			default:
+				DPAA_PMD_ERR("Bad flow distribution"
+					    " option\n");
+			}
+		}
+		req_dist_set = req_dist_set >> 1;
+		loop++;
+	}
+
+	/* Dist units is set to dist_idx */
+	dist_units->num_of_distinction_units = dist_idx;
+}
+
+/* De-Configure DPAA FM */
+int dpaa_fm_deconfig(struct dpaa_if *dpaa_intf)
+{
+	int ret;
+
+	/* FM PORT Disable */
+	ret = FM_PORT_Disable(dpaa_intf->port_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PORT_Disable: Failed\n");
+		return ret;
+	}
+
+	/* FM PORT DeletePCD */
+	ret = FM_PORT_DeletePCD(dpaa_intf->port_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PORT_DeletePCD: Failed\n");
+		return ret;
+	}
+
+	/* FM PCD KgSchemeDelete */
+	ret = FM_PCD_KgSchemeDelete(dpaa_intf->scheme_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PCD_KgSchemeDelete: Failed\n");
+		return ret;
+	}
+	dpaa_intf->scheme_handle = NULL;
+
+	/* FM PCD NetEnvCharacteristicsDelete */
+	ret = FM_PCD_NetEnvCharacteristicsDelete(dpaa_intf->netenv_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PCD_NetEnvCharacteristicsDelete: Failed\n");
+		return ret;
+	}
+	dpaa_intf->netenv_handle = NULL;
+
+	/* FM PORT Close */
+	FM_PORT_Close(dpaa_intf->port_handle);
+	dpaa_intf->port_handle = NULL;
+
+	/* Set scheme count to 0 */
+	dpaa_intf->scheme_count = 0;
+
+	return 0;
+}
+
+int dpaa_fm_init(void)
+{
+	t_Handle fman_handle;
+	t_Handle pcd_handle;
+	t_FmPcdParams fmPcdParams = {0};
+	/* Hard-coded : fman id 0 since one fman is present in LS104x */
+	int fman_id = 0, ret;
+
+	dpaa_read_fm_config_from_file();
+
+	/* FM Open */
+	fman_handle = FM_Open(fman_id);
+	if (!fman_handle) {
+		DPAA_PMD_ERR("FM_Open: Failed\n");
+		return -1;
+	}
+
+	/* FM PCD Open */
+	fmPcdParams.h_Fm = fman_handle;
+	fmPcdParams.prsSupport = true;
+	fmPcdParams.kgSupport = true;
+	pcd_handle = FM_PCD_Open(&fmPcdParams);
+	if (!pcd_handle) {
+		DPAA_PMD_ERR("FM_PCD_Open: Failed\n");
+		return -1;
+	}
+
+	/* FM PCD Enable */
+	ret = FM_PCD_Enable(pcd_handle);
+	if (ret) {
+		DPAA_PMD_ERR("FM_PCD_Enable: Failed\n");
+		return -1;
+	}
+
+	/* Set fman and pcd handle in fm info */
+	fm_info.fman_handle = fman_handle;
+	fm_info.pcd_handle = pcd_handle;
+
+	return 0;
+}
+
+/* Apply PCD configuration on interface */
+static inline int set_port_pcd(struct dpaa_if *dpaa_intf)
+{
+	int ret = 0;
+	ioc_fm_port_pcd_params_t pcd_param;
+	ioc_fm_port_pcd_prs_params_t prs_param;
+	ioc_fm_port_pcd_kg_params_t  kg_param;
+	/* PCD support for hash distribution */
+	uint8_t pcd_support = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG;
+
+	memset(&pcd_param, 0, sizeof(pcd_param));
+	memset(&prs_param, 0, sizeof(prs_param));
+	memset(&kg_param, 0, sizeof(kg_param));
+
+	/* Set parse params */
+	prs_param.first_prs_hdr = HEADER_TYPE_ETH;
+
+	/* Set kg params */
+	kg_param.scheme_ids[0] = dpaa_intf->scheme_handle;
+	kg_param.num_of_schemes = dpaa_intf->scheme_count;
+
+	/* Set pcd params */
+	pcd_param.net_env_id = dpaa_intf->netenv_handle;
+	pcd_param.pcd_support = pcd_support;
+	pcd_param.p_kg_params = &kg_param;
+	pcd_param.p_prs_params = &prs_param;
+
+	/* FM PORT Disable */
+	ret = FM_PORT_Disable(dpaa_intf->port_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PORT_Disable: Failed\n");
+		return ret;
+	}
+
+	/* FM PORT SetPCD */
+	ret = FM_PORT_SetPCD(dpaa_intf->port_handle, &pcd_param);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PORT_SetPCD: Failed\n");
+		return ret;
+	}
+
+	/* FM PORT Enable */
+	ret = FM_PORT_Enable(dpaa_intf->port_handle);
+	if (ret != E_OK) {
+		DPAA_PMD_ERR("FM_PORT_Enable: Failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/* Set PCD NetEnv and Scheme */
+static inline int set_pcd_netenv_scheme(struct dpaa_if *dpaa_intf,
+					uint64_t req_dist_set)
+{
+	int ret = -1;
+	ioc_fm_pcd_net_env_params_t dist_units;
+	ioc_fm_pcd_kg_scheme_params_t scheme_params;
+
+	/* Set PCD NetEnvCharacteristics */
+	memset(&dist_units, 0, sizeof(dist_units));
+	memset(&scheme_params, 0, sizeof(scheme_params));
+
+	/* Set dist unit header type */
+	set_dist_units(&dist_units, req_dist_set);
+
+	/* FM PCD NetEnvCharacteristicsSet */
+	dpaa_intf->netenv_handle = FM_PCD_NetEnvCharacteristicsSet(
+					fm_info.pcd_handle, &dist_units);
+	if (!dpaa_intf->netenv_handle) {
+		DPAA_PMD_ERR("FM_PCD_NetEnvCharacteristicsSet: Failed\n");
+		return -1;
+	}
+
+	fm_model.netenv_devid[dpaa_intf->ifid] =
+					GetDeviceId(dpaa_intf->netenv_handle);
+	scheme_params.scm_id.relative_scheme_id = dpaa_intf->ifid;
+
+	/* Set PCD Scheme params */
+	ret = set_scheme_params(&scheme_params, &dist_units, dpaa_intf);
+	if (ret) {
+		DPAA_PMD_ERR("Set scheme params: Failed\n");
+		return ret;
+	}
+
+	/* FM PCD KgSchemeSet */
+	dpaa_intf->scheme_handle = FM_PCD_KgSchemeSet(
+					fm_info.pcd_handle, &scheme_params);
+	if (!dpaa_intf->scheme_handle) {
+		DPAA_PMD_ERR("FM_PCD_KgSchemeSet: Failed\n");
+		return -1;
+	}
+
+	fm_model.scheme_devid[dpaa_intf->ifid] =
+					GetDeviceId(dpaa_intf->scheme_handle);
+	dpaa_intf->scheme_count++;
+	return 0;
+}
+
+
+static inline int get_port_type(struct fman_if *fif)
+{
+	if (fif->mac_type == fman_mac_1g) {
+		return e_FM_PORT_TYPE_RX;
+	} else if (fif->mac_type == fman_mac_10g) {
+		return e_FM_PORT_TYPE_RX_10G;
+	} else {
+		DPAA_PMD_ERR("MAC type unsupported\n");
+		return -1;
+	}
+}
+
+static inline int set_fm_port_handle(struct dpaa_if *dpaa_intf)
+{
+	t_FmPortParams	fm_port_params;
+
+	/* FMAN mac indexes mappings */
+	uint8_t mac_idx[] = {-1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1};
+
+	/* Memset FM port params */
+	memset(&fm_port_params, 0, sizeof(fm_port_params));
+
+	/* Set FM port params */
+	fm_port_params.h_Fm = fm_info.fman_handle;
+	fm_port_params.portType = get_port_type(dpaa_intf->fif);
+	fm_port_params.portId = mac_idx[dpaa_intf->fif->mac_idx];
+
+	/* FM PORT Open */
+	dpaa_intf->port_handle = FM_PORT_Open(&fm_port_params);
+	if (!dpaa_intf->port_handle) {
+		DPAA_PMD_ERR("FM_PORT_Open: Failed\n");
+		return -1;
+	}
+
+	fm_model.fm_port_params[dpaa_intf->ifid] = fm_port_params;
+
+	return 0;
+}
+
+int dpaa_fm_config(struct rte_eth_dev *dev, uint64_t req_dist_set)
+{
+	struct dpaa_if *dpaa_intf = dev->data->dev_private;
+	int ret;
+
+	if (dpaa_intf->port_handle) {
+		if (dpaa_fm_deconfig(dpaa_intf))
+			DPAA_PMD_ERR("DPAA FM deconfig failed\n");
+	}
+	dpaa_intf->nb_rx_queues = dev->data->nb_rx_queues;
+
+	/* Open FM Port and set it in port info */
+	ret = set_fm_port_handle(dpaa_intf);
+	if (ret) {
+		DPAA_PMD_ERR("Set FM Port handle: Failed\n");
+		return -1;
+	}
+
+	/* Set PCD netenv and scheme */
+	ret = set_pcd_netenv_scheme(dpaa_intf, req_dist_set);
+	if (ret) {
+		DPAA_PMD_ERR("Set PCD NetEnv and Scheme: Failed\n");
+		return -1;
+	}
+
+	/* Set Port PCD */
+	ret = set_port_pcd(dpaa_intf);
+	if (ret) {
+		DPAA_PMD_ERR("Set Port PCD: Failed\n");
+		return -1;
+	}
+
+	fm_model.dev_count++;
+
+	return 0;
+}
+
+/* De-initialization of FM */
+int dpaa_fm_term(void)
+{
+	t_Handle fman_handle = NULL;
+	t_Handle pcd_handle = NULL;
+	int ret;
+
+	fman_handle = fm_info.fman_handle;
+	pcd_handle = fm_info.pcd_handle;
+
+	/* FM PCD Disable */
+	ret = FM_PCD_Disable(pcd_handle);
+	if (ret) {
+		DPAA_PMD_ERR("FM_PCD_Disable: Failed\n");
+		return -1;
+	}
+
+	/* FM PCD Close */
+	FM_PCD_Close(pcd_handle);
+
+	/* FM Close */
+	FM_Close(fman_handle);
+
+	ret = remove(fm_log);
+	if (ret)
+		DPAA_PMD_ERR("File remove successfully\n");
+
+	return 0;
+}
diff --git a/drivers/net/dpaa/dpaa_flow.h b/drivers/net/dpaa/dpaa_flow.h
new file mode 100644
index 000000000000..4f7a95604abd
--- /dev/null
+++ b/drivers/net/dpaa/dpaa_flow.h
@@ -0,0 +1,41 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright 2017 NXP
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of NXP nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __DPAA_FLOW_H__
+#define __DPAA_FLOW_H__
+
+int dpaa_fm_init(void);
+int dpaa_fm_term(void);
+int dpaa_fm_config(struct rte_eth_dev *dev, uint64_t req_dist_set);
+int dpaa_fm_deconfig(struct dpaa_if *dpaa_intf);
+void dpaa_write_fm_config_to_file(void);
+
+#endif
diff --git a/drivers/net/dpaa/fmlib/dpaa_integration.h b/drivers/net/dpaa/fmlib/dpaa_integration.h
new file mode 100644
index 000000000000..e399f308c3a9
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/dpaa_integration.h
@@ -0,0 +1,84 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2009-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPAA_INTEGRATION_H
+#define __DPAA_INTEGRATION_H
+
+#include "ncsw_ext.h"
+
+#define DPAA_VERSION	11
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS	64	/**< Number of buffers pools */
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM	2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS	6
+#define FM_MAX_NUM_OF_10G_MACS	2
+#define FM_MAX_NUM_OF_MACS	(FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS	6
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS	(FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS	(FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS		4	/**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS		256	/**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS		16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES		256	/**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES	32	/**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS	256	/**< Number of classification plan entries. */
+
+#define FM_MAX_NUM_OF_PFC_PRIORITIES		8
+
+#endif /* __DPAA_INTEGRATION_H */
diff --git a/drivers/net/dpaa/fmlib/fm_ext.h b/drivers/net/dpaa/fmlib/fm_ext.h
new file mode 100644
index 000000000000..f252d8d10c0b
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/fm_ext.h
@@ -0,0 +1,1206 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_EXT_H
+#define __FM_EXT_H
+
+#include "ncsw_ext.h"
+#include "dpaa_integration.h"
+
+
+#define FM_IOC_TYPE_BASE	(NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE	(NCSW_IOC_TYPE_BASE+3)
+
+/*#define FM_IOCTL_DBG*/
+
+#if defined(FM_IOCTL_DBG)
+	#define _fm_ioctl_dbg(format, arg...) \
+	printk("fm ioctl [%s:%u](cpu:%u) - " format, \
+		__func__, __LINE__, smp_processor_id(), ##arg)
+#else
+#   define _fm_ioctl_dbg(arg...)
+#endif
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_ncsw_grp	NetCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+#define NCSW_IOC_TYPE_BASE	0xe0	/**< defines the IOCTL type for all
+						the NCSW Linux module commands */
+
+
+/**************************************************************************//**
+ @Group	lnx_usr_FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group	lnx_usr_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+
+		The FM module is the main driver module and is a mandatory module
+		for FM driver users. This module must be initialized first prior
+		to any other drivers modules.
+		The FM is a "singleton" module. It is responsible of the common
+		HW modules: FPM, DMA, common QMI and common BMI initializations and
+		run-time control routines. This module must be initialized always
+		when working with any of the FM modules.
+		NOTE - We assume that the FM library will be initialized only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmPortType {
+	e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+	e_FM_PORT_TYPE_RX,			/**< 1G Rx port */
+	e_FM_PORT_TYPE_RX_10G,		/**< 10G Rx port */
+	e_FM_PORT_TYPE_TX,			/**< 1G Tx port */
+	e_FM_PORT_TYPE_TX_10G,		/**< 10G Tx port */
+	e_FM_PORT_TYPE_DUMMY
+} e_FmPortType;
+
+/**************************************************************************//**
+ @Description   Parse results memory layout
+*//***************************************************************************/
+typedef struct t_FmPrsResult {
+	volatile uint8_t	lpid;		/**< Logical port id */
+	volatile uint8_t	shimr;		/**< Shim header result  */
+	volatile uint16_t	l2r;		/**< Layer 2 result */
+	volatile uint16_t	l3r;		/**< Layer 3 result */
+	volatile uint8_t	l4r;		/**< Layer 4 result */
+	volatile uint8_t	cplan;		/**< Classification plan id */
+	volatile uint16_t	nxthdr;		/**< Next Header  */
+	volatile uint16_t	cksum;		/**< Running-sum */
+	volatile uint16_t	flags_frag_off;	/**< Flags & fragment-offset field of the last IP-header */
+	volatile uint8_t	route_type;	/**< Routing type field of a IPv6 routing extension header */
+	volatile uint8_t	rhp_ip_valid;	/**< Routing Extension Header Present; last bit is IP valid */
+	volatile uint8_t	shim_off[2];	/**< Shim offset */
+	volatile uint8_t	ip_pid_off;	/**< IP PID (last IP-proto) offset */
+	volatile uint8_t	eth_off;		/**< ETH offset */
+	volatile uint8_t	llc_snap_off;	/**< LLC_SNAP offset */
+	volatile uint8_t	vlan_off[2];	/**< VLAN offset */
+	volatile uint8_t	etype_off;	/**< ETYPE offset */
+	volatile uint8_t	pppoe_off;	/**< PPP offset */
+	volatile uint8_t	mpls_off[2];	/**< MPLS offset */
+	volatile uint8_t	ip_off[2];	/**< IP offset */
+	volatile uint8_t	gre_off;		/**< GRE offset */
+	volatile uint8_t	l4_off;		/**< Layer 4 offset */
+	volatile uint8_t	nxthdr_off;	/**< Parser end point */
+} __attribute__((__packed__)) t_FmPrsResult;
+
+/**************************************************************************//**
+ @Collection   FM Parser results
+*//***************************************************************************/
+#define FM_PR_L2_VLAN_STACK	0x00000100  /**< Parse Result: VLAN stack */
+#define FM_PR_L2_ETHERNET	0x00008000  /**< Parse Result: Ethernet*/
+#define FM_PR_L2_VLAN		0x00004000  /**< Parse Result: VLAN */
+#define FM_PR_L2_LLC_SNAP	0x00002000  /**< Parse Result: LLC_SNAP */
+#define FM_PR_L2_MPLS		0x00001000  /**< Parse Result: MPLS */
+#define FM_PR_L2_PPPoE		0x00000800  /**< Parse Result: PPPoE */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_CMD_FCO		0x80000000  /**< Frame queue Context Override */
+#define FM_FD_CMD_RPD		0x40000000  /**< Read Prepended Data */
+#define FM_FD_CMD_UPD		0x20000000  /**< Update Prepended Data */
+#define FM_FD_CMD_DTC		0x10000000  /**< Do L4 Checksum */
+#define FM_FD_CMD_DCL4C		0x10000000  /**< Didn't calculate L4 Checksum */
+#define FM_FD_CMD_CFQ		0x00ffffff  /**< Confirmation Frame Queue */
+
+#define FM_FD_ERR_UNSUPPORTED_FORMAT	0x04000000  /**< Not for Rx-Port! Unsupported Format */
+#define FM_FD_ERR_LENGTH		0x02000000  /**< Not for Rx-Port! Length Error */
+#define FM_FD_ERR_DMA		0x01000000  /**< DMA Data error */
+
+#define FM_FD_IPR			0x00000001  /**< IPR frame (not error) */
+
+#define FM_FD_ERR_IPR_NCSP		(0x00100000 | FM_FD_IPR)	/**< IPR non-consistent-sp */
+#define FM_FD_ERR_IPR		(0x00200000 | FM_FD_IPR)	/**< IPR error */
+#define FM_FD_ERR_IPR_TO		(0x00300000 | FM_FD_IPR)	/**< IPR timeout */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_FD_ERR_CRE		0x00200000
+#define FM_FD_ERR_CHE		0x00100000
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_FD_ERR_PHYSICAL		0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+							error (SGMII and TBI modes), FIFO parity error. PHY
+							Sequence error, PHY error control character detected. */
+#define FM_FD_ERR_SIZE		0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_FD_ERR_CLS_DISCARD	0x00020000  /**< classification discard */
+#define FM_FD_ERR_EXTRACTION		0x00008000  /**< Extract Out of Frame */
+#define FM_FD_ERR_NO_SCHEME		0x00004000  /**< No Scheme Selected */
+#define FM_FD_ERR_KEYSIZE_OVERFLOW	0x00002000  /**< Keysize Overflow */
+#define FM_FD_ERR_COLOR_RED		0x00000800  /**< Frame color is red */
+#define FM_FD_ERR_COLOR_YELLOW	0x00000400  /**< Frame color is yellow */
+#define FM_FD_ERR_ILL_PLCR		0x00000200  /**< Illegal Policer Profile selected */
+#define FM_FD_ERR_PLCR_FRAME_LEN	0x00000100  /**< Policer frame length error */
+#define FM_FD_ERR_PRS_TIMEOUT	0x00000080  /**< Parser Time out Exceed */
+#define FM_FD_ERR_PRS_ILL_INSTRUCT	0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_FD_ERR_PRS_HDR_ERR	0x00000020  /**< Header error was identified during parsing */
+#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008  /**< Frame parsed beyind 256 first bytes */
+
+#define FM_FD_TX_STATUS_ERR_MASK	(FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+					FM_FD_ERR_LENGTH		| \
+					FM_FD_ERR_DMA) /**< TX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_MASK	(FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+					FM_FD_ERR_LENGTH		| \
+					FM_FD_ERR_DMA		| \
+					FM_FD_ERR_IPR		| \
+					FM_FD_ERR_IPR_TO		| \
+					FM_FD_ERR_IPR_NCSP		| \
+					FM_FD_ERR_PHYSICAL		| \
+					FM_FD_ERR_SIZE		| \
+					FM_FD_ERR_CLS_DISCARD	| \
+					FM_FD_ERR_COLOR_RED		| \
+					FM_FD_ERR_COLOR_YELLOW	| \
+					FM_FD_ERR_ILL_PLCR		| \
+					FM_FD_ERR_PLCR_FRAME_LEN	| \
+					FM_FD_ERR_EXTRACTION	| \
+					FM_FD_ERR_NO_SCHEME		| \
+					FM_FD_ERR_KEYSIZE_OVERFLOW	| \
+					FM_FD_ERR_PRS_TIMEOUT	| \
+					FM_FD_ERR_PRS_ILL_INSTRUCT	| \
+					FM_FD_ERR_PRS_HDR_ERR	| \
+					FM_FD_ERR_BLOCK_LIMIT_EXCEEDED) /**< RX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_NON_FM	0x00400000  /**< non Frame-Manager error */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum e_FmExceptions {
+	e_FM_EX_DMA_BUS_ERROR = 0,	/**< DMA bus error. */
+	e_FM_EX_DMA_READ_ECC,		/**< Read Buffer ECC error (Valid for FM rev < 6)*/
+	e_FM_EX_DMA_SYSTEM_WRITE_ECC,	/**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+	e_FM_EX_DMA_FM_WRITE_ECC,	/**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+	e_FM_EX_DMA_SINGLE_PORT_ECC,	/**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+	e_FM_EX_FPM_STALL_ON_TASKS,	/**< Stall of tasks on FPM */
+	e_FM_EX_FPM_SINGLE_ECC,		/**< Single ECC on FPM. */
+	e_FM_EX_FPM_DOUBLE_ECC,		/**< Double ECC error on FPM ram access */
+	e_FM_EX_QMI_SINGLE_ECC,		/**< Single ECC on QMI. */
+	e_FM_EX_QMI_DOUBLE_ECC,		/**< Double bit ECC occurred on QMI */
+	e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+	e_FM_EX_BMI_LIST_RAM_ECC,	/**< Linked List RAM ECC error */
+	e_FM_EX_BMI_STORAGE_PROFILE_ECC,	/**< Storage Profile ECC Error */
+	e_FM_EX_BMI_STATISTICS_RAM_ECC,	/**< Statistics Count RAM ECC Error Enable */
+	e_FM_EX_BMI_DISPATCH_RAM_ECC,	/**< Dispatch RAM ECC Error Enable */
+	e_FM_EX_IRAM_ECC,		/**< Double bit ECC occurred on IRAM*/
+	e_FM_EX_MURAM_ECC		/**< Double bit ECC occurred on MURAM*/
+} e_FmExceptions;
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmDmaSwapOption {
+	e_FM_DMA_NO_SWP,	/**< No swap, transfer data as is.*/
+	e_FM_DMA_SWP_PPC_LE,	/**< The transferred data should be swapped
+					in PowerPc Little Endian mode. */
+	e_FM_DMA_SWP_BE		/**< The transferred data should be swapped
+					in Big Endian mode */
+} e_FmDmaSwapOption;
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOption {
+	e_FM_DMA_NO_STASH = 0,	/**< Cacheable, no Allocate (No Stashing) */
+	e_FM_DMA_STASH = 1	/**< Cacheable and Allocate (Stashing on) */
+} e_FmDmaCacheOption;
+/**************************************************************************//**
+ @Group	lnx_usr_FM_init_grp FM Initialization Unit
+
+ @Description   FM Initialization Unit
+
+		Initialization Flow
+		Initialization of the FM Module will be carried out by the application
+		according to the following sequence:
+		-  Calling the configuration routine with basic parameters.
+		-  Calling the advance initialization routines to change driver's defaults.
+		-  Calling the initialization routine.
+
+ @{
+*//***************************************************************************/
+
+t_Handle FM_Open(uint8_t id);
+void	FM_Close(t_Handle h_Fm);
+
+
+/**************************************************************************//**
+ @Description   A structure for defining buffer prefix area content.
+*//***************************************************************************/
+typedef struct t_FmBufferPrefixContent {
+	uint16_t	privDataSize;	/**< Number of bytes to be left at the beginning
+					of the external buffer; Note that the private-area will
+					start from the base of the buffer address. */
+	bool	passPrsResult;	/**< TRUE to pass the parse result to/from the FM;
+					User may use FM_PORT_GetBufferPrsResult() in order to
+					get the parser-result from a buffer. */
+	bool	passTimeStamp;	/**< TRUE to pass the timeStamp to/from the FM
+					User may use FM_PORT_GetBufferTimeStamp() in order to
+					get the parser-result from a buffer. */
+	bool	passHashResult;	/**< TRUE to pass the KG hash result to/from the FM
+					User may use FM_PORT_GetBufferHashResult() in order to
+					get the parser-result from a buffer. */
+	bool	passAllOtherPCDInfo;/**< Add all other Internal-Context information:
+					AD, hash-result, key, etc. */
+	uint16_t	dataAlign;	/**< 0 to use driver's default alignment [64],
+					other value for selecting a data alignment (must be a power of 2);
+					if write optimization is used, must be >= 16. */
+	uint8_t	manipExtraSpace;	/**< Maximum extra size needed (insertion-size minus removal-size);
+					Note that this field impacts the size of the buffer-prefix
+					(i.e. it pushes the data offset);
+					This field is irrelevant if DPAA_VERSION==10 */
+} t_FmBufferPrefixContent;
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+		buffer pools used by a port or storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPoolParams {
+	uint8_t		id;	/**< External buffer pool id */
+	uint16_t		size;   /**< External buffer pool buffer size */
+} t_FmExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+		buffer pools allocated in the BM and used by a port or a
+		storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPools {
+	uint8_t		numOfPoolsUsed;	/**< Number of pools use by this port */
+	t_FmExtPoolParams	extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+						/**< Parameters for each port */
+} t_FmExtPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining backup BM Pools.
+*//***************************************************************************/
+typedef struct t_FmBackupBmPools {
+	uint8_t	numOfBackupPools;	/**< Number of BM backup pools -
+						must be smaller than the total number of
+						pools defined for the specified port.*/
+	uint8_t	poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+					/**< numOfBackupPools pool id's, specifying which
+						pools should be used only as backup. Pool
+						id's specified here must be a subset of the
+						pools used by the specified port.*/
+} t_FmBackupBmPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct t_FmBufPoolDepletion {
+	bool	poolsGrpModeEnable;		/**< select mode in which pause frames will be sent after
+							a number of pools (all together!) are depleted */
+	uint8_t	numOfPools;			/**< the number of depleted pools that will invoke
+							pause frames transmission. */
+	bool	poolsToConsider[BM_MAX_NUM_OF_POOLS];
+							/**< For each pool, TRUE if it should be considered for
+							depletion (Note - this pool must be used by this port!). */
+	bool	singlePoolModeEnable;		/**< select mode in which pause frames will be sent after
+							a single-pool is depleted; */
+	bool	poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
+							/**< For each pool, TRUE if it should be considered for
+							depletion (Note - this pool must be used by this port!) */
+#if (DPAA_VERSION >= 11)
+	bool	pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
+							/**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmBufPoolDepletion;
+
+
+/** @} */ /* end of lnx_usr_FM_init_grp group */
+
+
+/**************************************************************************//**
+ @Group	lnx_usr_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+		The FM driver provides a set of control routines.
+		These routines may only be called after the module was fully
+		initialized (both configuration and initialization routines were
+		called). They are typically used to get information from hardware
+		(status, counters/statistics, revision etc.), to modify a current
+		state or to force/enable a required action. Run-time control may
+		be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_VALID_PORTS   (FM_MAX_NUM_OF_OH_PORTS +	\
+					FM_MAX_NUM_OF_1G_RX_PORTS +	\
+					FM_MAX_NUM_OF_10G_RX_PORTS +   \
+					FM_MAX_NUM_OF_1G_TX_PORTS +	\
+					FM_MAX_NUM_OF_10G_TX_PORTS)	/**< Number of available FM ports */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A structure for Port bandwidth requirement. Port is identified
+		by type and relative id.
+*//***************************************************************************/
+typedef struct t_FmPortBandwidth {
+	e_FmPortType	type;	/**< FM port type */
+	uint8_t		relativePortId; /**< Type relative port id */
+	uint8_t		bandwidth;	/**< bandwidth - (in term of percents) */
+} t_FmPortBandwidth;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+		The user should state the ports requiring bandwidth in terms of
+		percentage - i.e. all port's bandwidths in the array must add
+		up to 100.
+*//***************************************************************************/
+typedef struct t_FmPortsBandwidthParams {
+	uint8_t		numOfPorts;	/**< The number of relevant ports, which is the
+						number of valid entries in the array below */
+	t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
+						/**< for each port, it's bandwidth (all port's
+						bandwidths must add up to 100.*/
+} t_FmPortsBandwidthParams;
+
+/**************************************************************************//**
+ @Description   Enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmCounters {
+	e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,		/**< QMI total enqueued frames counter */
+	e_FM_COUNTERS_DEQ_TOTAL_FRAME,		/**< QMI total dequeued frames counter */
+	e_FM_COUNTERS_DEQ_0,				/**< QMI 0 frames from QMan counter */
+	e_FM_COUNTERS_DEQ_1,				/**< QMI 1 frames from QMan counter */
+	e_FM_COUNTERS_DEQ_2,				/**< QMI 2 frames from QMan counter */
+	e_FM_COUNTERS_DEQ_3,				/**< QMI 3 frames from QMan counter */
+	e_FM_COUNTERS_DEQ_FROM_DEFAULT,		/**< QMI dequeue from default queue counter */
+	e_FM_COUNTERS_DEQ_FROM_CONTEXT,		/**< QMI dequeue from FQ context counter */
+	e_FM_COUNTERS_DEQ_FROM_FD,			/**< QMI dequeue from FD command field counter */
+	e_FM_COUNTERS_DEQ_CONFIRM			/**< QMI dequeue confirm counter */
+} e_FmCounters;
+
+/**************************************************************************//**
+ @Description   A structure for returning FM revision information
+*//***************************************************************************/
+typedef struct t_FmRevisionInfo {
+	uint8_t	majorRev;		/**< Major revision */
+	uint8_t	minorRev;		/**< Minor revision */
+} t_FmRevisionInfo;
+
+/**************************************************************************//**
+ @Description   A structure for returning FM ctrl code revision information
+*//***************************************************************************/
+typedef struct t_FmCtrlCodeRevisionInfo {
+	uint16_t	packageRev;		/**< Package revision */
+	uint8_t	majorRev;		/**< Major revision */
+	uint8_t	minorRev;		/**< Minor revision */
+} t_FmCtrlCodeRevisionInfo;
+
+/**************************************************************************//**
+ @Description   A Structure for obtaining FM controller monitor values
+*//***************************************************************************/
+typedef struct t_FmCtrlMon {
+	uint8_t percentCnt[2];	/**< Percentage value */
+} t_FmCtrlMon;
+
+/**************************************************************************//**
+ @Function	FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+ @Param[in]	p_PortsBandwidth	A structure of ports bandwidths in percentage, i.e.
+					total must equal 100.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
+
+/**************************************************************************//**
+ @Function	FM_GetRevision
+
+ @Description   Returns the FM revision
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+ @Param[out]	p_FmRevisionInfo	A structure of revision information parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+/**************************************************************************//**
+ @Function	FM_GetFmanCtrlCodeRevision
+
+ @Description   Returns the Fman controller code revision
+		(Not implemented in fm-lib just yet!)
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+ @Param[out]	p_RevisionInfo	A structure of revision information parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo);
+
+/**************************************************************************//**
+ @Function	FM_GetCounter
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in]	h_Fm	A handle to an FM Module.
+ @Param[in]	counter	The requested counter.
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_Init().
+		Note that it is user's responsibility to call this routine only
+		for enabled counters, and there will be no indication if a
+		disabled counter is accessed.
+*//***************************************************************************/
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
+
+/**************************************************************************//**
+ @Function	FM_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	h_Fm	A handle to an FM Module.
+ @Param[in]	counter	The requested counter.
+ @Param[in]	val	The requested value to be written into the counter.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonStart
+
+ @Description   Start monitoring utilization of all available FM controllers.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+uint32_t FM_CtrlMonStart(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonStop
+
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+uint32_t FM_CtrlMonStop(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonGetCounters
+
+ @Description   Obtain FM controller utilization parameters.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+ @Param[in]	fmCtrlIndex	FM Controller index for that utilization results
+				are requested.
+ @Param[in]	p_Mon	Pointer to utilization results structure.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+uint32_t FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
+
+
+/**************************************************************************//*
+ @Function	FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]	h_Fm		A handle to an FM Module.
+ @Param[in]	exception	An exception to be forced.
+
+ @Return	E_OK on success; Error code if the exception is not enabled,
+		or is not able to create interrupt.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
+/** @} */ /* end of lnx_usr_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_usr_FM_lib_grp group */
+/** @} */ /* end of lnx_usr_FM_grp group */
+
+
+/**************************************************************************//**
+@Description   FM Char device ioctls
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection	FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME		"fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE	0
+#define DEV_FM_PCD_MINOR_BASE	(DEV_FM_MINOR_BASE + 1)				/*/dev/fmx-pcd */
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)				/*/dev/fmx-port-ohy */
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)   /*/dev/fmx-port-rxy */
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
+#define DEV_FM_MAX_MINORS	(DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
+
+#define FM_IOC_NUM(n)	(n)
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+70)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS	64
+
+
+/**************************************************************************//**
+ @Description   Enum for defining port types
+		(must match enum e_FmPortType defined in fm_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+	e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+	e_IOC_FM_PORT_TYPE_RX,			/**< 1G Rx port */
+	e_IOC_FM_PORT_TYPE_RX_10G,		/**< 10G Rx port */
+	e_IOC_FM_PORT_TYPE_TX,			/**< 1G Tx port */
+	e_IOC_FM_PORT_TYPE_TX_10G,		/**< 10G Tx port */
+	e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+		The FM module is the main driver module and is a mandatory module
+		for FM driver users. Before any further module initialization,
+		this module must be initialized.
+		The FM is a "single-tone" module. It is responsible of the common
+		HW modules: FPM, DMA, common QMI, common BMI initializations and
+		run-time control routines. This module must be initialized always
+		when working with any of the FM modules.
+		NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+	e_IOC_FM_EX_DMA_BUS_ERROR,		/**< DMA bus error. */
+	e_IOC_EX_DMA_READ_ECC,		/**< Read Buffer ECC error (Valid for FM rev < 6)*/
+	e_IOC_EX_DMA_SYSTEM_WRITE_ECC,	/**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+	e_IOC_EX_DMA_FM_WRITE_ECC,	/**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+	e_IOC_EX_DMA_SINGLE_PORT_ECC,	/**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+	e_IOC_EX_FPM_STALL_ON_TASKS,	/**< Stall of tasks on FPM */
+	e_IOC_EX_FPM_SINGLE_ECC,		/**< Single ECC on FPM. */
+	e_IOC_EX_FPM_DOUBLE_ECC,		/**< Double ECC error on FPM ram access */
+	e_IOC_EX_QMI_SINGLE_ECC,		/**< Single ECC on QMI. */
+	e_IOC_EX_QMI_DOUBLE_ECC,		/**< Double bit ECC occurred on QMI */
+	e_IOC_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+	e_IOC_EX_BMI_LIST_RAM_ECC,	/**< Linked List RAM ECC error */
+	e_IOC_EX_BMI_STORAGE_PROFILE_ECC,	/**< Storage Profile ECC Error */
+	e_IOC_EX_BMI_STATISTICS_RAM_ECC,	/**< Statistics Count RAM ECC Error Enable */
+	e_IOC_EX_BMI_DISPATCH_RAM_ECC,	/**< Dispatch RAM ECC Error Enable */
+	e_IOC_EX_IRAM_ECC,		/**< Double bit ECC occurred on IRAM*/
+	e_IOC_EX_MURAM_ECC		/**< Double bit ECC occurred on MURAM*/
+} ioc_fm_exceptions;
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+		The FM driver provides a set of control routines for each module.
+		These routines may only be called after the module was fully
+		initialized (both configuration and initialization routines were
+		called). They are typically used to get information from hardware
+		(status, counters/statistics, revision etc.), to modify a current
+		state or to force/enable a required action. Run-time control may
+		be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+ *//***************************************************************************/
+#define IOC_FM_MAX_NUM_OF_VALID_PORTS  (FM_MAX_NUM_OF_OH_PORTS + \
+					FM_MAX_NUM_OF_1G_RX_PORTS +  \
+					FM_MAX_NUM_OF_10G_RX_PORTS + \
+					FM_MAX_NUM_OF_1G_TX_PORTS +  \
+					FM_MAX_NUM_OF_10G_TX_PORTS)
+/* @} */
+
+/**************************************************************************//**
+ @Description   Structure for Port bandwidth requirement. Port is identified
+		by type and relative id.
+		(must be identical to t_FmPortBandwidth defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_t {
+	ioc_fm_port_type	type;	/**< FM port type */
+	uint8_t		relative_port_id; /**< Type relative port id */
+	uint8_t		bandwidth;	/**< bandwidth - (in term of percents) */
+} ioc_fm_port_bandwidth_t;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+		The user should state the ports requiring bandwidth in terms of
+		percentage - i.e. all port's bandwidths in the array must add
+		up to 100.
+		(must be identical to t_FmPortsBandwidthParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_params {
+	uint8_t			num_of_ports;
+				/**< num of ports listed in the array below */
+	ioc_fm_port_bandwidth_t	ports_bandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
+				/**< for each port, it's bandwidth (all port's
+				bandwidths must add up to 100.*/
+} ioc_fm_port_bandwidth_params;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+	e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,		/**< QMI total enqueued frames counter */
+	e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,		/**< QMI total dequeued frames counter */
+	e_IOC_FM_COUNTERS_DEQ_0,			/**< QMI 0 frames from QMan counter */
+	e_IOC_FM_COUNTERS_DEQ_1,			/**< QMI 1 frames from QMan counter */
+	e_IOC_FM_COUNTERS_DEQ_2,			/**< QMI 2 frames from QMan counter */
+	e_IOC_FM_COUNTERS_DEQ_3,			/**< QMI 3 frames from QMan counter */
+	e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,		/**< QMI dequeue from default queue counter */
+	e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,		/**< QMI dequeue from FQ context counter */
+	e_IOC_FM_COUNTERS_DEQ_FROM_FD,		/**< QMI dequeue from FD command field counter */
+	e_IOC_FM_COUNTERS_DEQ_CONFIRM,		/**< QMI dequeue confirm counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+	void		*obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   A structure for returning revision information
+		(must match struct t_FmRevisionInfo declared in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+	uint8_t	major;		/**< Major revision */
+	uint8_t	minor;		/**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   A structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+	ioc_fm_counters cnt;		/**< The requested counter */
+	uint32_t	val;		/**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+typedef union ioc_fm_api_version_t {
+	struct {
+	uint8_t major;
+	uint8_t minor;
+	uint8_t respin;
+	uint8_t reserved;
+	} version;
+	uint32_t ver;
+} ioc_fm_api_version_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+		buffer pools used by a port or storage-profile.
+		(must be identical to t_FmExtPoolParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pool_params {
+	uint8_t		id;	/**< External buffer pool id */
+	uint16_t		size;   /**< External buffer pool buffer size */
+} ioc_fm_ext_pool_params;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+		buffer pools allocated in the BM and used by a port or a
+		storage-profile.
+		(must be identical to t_FmExtPools defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pools {
+	uint8_t		num_of_pools_used;	/**< Number of pools use by this port */
+	ioc_fm_ext_pool_params  ext_buf_pool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+						/**< Parameters for each port */
+} ioc_fm_ext_pools;
+
+typedef struct ioc_fm_vsp_params_t {
+	void		*p_fm;		/**< A handle to the FM object this VSP related to */
+	ioc_fm_ext_pools	ext_buf_pools;	/**< Which external buffer pools are used
+						(up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
+						parameter associated with Rx / OP port */
+	uint16_t		liodn_offset;	/**< VSP's LIODN offset */
+	struct {
+	ioc_fm_port_type port_type;	/**< Port type */
+	uint8_t	port_id;		/**< Port Id - relative to type */
+	} port_params;
+	uint8_t		relative_profile_id;  /**< VSP Id - relative to VSP's range
+						defined in relevant FM object */
+	void		*id;		/**< return value */
+} ioc_fm_vsp_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct ioc_fm_buf_pool_depletion_t {
+	bool	pools_grp_mode_enable;		/**< select mode in which pause frames will be sent after
+							a number of pools (all together!) are depleted */
+	uint8_t	num_of_pools;			/**< the number of depleted pools that will invoke
+							pause frames transmission. */
+	bool	pools_to_consider[BM_MAX_NUM_OF_POOLS];
+							/**< For each pool, TRUE if it should be considered for
+							depletion (Note - this pool must be used by this port!). */
+	bool	single_pool_mode_enable;		/**< select mode in which pause frames will be sent after
+							a single-pool is depleted; */
+	bool	pools_to_consider_for_single_mode[BM_MAX_NUM_OF_POOLS];
+							/**< For each pool, TRUE if it should be considered for
+							depletion (Note - this pool must be used by this port!) */
+#if (DPAA_VERSION >= 11)
+	bool	pfc_priorities_en[FM_MAX_NUM_OF_PFC_PRIORITIES];
+							/**< This field is used by the MAC as the Priority Enable Vector in the PFC frame
+							which is transmitted */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_buf_pool_depletion_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_buf_pool_depletion_params_t {
+	void	*p_fm_vsp;
+	ioc_fm_buf_pool_depletion_t fm_buf_pool_depletion;
+} ioc_fm_buf_pool_depletion_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+typedef struct ioc_fm_buffer_prefix_content_t {
+	uint16_t	priv_data_size;	/**< Number of bytes to be left at the beginning
+					of the external buffer; Note that the private-area will
+					start from the base of the buffer address. */
+	bool	pass_prs_result;	/**< TRUE to pass the parse result to/from the FM;
+					User may use FM_PORT_GetBufferPrsResult() in order to
+					get the parser-result from a buffer. */
+	bool	pass_time_stamp;	/**< TRUE to pass the timeStamp to/from the FM
+					User may use FM_PORT_GetBufferTimeStamp() in order to
+					get the parser-result from a buffer. */
+	bool	pass_hash_result;	/**< TRUE to pass the KG hash result to/from the FM
+					User may use FM_PORT_GetBufferHashResult() in order to
+					get the parser-result from a buffer. */
+	bool	pass_all_other_pcd_info; /**< Add all other Internal-Context information:
+					AD, hash-result, key, etc. */
+	uint16_t	data_align;	/**< 0 to use driver's default alignment [64],
+					other value for selecting a data alignment (must be a power of 2);
+					if write optimization is used, must be >= 16. */
+	uint8_t	manip_extra_space;	/**< Maximum extra size needed (insertion-size minus removal-size);
+					Note that this field impacts the size of the buffer-prefix
+					(i.e. it pushes the data offset);
+					This field is irrelevant if DPAA_VERSION==10 */
+} ioc_fm_buffer_prefix_content_t;
+
+typedef struct ioc_fm_buffer_prefix_content_params_t {
+	void	*p_fm_vsp;
+	ioc_fm_buffer_prefix_content_t fm_buffer_prefix_content;
+} ioc_fm_buffer_prefix_content_params_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_vsp_config_no_sg_params_t {
+	void	*p_fm_vsp;
+	bool	no_sg;
+} ioc_fm_vsp_config_no_sg_params_t;
+
+typedef struct ioc_fm_vsp_prs_result_params_t {
+	void	*p_fm_vsp;
+	void	*p_data;
+} ioc_fm_vsp_prs_result_params_t;
+#endif
+
+typedef struct fm_ctrl_mon_t {
+	uint8_t	percent_cnt[2];
+} fm_ctrl_mon_t;
+
+typedef struct ioc_fm_ctrl_mon_counters_params_t {
+	uint8_t	fm_ctrl_index;
+	fm_ctrl_mon_t *p_mon;
+} ioc_fm_ctrl_mon_counters_params_t;
+
+/**************************************************************************//**
+ @Function	FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]	ioc_fm_port_bandwidth_params	Port bandwidth percentages,
+ their sum must equal 100.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH				_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_fm_port_bandwidth_params)
+
+/**************************************************************************//**
+ @Function	FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]	ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return	None.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION					_IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function	FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_Init().
+		Note that it is user's responsibilty to call this routine only
+		for enabled counters, and there will be no indication if a
+		disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER					_IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function	FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER					_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function	FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]	ioc_fm_exceptions   An exception to be forced.
+
+ @Return	E_OK on success; Error code if the exception is not enabled,
+		or is not able to create interrupt.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR					_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/**************************************************************************//**
+ @Function	FM_IOC_GET_API_VERSION
+
+ @Description   Reads the FMD IOCTL API version.
+
+ @Param[in,out] ioc_fm_api_version_t The requested counter parameters.
+
+ @Return	Version's value.
+*//***************************************************************************/
+#define FM_IOC_GET_API_VERSION				_IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(7), ioc_fm_api_version_t)
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function	FM_VSP_Config
+
+ @Description   Creates descriptor for the FM VSP module.
+
+		The routine returns a handle (descriptor) to the FM VSP object.
+		This descriptor must be passed as first parameter to all other
+		FM VSP function calls.
+
+		No actual initialization or configuration of FM hardware is
+		done by this routine.
+
+@Param[in]	p_FmVspParams   Pointer to data structure of parameters
+
+ @Retval	Handle to FM VSP object, or NULL for Failure.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_COMPAT				_IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_compat_fm_vsp_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG					_IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_fm_vsp_params_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_Init
+
+ @Description   Initializes the FM VSP module
+
+ @Param[in]	h_FmVsp - FM VSP module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_INIT_COMPAT				_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_INIT					_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_Free
+
+ @Description   Frees all resources that were assigned to FM VSP module.
+
+		Calling this routine invalidates the descriptor.
+
+ @Param[in]	h_FmVsp - FM VSP module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_FREE_COMPAT				_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_FREE					_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+		depletion status of BM pools. It also defines the conditions to activate
+		this functionality. By default, this functionality is disabled.
+
+ @Param[in]	ioc_fm_buf_pool_depletion_params_t	A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION_COMPAT		_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_compat_fm_buf_pool_depletion_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION			_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_fm_buf_pool_depletion_params_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+
+		The prefix will
+		In VSPs defined for Tx ports, if 'passPrsResult', the application
+		should set a value to their offsets in the prefix of
+		the FM will save the first 'privDataSize', than,
+		depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+		and timeStamp, and the packet itself (in this order), to the
+		application buffer, and to offset.
+
+		Calling this routine changes the buffer margins definitions
+		in the internal driver data base from its default
+		configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+				Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+				Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+ @Param[in]	ioc_fm_buffer_prefix_content_params_t   A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_compat_fm_buffer_prefix_content_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT		_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_fm_buffer_prefix_content_params_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_ConfigNoScatherGather
+
+ @Description   Calling this routine changes the possibility to receive S/G frame
+		in the internal driver data base
+		from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
+
+ @Param[in]	ioc_fm_vsp_config_no_sg_params_t	A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_NO_SG_COMPAT			_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_compat_fm_vsp_config_no_sg_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_NO_SG				_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_fm_vsp_config_no_sg_params_t)
+
+/**************************************************************************//**
+ @Function	FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+		In Rx ports this is relevant after reception, if parse
+		result is configured to be part of the data passed to the
+		application. For non Rx ports it may be used to get the pointer
+		of the area in the buffer where parse result should be
+		initialized - if so configured.
+		See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+		configuration.
+
+ @Param[in]	ioc_fm_vsp_prs_result_params_t  A structure holding the required parameters.
+
+ @Return	Parse result pointer on success, NULL if parse result was not
+		configured for this port.
+
+ @Cautions	Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT_COMPAT		_IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_compat_fm_vsp_prs_result_params_t)
+#endif
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT		_IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_fm_vsp_prs_result_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonStart
+
+ @Description   Start monitoring utilization of all available FM controllers.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_START				_IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(15))
+
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonStop
+
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_STOP				_IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(16))
+
+/**************************************************************************//**
+ @Function	FM_CtrlMonGetCounters
+
+ @Description   Obtain FM controller utilization parameters.
+
+		In order to obtain FM controllers utilization the following sequence
+		should be used:
+		-# FM_CtrlMonStart()
+		-# FM_CtrlMonStop()
+		-# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]	ioc_fm_ctrl_mon_counters_params_t	A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_CTRL_MON_GET_COUNTERS_COMPAT		_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_compat_fm_ctrl_mon_counters_params_t)
+#endif
+#define FM_IOC_CTRL_MON_GET_COUNTERS			_IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_fm_ctrl_mon_counters_params_t)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+#define FMD_API_VERSION_MAJOR 21
+#define FMD_API_VERSION_MINOR 1 
+#define FMD_API_VERSION_RESPIN 0
+
+#endif /* __FM_EXT_H */
diff --git a/drivers/net/dpaa/fmlib/fm_lib.c b/drivers/net/dpaa/fmlib/fm_lib.c
new file mode 100644
index 000000000000..2c4fac0c3148
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/fm_lib.c
@@ -0,0 +1,608 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <stdbool.h>
+
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+
+#define MODULE_FM		0x00010000
+#define __ERR_MODULE__	MODULE_FM
+
+#define DEV_TO_ID(p) \
+	do { \
+	t_Device *p_Dev = (t_Device *)p; \
+	p = UINT_TO_PTR(p_Dev->id); \
+	} while(0)
+
+/* #define FM_LIB_DBG */
+
+#if defined(FM_LIB_DBG)
+	#define _fml_dbg(format, arg...) \
+	printf("fmlib [%s:%u] - " format, \
+		__func__, __LINE__, ##arg)
+#else
+	#define _fml_dbg(arg...)
+#endif
+
+/* Major and minor are in sync with FMD, respin is for fmlib identification */
+#define FM_LIB_VERSION_MAJOR	21
+#define FM_LIB_VERSION_MINOR	1 
+#define FM_LIB_VERSION_RESPIN	0
+
+#if (FMD_API_VERSION_MAJOR != FM_LIB_VERSION_MAJOR) || \
+	(FMD_API_VERSION_MINOR != FM_LIB_VERSION_MINOR)
+#warning FMD and FMLIB version mismatch
+#endif
+
+uint32_t FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version);
+
+/*******************************************************************************
+*  FM FUNCTIONS								*
+*******************************************************************************/
+
+t_Handle FM_Open(uint8_t id)
+{
+	t_Device	*p_Dev;
+	int	fd;
+	char	devName[20];
+	static bool called = false;
+	ioc_fm_api_version_t ver;
+
+	_fml_dbg("Calling...\n");
+
+	p_Dev = (t_Device*) malloc(sizeof(t_Device));
+	if (!p_Dev)
+	{
+	return NULL;
+	}
+
+	memset(devName, 0, 20);
+	sprintf(devName, "%s%s%d", "/dev/", DEV_FM_NAME, id);
+	fd = open(devName, O_RDWR);
+	if (fd < 0)
+	{
+	free(p_Dev);
+	return NULL;
+	}
+
+	p_Dev->id = id;
+	p_Dev->fd = fd;
+	if (!called)
+	{
+	called = true;
+
+	FM_GetApiVersion((t_Handle)p_Dev, &ver);
+
+	if (FMD_API_VERSION_MAJOR != ver.version.major ||
+		FMD_API_VERSION_MINOR != ver.version.minor ||
+		FMD_API_VERSION_RESPIN != ver.version.respin)
+	{
+		printf("Warning:\nCompiled against FMD API version %u.%u.%u\n",
+		FMD_API_VERSION_MAJOR, FMD_API_VERSION_MINOR, FMD_API_VERSION_RESPIN);
+		printf("Running with FMD API version %u.%u.%u\n",
+		ver.version.major, ver.version.minor, ver.version.respin);
+		printf("Current fmlib version %u.%u.%u\n",
+		FM_LIB_VERSION_MAJOR, FM_LIB_VERSION_MINOR, FM_LIB_VERSION_RESPIN);
+	}
+	}
+	_fml_dbg("Called.\n");
+
+	return (t_Handle)p_Dev;
+}
+
+void FM_Close(t_Handle h_Fm)
+{
+	t_Device	*p_Dev = (t_Device*) h_Fm;
+
+	_fml_dbg("Calling...\n");
+
+	close(p_Dev->fd);
+	free(p_Dev);
+
+	_fml_dbg("Called.\n");
+}
+
+uint32_t  FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version)
+{
+	t_Device			*p_Dev = (t_Device*) h_Fm;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_IOC_GET_API_VERSION, p_version)) {
+	}
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+/********************************************************************************************/
+/*  FM_PCD FUNCTIONS								*/
+/********************************************************************************************/
+
+t_Handle FM_PCD_Open(t_FmPcdParams *p_FmPcdParams)
+{
+	t_Device	*p_Dev;
+	int	fd;
+	char	devName[20];
+
+	_fml_dbg("Calling...\n");
+
+	p_Dev = (t_Device*) malloc(sizeof(t_Device));
+	if (!p_Dev)
+	{
+	return NULL;
+	}
+
+	memset(devName, 0, 20);
+	sprintf(devName, "%s%s%u-pcd", "/dev/", DEV_FM_NAME, (uint32_t)((t_Device*) p_FmPcdParams->h_Fm)->id);
+	fd = open(devName, O_RDWR);
+	if (fd < 0)
+	{
+	free(p_Dev);
+	return NULL;
+	}
+
+	p_Dev->id = ((t_Device*) p_FmPcdParams->h_Fm)->id;
+	p_Dev->fd = fd;
+	p_Dev->owners = 0;
+
+	_fml_dbg("Called.\n");
+
+	return (t_Handle) p_Dev;
+}
+
+void FM_PCD_Close(t_Handle h_FmPcd)
+{
+	t_Device	*p_Dev = (t_Device*) h_FmPcd;
+
+	_fml_dbg("Calling...\n");
+
+	close(p_Dev->fd);
+
+	if (p_Dev->owners) {
+	printf("Trying to delete a pcd handler that has modules bound to (owners:%u)!!!",
+		p_Dev->owners);
+	return;
+	}
+
+	free(p_Dev);
+
+	_fml_dbg("Called.\n");
+}
+
+uint32_t FM_PCD_Enable(t_Handle h_FmPcd)
+{
+	t_Device	*p_Dev = (t_Device*) h_FmPcd;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_PCD_IOC_ENABLE))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+uint32_t FM_PCD_Disable(t_Handle h_FmPcd)
+{
+	t_Device	*p_Dev = (t_Device*) h_FmPcd;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_PCD_IOC_DISABLE))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, ioc_fm_pcd_net_env_params_t *params)
+{
+	t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+	t_Device *p_Dev = NULL;
+
+	_fml_dbg("Calling...\n");
+
+	params->id = NULL;
+
+	if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET, params))
+		return NULL;
+
+	p_Dev = (t_Device *)malloc(sizeof(t_Device));
+	if (!p_Dev)
+		return NULL;
+
+	memset(p_Dev, 0, sizeof(t_Device));
+	p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+	p_PcdDev->owners++;
+	p_Dev->id = PTR_TO_UINT(params->id);
+
+	_fml_dbg("Called.\n");
+
+	return (t_Handle) p_Dev;;
+}
+
+uint32_t FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
+{
+	t_Device *p_Dev = (t_Device*) h_NetEnv;
+	t_Device *p_PcdDev = NULL;
+	ioc_fm_obj_t id;
+
+	_fml_dbg("Calling...\n");
+
+	p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+	id.obj = UINT_TO_PTR(p_Dev->id);
+
+	if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE, &id))
+		RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	p_PcdDev->owners--;
+	free(p_Dev);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+t_Handle FM_PCD_KgSchemeSet (t_Handle h_FmPcd, ioc_fm_pcd_kg_scheme_params_t *params)
+{
+	t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+	t_Device *p_Dev = NULL;
+
+	_fml_dbg("Calling...\n");
+
+	params->id = NULL;
+
+	if (params->modify) {
+		if (params->scm_id.scheme_id)
+			DEV_TO_ID(params->scm_id.scheme_id);
+		else
+			return NULL;
+	}
+
+	/* correct h_NetEnv param from scheme */
+	if (params->net_env_params.net_env_id)
+		DEV_TO_ID(params->net_env_params.net_env_id);
+
+	/* correct next engine params handlers: cc*/
+	if (params->next_engine == e_IOC_FM_PCD_CC &&
+	params->kg_next_engine_params.cc.tree_id)
+		DEV_TO_ID(params->kg_next_engine_params.cc.tree_id);
+
+	if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_SET, params))
+		return NULL;
+
+	p_Dev = (t_Device *)malloc(sizeof(t_Device));
+	if (!p_Dev)
+		return NULL;
+
+	memset(p_Dev, 0, sizeof(t_Device));
+	p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+	/* increase owners only if a new scheme is created */
+	if (params->modify == false)
+		p_PcdDev->owners++;
+	p_Dev->id = PTR_TO_UINT(params->id);
+
+	_fml_dbg("Called.\n");
+
+	return (t_Handle) p_Dev;
+}
+
+uint32_t FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
+{
+	t_Device *p_Dev = (t_Device*) h_Scheme;
+	t_Device *p_PcdDev = NULL;
+	ioc_fm_obj_t id;
+
+	_fml_dbg("Calling...\n");
+
+	p_PcdDev =  (t_Device *)p_Dev->h_UserPriv;
+	id.obj = UINT_TO_PTR(p_Dev->id);
+
+	if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_DELETE, &id)){
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+	}
+
+	p_PcdDev->owners--;
+	free(p_Dev);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+#error CAPWAP feature not supported
+#endif
+
+typedef struct {
+	e_FmPortType		portType;	/**< Port type */
+	uint8_t		portId;		/**< Port Id - relative to type */
+} t_FmPort;
+
+/********************************************************************************************/
+/*  FM_PORT FUNCTIONS								*/
+/********************************************************************************************/
+
+t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams)
+{
+	t_Device	*p_Dev;
+	int	fd;
+	char	devName[30];
+	t_FmPort	*p_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	p_Dev = (t_Device*) malloc(sizeof(t_Device));
+	if (!p_Dev)
+	{
+	return NULL;
+	}
+	memset(p_Dev, 0, sizeof(t_Device));
+
+	p_FmPort = (t_FmPort*) malloc(sizeof(t_FmPort));
+	if (!p_FmPort)
+	{
+	free(p_Dev);
+	return NULL;
+	}
+	memset(p_FmPort, 0, sizeof(t_FmPort));
+
+	memset(devName, 0, sizeof(devName));
+	switch (p_FmPortParams->portType)
+	{
+	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
+		sprintf(devName, "%s%s%u-port-oh%d", "/dev/", DEV_FM_NAME,
+			(uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+		break;
+	case e_FM_PORT_TYPE_RX:
+		sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
+			(uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+		break;
+	case e_FM_PORT_TYPE_RX_10G:
+		sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
+			(uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_RX_PORTS+p_FmPortParams->portId);
+		break;
+	case e_FM_PORT_TYPE_TX:
+		sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
+			(uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+		break;
+	case e_FM_PORT_TYPE_TX_10G:
+		sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
+			(uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_TX_PORTS+p_FmPortParams->portId);
+		break;
+	default:
+		free(p_FmPort);
+		free(p_Dev);
+		return NULL;
+	}
+
+	fd = open(devName, O_RDWR);
+	if (fd < 0)
+	{
+	free(p_FmPort);
+	free(p_Dev);
+	return NULL;
+	}
+
+	p_FmPort->portType = p_FmPortParams->portType;
+	p_FmPort->portId = p_FmPortParams->portId;
+	p_Dev->id = p_FmPortParams->portId;
+	p_Dev->fd = fd;
+	p_Dev->h_UserPriv = (t_Handle) p_FmPort;
+
+	_fml_dbg("Called.\n");
+
+	return (t_Handle) p_Dev;
+}
+
+void FM_PORT_Close(t_Handle h_FmPort)
+{
+	t_Device	*p_Dev = (t_Device *)h_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	close(p_Dev->fd);
+	if (p_Dev->h_UserPriv)
+	free(p_Dev->h_UserPriv);
+	free(p_Dev);
+
+	_fml_dbg("Called.\n");
+}
+
+uint32_t FM_PORT_Disable(t_Handle h_FmPort)
+{
+	t_Device	*p_Dev = (t_Device *)h_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_PORT_IOC_DISABLE))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+uint32_t FM_PORT_Enable(t_Handle h_FmPort)
+{
+	t_Device	*p_Dev = (t_Device *)h_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_PORT_IOC_ENABLE))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+uint32_t FM_PORT_SetPCD(t_Handle h_FmPort, ioc_fm_port_pcd_params_t *params)
+{
+	t_Device *p_Dev = (t_Device*) h_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	/* correct h_NetEnv param from t_FmPortPcdParams */
+	DEV_TO_ID(params->net_env_id);
+
+	/* correct pcd structures according to what support was set */
+	if (params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC) {
+
+	if (params->p_cc_params && params->p_cc_params->cc_tree_id)
+		DEV_TO_ID(params->p_cc_params->cc_tree_id);
+	else
+		printf("fmlib warning (%s): Coarse Clasification not set ! \n", __func__);
+	}
+
+	if (params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR ){
+
+	if (params->p_kg_params){
+		uint32_t i;
+		for (i = 0; i < params->p_kg_params->num_of_schemes; i++)
+		if (params->p_kg_params->scheme_ids[i])
+			DEV_TO_ID(params->p_kg_params->scheme_ids[i]);
+		else
+			printf("fmlib warning (%s): Scheme:%u not set!\n", __func__, i);
+
+		if (params->p_kg_params && params->p_kg_params->direct_scheme)
+		DEV_TO_ID(params->p_kg_params->direct_scheme_id);
+	} else
+		printf("fmlib warning (%s): KeyGen not set ! \n", __func__);
+	}
+
+	if (params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+	params->pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR){
+
+	if (params->p_plcr_params)
+	{
+		if (params->p_plcr_params->plcr_profile_id)
+		DEV_TO_ID(params->p_plcr_params->plcr_profile_id);
+		else
+		printf("fmlib warning (%s): Policer not set !\n", __func__);
+	}
+	}
+
+	if (params->p_ip_reassembly_manip)
+	DEV_TO_ID(params->p_ip_reassembly_manip);
+
+#if (DPAA_VERSION >= 11)
+	if (params->p_capwap_reassembly_manip)
+	DEV_TO_ID(params->p_capwap_reassembly_manip);
+#endif
+
+	if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_PCD, params))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+uint32_t FM_PORT_DeletePCD(t_Handle h_FmPort)
+{
+	t_Device *p_Dev = (t_Device*) h_FmPort;
+
+	_fml_dbg("Calling...\n");
+
+	if (ioctl(p_Dev->fd, FM_PORT_IOC_DELETE_PCD))
+	RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+	_fml_dbg("Called.\n");
+
+	return E_OK;
+}
+
+t_Handle CreateDevice(t_Handle h_UserPriv, t_Handle h_DevId)
+{
+    t_Device *p_UserPrivDev = (t_Device*)h_UserPriv;
+    t_Device *p_Dev = NULL;
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev) {
+	return NULL;
+    }
+
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = h_UserPriv;
+    p_UserPrivDev->owners++;
+    p_Dev->id = PTR_TO_UINT(h_DevId);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Handle GetDeviceId(t_Handle h_Dev)
+{
+	t_Device *p_Dev = (t_Device *) h_Dev;
+
+	return (t_Handle)p_Dev->id;
+}
+
+#if defined FMAN_V3H
+void Platform_is_FMAN_V3H()
+{
+}
+#elif defined FMAN_V3L
+void Platform_is_FMAN_V3L()
+{
+}
+#endif
diff --git a/drivers/net/dpaa/fmlib/fm_pcd_ext.h b/drivers/net/dpaa/fmlib/fm_pcd_ext.h
new file mode 100644
index 000000000000..3927aa017774
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/fm_pcd_ext.h
@@ -0,0 +1,4980 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_PCD_EXT_H
+#define __FM_PCD_EXT_H
+
+#include "ncsw_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+
+/******************************************************************************
+ @Description   FM PCD ...
+*//***************************************************************************/
+
+/**************************************************************************//**
+
+ @Group	lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   Frame Manager Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   Frame Manager PCD API functions, definitions and enums
+
+		The FM PCD module is responsible for the initialization of all
+		global classifying FM modules. This includes the parser general and
+		common registers, the key generator global and common registers,
+		and the policer global and common registers.
+		In addition, the FM PCD SW module will initialize all required
+		key generator schemes, coarse classification flows, and policer
+		profiles. When an FM module is configured to work with one of these
+		entities, it will register to it using the FM PORT API. The PCD
+		module will manage the PCD resources - i.e. resource management of
+		KeyGen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection	General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS		2		/**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS			16		/**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS	(32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+								/**< Number of distinction units is limited by
+								register size (32 bits) minus reserved bits
+								for private headers. */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS	4		/**< Maximum number of interchangeable headers
+								in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS		8		/**< Total number of generic KeyGen registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY	35		/**< Max number allowed on any configuration;
+								For HW implementation reasons, in most
+								cases less than this will be allowed; The
+								driver will return an initialization error
+								if resource is unavailable. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS		4		/**< Total number of masks allowed on KeyGen extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS		16		/**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS			32		/**< Maximum number of SW parser labels */
+#define IOC_FM_PCD_SW_PRS_SIZE			0x00000800	/**< Total size of SW parser area */
+
+#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE	128		/**< Maximum size of insertion template for
+								insert manipulation */
+
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES	64		/**< Maximum possible entries for frame replicator group */
+#endif /* DPAA_VERSION >= 11 */
+/* @} */
+
+#ifdef FM_CAPWAP_SUPPORT
+#error "FM_CAPWAP_SUPPORT not implemented!"
+#endif
+
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+		(must match enum ioc_fm_pcd_counters defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+	e_IOC_FM_PCD_KG_COUNTERS_TOTAL,				/**< KeyGen counter */
+	e_IOC_FM_PCD_PLCR_COUNTERS_RED,				/**< Policer counter - counts the total number of RED packets that exit the Policer. */
+	e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,				/**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+	e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,			/**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+								This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+	e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,		/**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+								This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+	e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,				/**< Policer counter - counts the total number of packets passed in the Policer. */
+	e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,			/**< Policer counter - counts the number of packets with length mismatch. */
+	e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,			/**< Parser counter - counts the number of times the parser block is dispatched. */
+	e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,		/**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+	e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,		/**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+	e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,		/**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+	e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,	/**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+	e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,	/**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+	e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,	/**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+	e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,	/**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+	e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+	e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,			/**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+	e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,		/**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+	e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,	/**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+	e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,			/**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+	e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,		/**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+	e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,		/**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+	e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,		/**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+	e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES		/**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+		(must match enum ioc_fm_pcd_exceptions defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+	e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,		/**< KeyGen double-bit ECC error is detected on internal memory read access. */
+	e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,		/**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+	e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,		/**< Policer double-bit ECC error has been detected on PRAM read access. */
+	e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,	/**< Policer access to a non-initialized profile has been detected. */
+	e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,	/**< Policer RAM self-initialization complete */
+	e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,	/**< Policer atomic action complete */
+	e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,		/**< Parser double-bit ECC error */
+	e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC		/**< Parser single-bit ECC error */
+} ioc_fm_pcd_exceptions;
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group	lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   Frame Manager PCD Runtime Unit
+
+		The runtime control allows creation of PCD infrastructure modules
+		such as Network Environment Characteristics, Classification Plan
+		Groups and Coarse Classification Trees.
+		It also allows on-the-fly initialization, modification and removal
+		of PCD modules such as KeyGen schemes, coarse classification nodes
+		and Policer profiles.
+
+		In order to explain the programming model of the PCD driver interface
+		a few terms should be explained, and will be used below.
+		- Distinction Header - One of the 16 protocols supported by the FM parser,
+			or one of the SHIM headers (1 or 2). May be a header with a special
+			option (see below).
+		- Interchangeable Headers Group - This is a group of Headers recognized
+			by either one of them. For example, if in a specific context the user
+			chooses to treat IPv4 and IPV6 in the same way, they may create an
+			interchangeable Headers Unit consisting of these 2 headers.
+		- A Distinction Unit - a Distinction Header or an Interchangeable Headers
+			Group.
+		- Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+			IPv6, includes multicast, broadcast and other protocol specific options.
+			In terms of hardware it relates to the options available in the classification
+			plan.
+		- Network Environment Characteristics - a set of Distinction Units that define
+			the total recognizable header selection for a certain environment. This is
+			NOT the list of all headers that will ever appear in a flow, but rather
+			everything that needs distinction in a flow, where distinction is made by KeyGen
+			schemes and coarse classification action descriptors.
+
+		The PCD runtime modules initialization is done in stages. The first stage after
+		initializing the PCD module itself is to establish a Network Flows Environment
+		Definition. The application may choose to establish one or more such environments.
+		Later, when needed, the application will have to state, for some of its modules,
+		to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+	ioc_fm_pcd_counters cnt;		/**< The requested counter */
+	uint32_t		val;		/**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+	ioc_fm_pcd_exceptions exception;	/**< The requested exception */
+	bool		enable;	/**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser labels
+		(must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+	uint32_t		instruction_offset;		/**< SW parser label instruction offset (2 bytes
+								resolution), relative to Parser RAM. */
+	ioc_net_header_type	hdr;				/**< The existence of this header will invoke
+								the SW parser code. */
+	uint8_t		index_per_hdr;		/**< Normally 0, if more than one SW parser
+								attachments for the same header, use this
+								index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser
+		(Must match struct ioc_fm_pcd_prs_sw_params_t defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+	bool			override;		/**< FALSE to invoke a check that nothing else
+								was loaded to this address, including
+								internal patches.
+								TRUE to override any existing code.*/
+	uint32_t		size;			/**< SW parser code size */
+	uint16_t		base;			/**< SW parser base (in instruction counts!
+								must be larger than 0x20)*/
+	uint8_t		*p_code;			/**< SW parser code */
+	uint32_t		sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+							/**< SW parser data (parameters) */
+	uint8_t		num_of_labels;		/**< Number of labels for SW parser. */
+	ioc_fm_pcd_prs_label_params_t labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+							/**< SW parser labels table,
+								containing num_of_labels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+	uint8_t			valueId;		/**< 0,1 - one of 2 global default values */
+	uint32_t			value;		/**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function	FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+		PCD engines according to their existing configuration.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function	FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+		disable all PCD engines. It may be called
+		only when none of the ports in the system are using the PCD.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function	FM_PCD_PrsLoadSw
+
+ @Description   This routine may be called only when all ports in the
+		system are actively using the classification plan scheme.
+		In such cases it is recommended in order to save resources.
+		The driver automatically saves 8 classification plans for
+		ports that do NOT use the classification plan mechanism, to
+		avoid this (in order to save those entries) this routine may
+		be called.
+
+ @Param[in]	ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only when PCD is disabled.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
+#endif
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+		by the KeyGen when parser does not recognize a required
+		field/header.
+		By default default values are 0.
+
+ @Param[in]	ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+		the parser finishing point.
+
+ @Param[in]	uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]	ioc_fm_pcd_exception_params_t	Arguments struct with exception to be enabled/disabled.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Note that it is user's responsibilty to call this routine only
+		for enabled counters, and there will be no indication if a
+		disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+
+ @Function	FM_PCD_KgSchemeGetCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]	h_Scheme	scheme handle as returned by FM_PCD_KgSchemeSet().
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_GET_CNTR_COMPAT  _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4), ioc_compat_fm_pcd_kg_scheme_spc_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_GET_CNTR  _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4), ioc_fm_pcd_kg_scheme_spc_t)
+
+#if 0
+TODO: unused IOCTL
+/**************************************************************************//**
+ @Function	FM_PCD_ModifyCounter
+
+ @Description   Writes a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	ioc_fm_pcd_counters_params_t - The requested counter parameters.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_MODIFY_COUNTER   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#define FM_PCD_IOC_SET_COUNTER	FM_PCD_IOC_MODIFY_COUNTER
+#endif
+
+/**************************************************************************//**
+ @Function	FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]	ioc_fm_pcd_exceptions - An exception to be forced.
+
+ @Return	0 on success; error code if the exception is not enabled,
+		or is not able to create interrupt.
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection	Definitions of coarse classification parameters as required by KeyGen
+		(when coarse classification is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES		8
+#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS		16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS		4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS		256
+#define IOC_FM_PCD_MAX_NUM_OF_FLOWS		(4*KILOBYTE)
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY		56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP	16
+#define IOC_FM_PCD_LAST_KEY_INDEX		0xffff
+#define IOC_FM_PCD_MANIP_DSCP_VALUES		64
+/* @} */
+
+/**************************************************************************//**
+ @Collection	A set of definitions to allow protocol
+		special option description.
+*//***************************************************************************/
+typedef uint32_t		ioc_protocol_opt_t;	/**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST		0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST		0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED		0x20000000   /**< Stacked VLAN. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED		0x10000000   /**< Stacked MPLS. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1		0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1		0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2		0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+#define IOC_IPV4_FRAG_1		0x00000008   /**< IPV4 reassembly option.
+							IPV4 Reassembly manipulation requires network
+							environment with IPV4 header and IPV4_FRAG_1 option  */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1		0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2		0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2		0x00200000   /**< Tunneled IPv6 - Multicast. */
+
+#define IOC_IPV6_FRAG_1		0x00000004   /**< IPV6 reassembly option.
+							IPV6 Reassembly manipulation requires network
+							environment with IPV6 header and IPV6_FRAG_1 option  */
+#if (DPAA_VERSION >= 11)
+typedef ioc_protocol_opt_t   ioc_capwap_protocol_opt_t;	/**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1		0x00000008  /**< CAPWAP reassembly option.
+							CAPWAP Reassembly manipulation requires network
+							environment with CAPWAP header and CAPWAP_FRAG_1 option;
+							in case where fragment found, the fragment-extension offset
+							may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+/* @} */
+
+#define IOC_FM_PCD_MANIP_MAX_HDR_SIZE		256
+#define IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS	64
+/**************************************************************************//**
+ @Collection	A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t			ioc_hdr_manip_flags_t;		/**< A general type to define a HMan update command flags. */
+
+typedef ioc_hdr_manip_flags_t	ioc_ipv4_hdr_manip_update_flags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV4_TOS	0x80000000	/**< update TOS with the given value ('tos' field
+								of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_ID	0x40000000	/**< update IP ID with the given value ('id' field
+								of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_TTL	0x20000000	/**< Decrement TTL by 1 */
+#define IOC_HDR_MANIP_IPV4_SRC	0x10000000	/**< update IP source address with the given value
+								('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_DST	0x08000000	/**< update IP destination address with the given value
+								('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+
+typedef ioc_hdr_manip_flags_t	ioc_ipv6_hdr_manip_update_flags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV6_TC	0x80000000	/**< update Traffic Class address with the given value
+								('traffic_class' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_HL	0x40000000	/**< Decrement Hop Limit by 1 */
+#define IOC_HDR_MANIP_IPV6_SRC	0x20000000	/**< update IP source address with the given value
+								('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_DST	0x10000000	/**< update IP destination address with the given value
+								('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+
+typedef ioc_hdr_manip_flags_t	ioc_tcp_udp_hdr_manip_update_flags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_TCP_UDP_SRC	0x80000000	/**< update TCP/UDP source address with the given value
+								('src' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_DST	0x40000000	/**< update TCP/UDP destination address with the given value
+								('dst' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000	/**< update TCP/UDP checksum */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+		each value in this array represents the index of the extraction
+		command as defined by the user in the initialization extraction array.
+		The valid size of this array is the user define number of extractions
+		required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef	uint8_t	ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+		(must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+	e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
+	e_IOC_FM_PCD_DONE,	/**< No PCD Engine indicated */
+	e_IOC_FM_PCD_KG,		/**< KeyGen */
+	e_IOC_FM_PCD_CC,		/**< Coarse Classifier */
+	e_IOC_FM_PCD_PLCR,	/**< Policer */
+	e_IOC_FM_PCD_PRS,	/**< Parser */
+#if DPAA_VERSION >= 11
+	e_IOC_FM_PCD_FR,		/**< Frame Replicator */
+#endif /* DPAA_VERSION >= 11 */
+	e_IOC_FM_PCD_HASH	/**< Hash Table */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+		(Must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+	e_IOC_FM_PCD_EXTRACT_FROM_HDR,	/**< Extract bytes from header */
+	e_IOC_FM_PCD_EXTRACT_FROM_FIELD,	/**< Extract bytes from header field */
+	e_IOC_FM_PCD_EXTRACT_FULL_FIELD	/**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source (when it is not the header)
+		(Must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+	e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,	/**< KG & CC: Extract from beginning of frame */
+	e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,	/**< KG only: Extract from a default value */
+	e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,	/**< KG only: Extract from the point where parsing had finished */
+	e_IOC_FM_PCD_EXTRACT_FROM_KEY,		/**< CC only: Field where saved KEY */
+	e_IOC_FM_PCD_EXTRACT_FROM_HASH,		/**< CC only: Field where saved HASH */
+	e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,	/**< KG & CC: Extract from the parser result */
+	e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,		/**< KG & CC: Extract from enqueue FQID */
+	e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID		/**< CC only: Field where saved Dequeue FQID */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+	e_IOC_FM_PCD_EXTRACT_BY_HDR,		/**< Extract according to header */
+	e_IOC_FM_PCD_EXTRACT_NON_HDR,		/**< Extract from data that is not the header */
+	e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+	e_IOC_FM_PCD_KG_DFLT_GBL_0,	/**< Default selection is KG register 0 */
+	e_IOC_FM_PCD_KG_DFLT_GBL_1,	/**< Default selection is KG register 1 */
+	e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,	/**< Default selection is a per scheme register 0 */
+	e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,	/**< Default selection is a per scheme register 1 */
+	e_IOC_FM_PCD_KG_DFLT_ILLEGAL	/**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type defining all default groups - each group shares
+		a default value, one of four user-initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+	e_IOC_FM_PCD_KG_MAC_ADDR,		/**< MAC Address */
+	e_IOC_FM_PCD_KG_TCI,			/**< TCI field */
+	e_IOC_FM_PCD_KG_ENET_TYPE,		/**< ENET Type */
+	e_IOC_FM_PCD_KG_PPP_SESSION_ID,	/**< PPP Session id */
+	e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,	/**< PPP Protocol id */
+	e_IOC_FM_PCD_KG_MPLS_LABEL,		/**< MPLS label */
+	e_IOC_FM_PCD_KG_IP_ADDR,		/**< IP addr */
+	e_IOC_FM_PCD_KG_PROTOCOL_TYPE,	/**< Protocol type */
+	e_IOC_FM_PCD_KG_IP_TOS_TC,		/**< TOS or TC */
+	e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,	/**< IPV6 flow label */
+	e_IOC_FM_PCD_KG_IPSEC_SPI,		/**< IPSEC SPI */
+	e_IOC_FM_PCD_KG_L4_PORT,		/**< L4 Port */
+	e_IOC_FM_PCD_KG_TCP_FLAG,		/**< TCP Flag */
+	e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,	/**< grouping implemented by SW,
+						any data extraction that is not the full
+						field described above  */
+	e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
+						any data extraction without validation */
+	e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
+						extraction from parser result or
+						direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining header index for scenarios with
+		multiple (tunneled) headers
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+	e_IOC_FM_PCD_HDR_INDEX_NONE	=   0,	/**< used when multiple headers not used, also
+							to specify regular IP (not tunneled). */
+	e_IOC_FM_PCD_HDR_INDEX_1,		/**< may be used for VLAN, MPLS, tunneled IP */
+	e_IOC_FM_PCD_HDR_INDEX_2,		/**< may be used for MPLS, tunneled IP */
+	e_IOC_FM_PCD_HDR_INDEX_3,		/**< may be used for MPLS */
+	e_IOC_FM_PCD_HDR_INDEX_LAST	=   0xFF	/**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+	e_IOC_FM_PCD_PLCR_PORT_PRIVATE,		/**< Port dedicated profile */
+	e_IOC_FM_PCD_PLCR_SHARED			/**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile algorithm
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+	e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+	e_IOC_FM_PCD_PLCR_RFC_2698,	/**< Policer algorithm RFC 2698 */
+	e_IOC_FM_PCD_PLCR_RFC_4115	/**< Policer algorithm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+	e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+	e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+	e_IOC_FM_PCD_PLCR_GREEN,	/**< Green */
+	e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+	e_IOC_FM_PCD_PLCR_RED,	/**< Red */
+	e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,	/**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,	/**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,	/**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN	/**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting roll-back frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,	/**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+	e_IOC_FM_PCD_PLCR_BYTE_MODE,	/**< Byte mode */
+	e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_done_action {
+	e_IOC_FM_PCD_ENQ_FRAME = 0,	/**< Enqueue frame */
+	e_IOC_FM_PCD_DROP_FRAME	/**< Drop frame */
+} ioc_fm_pcd_done_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+	e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,		/**< Green packets counter */
+	e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,		/**< Yellow packets counter */
+	e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,		/**< Red packets counter */
+	e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+	e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER	/**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the PCD action after extraction
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_action {
+	e_IOC_FM_PCD_ACTION_NONE,			/**< NONE  */
+	e_IOC_FM_PCD_ACTION_EXACT_MATCH,			/**< Exact match on the selected extraction*/
+	e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP		/**< Indexed lookup on the selected extraction*/
+} ioc_fm_pcd_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
+	e_IOC_FM_PCD_MANIP_INSRT_GENERIC,		/**< Insert according to offset & size */
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,			/**< Insert according to protocol */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+	e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE		/**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_insrt_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
+	e_IOC_FM_PCD_MANIP_RMV_GENERIC,			/**< Remove according to offset & size */
+	e_IOC_FM_PCD_MANIP_RMV_BY_HDR			/**< Remove according to offset & size */
+} ioc_fm_pcd_manip_hdr_rmv_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_specific_l2 {
+	e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET,		/**< Ethernet/802.3 MAC */
+	e_IOC_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,	/**< stacked QTags */
+	e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,	/**< MPLS and Ethernet/802.3 MAC header until
+								the header which follows the MPLS header */
+	e_IOC_FM_PCD_MANIP_HDR_RMV_MPLS			/**< Remove MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_rmv_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_type {
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,	/**< VLAN updates */
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,	/**< IPV4 updates */
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,	/**< IPV6 updates */
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,	/**< TCP_UDP updates */
+} ioc_fm_pcd_manip_hdr_field_update_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_vlan {
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,	/**< Replace VPri of outer most VLAN tag. */
+	e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN	/**< DSCP to VLAN priority bits translation */
+} ioc_fm_pcd_manip_hdr_field_update_vlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
+	e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS		/**< Insert MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+		Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+		User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_mapping_mode {
+	e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0, /**< No mapping, QoS field will not be changed */
+	e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_mapping_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+		Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+		User should left room for the parser-result on input/output buffer
+		and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_src {
+	e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0, /**< TODO */
+	e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED, /**< QoS will be taken from the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_src;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,	/**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_IP,		/**< IP insertion */
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP,		/**< UDP insertion */
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,		/**< UDP lite insertion */
+	e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP		/**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_type {
+	e_IOC_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,	/**< Replace IPv4/IPv6 */
+	e_IOC_FM_PCD_MANIP_HDR_CUSTOM_GEN_FIELD_REPLACE,
+} ioc_fm_pcd_manip_hdr_custom_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
+	e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6, /**< Replace IPv4 by IPv6 */
+	e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4  /**< Replace IPv6 by IPv4 */
+} ioc_fm_pcd_manip_hdr_custom_ip_replace;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
+	e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,	/**< Specific L2 fields removal */
+#if (DPAA_VERSION >= 11)
+	e_IOC_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,		/**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+	e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,	/**< Locate from data that is not the header */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of timeout mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
+	e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,	/**< Limits the time of the reassembly process
+								from the first fragment to the last */
+	e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG		/**< Limits the time of receiving the fragment */
+} ioc_fm_pcd_manip_reassem_time_out_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_ways_number {
+	e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,	/**< One way hash	*/
+	e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,	/**< Two ways hash   */
+	e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,	/**< Three ways hash */
+	e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,	/**< Four ways hash  */
+	e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,	/**< Five ways hash  */
+	e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,	/**< Six ways hash   */
+	e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,	/**< Seven ways hash */
+	e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH	/**< Eight ways hash */
+} ioc_fm_pcd_manip_reassem_ways_number;
+
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_stats {
+	e_IOC_FM_PCD_STATS_PER_FLOWID = 0	/**< Flow ID is used as index for getting statistics */
+} ioc_fm_pcd_stats;
+#endif
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_type {
+	e_IOC_FM_PCD_MANIP_HDR = 0,		/**< Header manipulation */
+	e_IOC_FM_PCD_MANIP_REASSEM,		/**< Reassembly */
+	e_IOC_FM_PCD_MANIP_FRAG,		/**< Fragmentation */
+	e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD	/**< Special Offloading */
+} ioc_fm_pcd_manip_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_cc_stats_mode {
+	e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,	/**< No statistics support */
+	e_IOC_FM_PCD_CC_STATS_MODE_FRAME,	/**< Frame count statistics */
+	e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+#if (DPAA_VERSION >= 11)
+	e_IOC_FM_PCD_CC_STATS_MODE_RMON,		/**< Byte and frame length range count statistics */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_cc_stats_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for determining the action in case an IP packet
+		is larger than MTU but its DF (Don't Fragment) bit is set.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_dont_frag_action {
+	e_IOC_FM_PCD_MANIP_DISCARD_PACKET = 0,	/**< Discard packet */
+	e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET =  e_IOC_FM_PCD_MANIP_DISCARD_PACKET,
+						/**< Obsolete, cannot enqueue to error queue;
+							In practice, selects to discard packets;
+							Will be removed in the future */
+	e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,	/**< Fragment packet and continue normal processing */
+	e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG	/**< Continue normal processing without fragmenting the packet */
+} ioc_fm_pcd_manip_dont_frag_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_special_offload_type {
+	e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,	/**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+	e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP	/**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_manip_special_offload_type;
+
+/**************************************************************************//**
+ @Description   A union of protocol dependent special options
+		(Must match union u_FmPcdHdrProtocolOpt defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+	ioc_eth_protocol_opt_t	eth_opt;	/**< Ethernet options */
+	ioc_vlan_protocol_opt_t   vlan_opt;	/**< Vlan options */
+	ioc_mpls_protocol_opt_t   mpls_opt;	/**< MPLS options */
+	ioc_ipv4_protocol_opt_t   ipv4_opt;	/**< IPv4 options */
+	ioc_ipv6_protocol_opt_t   ipv6_opt;	/**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+	ioc_capwap_protocol_opt_t capwap_opt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+	ioc_header_field_eth_t		eth;		/**< Ethernet		*/
+	ioc_header_field_vlan_t		vlan;	/**< VLAN		*/
+	ioc_header_field_llc_snap_t	llc_snap;	/**< LLC SNAP		*/
+	ioc_header_field_pppoe_t		pppoe;	/**< PPPoE		*/
+	ioc_header_field_mpls_t		mpls;	/**< MPLS		*/
+	ioc_header_field_ip_t		ip;		/**< IP			*/
+	ioc_header_field_ipv4_t		ipv4;	/**< IPv4		*/
+	ioc_header_field_ipv6_t		ipv6;	/**< IPv6		*/
+	ioc_header_field_udp_t		udp;		/**< UDP			*/
+	ioc_header_field_udp_lite_t	udp_lite;	/**< UDP_Lite		*/
+	ioc_header_field_tcp_t		tcp;		/**< TCP			*/
+	ioc_header_field_sctp_t		sctp;	/**< SCTP		*/
+	ioc_header_field_dccp_t		dccp;	/**< DCCP		*/
+	ioc_header_field_gre_t		gre;		/**< GRE			*/
+	ioc_header_field_minencap_t	minencap;	/**< Minimal Encapsulation  */
+	ioc_header_field_ipsec_ah_t	ipsec_ah;	/**< IPSec AH		*/
+	ioc_header_field_ipsec_esp_t	ipsec_esp;	/**< IPSec ESP		*/
+	ioc_header_field_udp_encap_esp_t	udp_encap_esp;  /**< UDP Encapsulation ESP  */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+	uint8_t		size;	/**< Size in byte */
+	uint8_t		offset;	/**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+	ioc_fm_pcd_fields_u field;	/**< Field selection */
+	uint8_t		size;	/**< Size in byte */
+	uint8_t		offset;	/**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single network environment unit
+		A distinction unit should be defined if it will later be used
+		by one or more PCD engines to distinguish between flows.
+		(Must match struct t_FmPcdDistinctionUnit defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+	struct {
+	ioc_net_header_type		hdr;		/**< One of the headers supported by the FM */
+	ioc_fm_pcd_hdr_protocol_opt_u   opt;		/**< Select only one option! */
+	} hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining all different distinction units supported
+		by a specific PCD Network Environment Characteristics module.
+
+		Each unit represent a protocol or a group of protocols that may
+		be used later by the different PCD engines to distinguish between flows.
+		(Must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+	uint8_t			num_of_distinction_units;/**< Number of different units to be identified */
+	ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+								/**< An array of num_of_distinction_units of the
+								different units to be identified */
+	void				*id;			/**< Output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single extraction action when
+		creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+	ioc_fm_pcd_extract_type		type;	/**< Extraction type select */
+	union {
+	struct {
+		ioc_net_header_type		hdr;		/**< Header selection */
+		bool				ignore_protocol_validation;
+								/**< Ignore protocol validation */
+		ioc_fm_pcd_hdr_index		hdr_index;	/**< Relevant only for MPLS, VLAN and tunneled
+								IP. Otherwise should be cleared.*/
+		ioc_fm_pcd_extract_by_hdr_type  type;	/**< Header extraction type select */
+		union {
+		ioc_fm_pcd_from_hdr_t	from_hdr;	/**< Extract bytes from header parameters */
+		ioc_fm_pcd_from_field_t	from_field;	/**< Extract bytes from field parameters */
+		ioc_fm_pcd_fields_u	full_field;	/**< Extract full field parameters */
+		} extract_by_hdr_type;
+	} extract_by_hdr;				/**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+	struct {
+		ioc_fm_pcd_extract_from	src;		/**< Non-header extraction source */
+		ioc_fm_pcd_action		action;	/**< Relevant for CC Only */
+		uint16_t			ic_indx_mask;   /**< Relevant only for CC when
+								action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP;
+								Note that the number of bits that are set within
+								this mask must be log2 of the CC-node 'num_of_keys'.
+								Note that the mask cannot be set on the lower bits. */
+		uint8_t			offset;	/**< Byte offset */
+		uint8_t			size;	/**< Size in bytes */
+	} extract_non_hdr;				/**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+	} extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+		field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+	uint8_t		extract_array_index;	/**< Index in the extraction array, as initialized by user */
+	uint8_t		offset;			/**< Byte offset */
+	uint8_t		mask;			/**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+		of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+	ioc_fm_pcd_kg_known_fields_dflt_types	type;	/**< Default type select*/
+	ioc_fm_pcd_kg_extract_dflt_select	dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+		generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+	uint32_t				private_dflt0;	/**< Scheme default register 0 */
+	uint32_t				private_dflt1;	/**< Scheme default register 1 */
+	uint8_t				num_of_used_extracts;   /**< defines the valid size of the following array */
+	ioc_fm_pcd_extract_entry_t	extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+								/**< An array of extraction definitions. */
+	uint8_t				num_of_used_dflts;	/**< defines the valid size of the following array */
+	ioc_fm_pcd_kg_extract_dflt_t	dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+								/**< For each extraction used in this scheme, specify the required
+								default register to be used when header is not found.
+								types not specified in this array will get undefined value. */
+	uint8_t				num_of_used_masks;	/**< Defines the valid size of the following array */
+	ioc_fm_pcd_kg_extract_mask_t	masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+	uint8_t				hash_shift;		/**< Hash result right shift.
+								Selects the 24 bits out of the 64 hash result.
+								0 means using the 24 LSB's, otherwise use the
+								24 LSB's after shifting right.*/
+	uint32_t				hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+								of queues for the key and hash functionality */
+	uint8_t				hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+	bool				symmetric_hash;	/**< TRUE to generate the same hash for frames with swapped source and
+								destination fields on all layers; If TRUE, driver will check that for
+								all layers, if SRC extraction is selected, DST extraction must also be
+								selected, and vice versa. */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+		Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
+	ioc_fm_pcd_extract_type		type;		/**< Extraction type select */
+	union {
+	struct {						/**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+		ioc_net_header_type		hdr;
+		ioc_fm_pcd_hdr_index		hdr_index;	/**< Relevant only for MPLS, VLAN and tunneled
+								IP. Otherwise should be cleared.*/
+		bool				ignore_protocol_validation;
+
+	} extract_by_hdr;
+	ioc_fm_pcd_extract_from		src;		/**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+	} extract_params;
+	uint8_t				extraction_offset;  /**< Offset for extraction */
+	ioc_fm_pcd_kg_extract_dflt_select	dflt_value;	/**< Select register from which extraction is taken if
+								field not found */
+	uint8_t				mask;		/**< Mask LSB byte of extraction (specified bits are ignored) */
+	uint8_t			bit_offset_in_fqid;	/**< 0-31, Selects which bits of the 24 FQID bits to effect using
+								the extracted byte; Assume byte is placed as the 8 MSB's in
+								a 32 bit word where the lower bits
+								are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+								will effect the FQID MSB, if bitOffsetInFqid=24 than the
+								extracted byte will effect the 8 LSB's of the FQID,
+								if bitOffsetInFqid=31 than the byte's MSB will effect
+								the FQID's LSB; 0 means - no effect on FQID;
+								Note that one, and only one of
+								bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+								extracted byte must effect either FQID or Policer profile).*/
+	uint8_t			bit_offset_in_plcr_profile;
+							/**< 0-15, Selects which bits of the 8 policer profile id bits to
+								effect using the extracted byte; Assume byte is placed
+								as the 8 MSB's in a 16 bit word where the lower bits
+								are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+								than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+								than the extracted byte will effect the whole policer profile id,
+								if bitOffsetInFqid=15 than the byte's MSB will effect
+								the Policer Profile id's LSB;
+								0 means - no effect on policer profile; Note that one, and only one of
+								bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+								extracted byte must effect either FQID or Policer profile).*/
+} ioc_fm_pcd_kg_extracted_or_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+	bool	update;	/**< FALSE to keep the current counter state
+				and continue from that point, TRUE to update/reset
+				the counter when the scheme is written. */
+	uint32_t	value;	/**< If update=TRUE, this value will be written into the
+				counter; clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for retrieving FMKG_SE_SPC
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_spc_t {
+	uint32_t	val;	/**< return value */
+	void	*id;	/**< scheme handle */
+} ioc_fm_pcd_kg_scheme_spc_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile parameters as required by keygen
+		(when policer is the next engine after this scheme).
+		(Must match struct t_FmPcdKgPlcrProfile defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+	bool		shared_profile;		/**< TRUE if this profile is shared between ports
+								(i.e. managed by master partition) May not be TRUE
+								if profile is after Coarse Classification*/
+	bool		direct;			/**< If TRUE, direct_relative_profile_id only selects the profile
+								id, if FALSE fqid_offset_relative_profile_id_base is used
+								together with fqid_offset_shift and num_of_profiles
+								parameters, to define a range of profiles from
+								which the KeyGen result will determine the
+								destination policer profile.  */
+	union {
+	uint16_t	direct_relative_profile_id;	/**< Used if 'direct' is TRUE, to select policer profile.
+								This parameter should indicate the policer profile offset within the port's
+								policer profiles or SHARED window. */
+	struct {
+		uint8_t	fqid_offset_shift;		/**< Shift of KG results without the qid base */
+		uint8_t	fqid_offset_relative_profile_id_base;
+							/**< OR of KG results without the qid base
+								This parameter should indicate the policer profile
+								offset within the port's policer profiles window
+								or SHARED window depends on shared_profile */
+		uint8_t	num_of_profiles;		/**< Range of profiles starting at base */
+	} indirect_profile;				/**< Indirect profile parameters */
+	} profile_select;				/**< Direct/indirect profile selection and parameters */
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_storage_profile_t {
+	bool		direct;			/**< If TRUE, directRelativeProfileId only selects the
+							profile id;
+							If FALSE, fqidOffsetRelativeProfileIdBase is used
+							together with fqidOffsetShift and numOfProfiles
+							parameters to define a range of profiles from which
+							the KeyGen result will determine the destination
+							storage profile. */
+	union {
+	uint16_t	direct_relative_profileId;	/**< Used when 'direct' is TRUE, to select a storage profile;
+							should indicate the storage profile offset within the
+							port's storage profiles window. */
+	struct {
+		uint8_t	fqid_offset_shift;		/**< Shift of KeyGen results without the FQID base */
+		uint8_t	fqid_offset_relative_profile_id_base;
+							/**< OR of KeyGen results without the FQID base;
+							should indicate the policer profile offset within the
+							port's storage profiles window. */
+		uint8_t	num_of_profiles;		/**< Range of profiles starting at base. */
+	} indirect_profile;			/**< Indirect profile parameters. */
+	} profile_select;				/**< Direct/indirect profile selection and parameters. */
+} ioc_fm_pcd_kg_storage_profile_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after KeyGen
+		(Must match struct t_FmPcdKgCc defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+	void				*tree_id;	/**< CC Tree id */
+	uint8_t			grp_id;		/**< CC group id within the CC tree */
+	bool				plcr_next;	/**< TRUE if after CC, in case of data frame,
+								policing is required. */
+	bool				bypass_plcr_profile_generation;
+							/**< TRUE to bypass KeyGen policer profile generation;
+								selected profile is the one set at port initialization. */
+	ioc_fm_pcd_kg_plcr_profile_t	plcr_profile;	/**< Valid only if plcr_next = TRUE and
+								bypass_plcr_profile_generation = FALSE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining initializing a KeyGen scheme
+		(Must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+	bool				modify;	/**< TRUE to change an existing scheme */
+	union {
+	uint8_t			relative_scheme_id;
+							/**< if modify=FALSE: partition-relative scheme id */
+	void				*scheme_id;	/**< if modify=TRUE: the id of an existing scheme */
+	} scm_id;
+	bool				always_direct;  /**< This scheme is reached only directly, i.e. no need
+								for match vector; KeyGen will ignore it when matching */
+	struct {						/**< HL relevant only if always_direct=FALSE */
+	void				*net_env_id;	/**< The id of the Network Environment as returned
+								by FM_PCD_NetEnvCharacteristicsSet() */
+	uint8_t			num_of_distinction_units;
+							/**< Number of NetEnv units listed in unit_ids array */
+	uint8_t			unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+							/**< Indexes as passed to SetNetEnvCharacteristics (?) array */
+	} net_env_params;
+	bool				use_hash;	/**< use the KG Hash functionality */
+	ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+							/**< used only if useHash = TRUE */
+	bool				bypass_fqid_generation;
+							/**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+								In such a case FQID after KG will be the default FQID
+								defined for the relevant port, or the FQID defined by CC
+								in cases where CC was the previous engine. */
+	uint32_t				base_fqid;	/**< Base FQID; Relevant only if bypass_fqid_generation = FALSE;
+								If hash is used and an even distribution is expected
+								according to hash_distribution_num_of_fqids, base_fqid must be aligned to
+								hash_distribution_num_of_fqids. */
+	uint8_t				num_of_used_extracted_ors;
+							/**< Number of FQID masks listed in extracted_ors array*/
+	ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+							/**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+								registers are shared between qid_masks
+								functionality and some of the extraction
+								actions; Normally only some will be used
+								for qid_mask. Driver will return error if
+								resource is full at initialization time. */
+#if DPAA_VERSION >= 11
+	bool				override_storage_profile;
+							/**< TRUE if KeyGen override previously decided storage profile */
+	ioc_fm_pcd_kg_storage_profile_t	storage_profile;/**< Used when override_storage_profile=TRUE */
+#endif /* DPAA_VERSION >= 11 */
+	ioc_fm_pcd_engine		next_engine;	/**< may be BMI, PLCR or CC */
+	union {						/**< depends on nextEngine */
+	ioc_fm_pcd_done_action	done_action;	/**< Used when next engine is BMI (done) */
+	ioc_fm_pcd_kg_plcr_profile_t	plcr_profile;	/**< Used when next engine is PLCR */
+	ioc_fm_pcd_kg_cc_t		cc;		/**< Used when next engine is CC */
+	} kg_next_engine_params;
+	ioc_fm_pcd_kg_scheme_counter_t	scheme_counter;  /**< A structure of parameters for updating
+								the scheme counter */
+	void				*id;		/**< Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Collection
+*//***************************************************************************/
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR	10  /* Maximal supported number of frame length ranges */
+#define IOC_FM_PCD_CC_STATS_FLR_SIZE		2   /* Size in bytes of a frame length range limit */
+#endif /* DPAA_VERSION >= 11 */
+#define IOC_FM_PCD_CC_STATS_FLR_COUNT_SIZE	4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after a CC node.
+		(Must match struct t_FmPcdCcNextCcParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+	void	*cc_node_id;				/**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   A structure for defining Frame Replicator as the next engine after a CC node.
+		(Must match struct t_FmPcdCcNextFrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_fr_params_t {
+	void*	frm_replic_id;		/**< The id of the next frame replicator group */
+} ioc_fm_pcd_cc_next_fr_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+		next engine after a CC node
+		(Must match struct t_FmPcdCcNextPlcrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+	bool	override_params;		/**< TRUE if CC override previously decided parameters*/
+	bool	shared_profile;		/**< Relevant only if overrideParams=TRUE:
+						TRUE if this profile is shared between ports */
+	uint16_t	new_relative_profile_id;	/**< Relevant only if overrideParams=TRUE:
+						(otherwise profile id is taken from keygen);
+						This parameter should indicate the policer
+						profile offset within the port's
+						policer profiles or from SHARED window.*/
+	uint32_t	new_fqid;		/**< Relevant only if overrideParams=TRUE:
+						FQID for enquing the frame;
+						In earlier chips  if policer next engine is KEYGEN,
+						this parameter can be 0, because the KEYGEN always decides
+						the enqueue FQID.*/
+#if DPAA_VERSION >= 11
+	uint8_t	new_relative_storage_profile_id;
+						/**< Indicates the relative storage profile offset within
+						the port's storage profiles window;
+						Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+		next engine after a CC node
+		(Must match struct t_FmPcdCcNextEnqueueParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+	ioc_fm_pcd_done_action  action;	/**< Action - when next engine is BMI (done) */
+	bool			override_fqid;  /**< TRUE if CC override previously decided fqid and vspid,
+						relevant if action = e_IOC_FM_PCD_ENQ_FRAME */
+	uint32_t		new_fqid;	/**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+						(otherwise FQID is taken from KeyGen),
+						relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
+#if DPAA_VERSION >= 11
+	uint8_t		new_relative_storage_profile_id;
+						/**< Valid if override_fqid=TRUE, Indicates the relative virtual
+						storage profile offset within the port's storage profiles
+						window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the next engine after a CC node
+		(Must match struct t_FmPcdCcNextKgParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+	bool	override_fqid;		/**< TRUE if CC override previously decided fqid and vspid,
+						Note - this parameters are irrelevant for earlier chips */
+	uint32_t   new_fqid;			/**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+						(otherwise FQID is taken from KeyGen),
+						Note - this parameters are irrelevant for earlier chips */
+#if DPAA_VERSION >= 11
+	uint8_t		new_relative_storage_profile_id;
+						/**< Valid if override_fqid=TRUE, Indicates the relative virtual
+						storage profile offset within the port's storage profiles
+						window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+	void	*p_direct_scheme;		/**< Direct scheme id to go to. */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after a CC node.
+		(Must match struct ioc_fm_pcd_cc_next_engine_params_t defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+	ioc_fm_pcd_engine			next_engine;	/**< User has to initialize parameters
+								according to nextEngine definition */
+	union {
+		ioc_fm_pcd_cc_next_cc_params_t	cc_params;	/**< Parameters in case next engine is CC */
+		ioc_fm_pcd_cc_next_plcr_params_t	plcr_params;	/**< Parameters in case next engine is PLCR */
+		ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+		ioc_fm_pcd_cc_next_kg_params_t	kg_params;	/**< Parameters in case next engine is KG */
+#if DPAA_VERSION >= 11
+		ioc_fm_pcd_cc_next_fr_params_t	fr_params;	/**< Parameters in case next engine is FR */
+#endif /* DPAA_VERSION >= 11 */
+	} params;						/**< Union used for all the next-engine parameters options */
+	void					*manip_id;	/**< Handle to Manipulation object.
+								Relevant if next engine is of type result
+								(e_IOC_FM_PCD_PLCR, e_IOC_FM_PCD_KG, e_IOC_FM_PCD_DONE) */
+	bool					statistics_en;  /**< If TRUE, statistics counters are incremented
+								for each frame passing through this
+								Coarse Classification entry. */
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single CC key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+	uint8_t		*p_key;	/**< pointer to the key of the size defined in key_size */
+	uint8_t		*p_mask;	/**< pointer to the Mask per key of the size defined
+						in keySize. p_key and p_mask (if defined) has to be
+						of the same size defined in the key_size */
+	ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+						/**< parameters for the next for the defined Key in p_key */
+
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC keys parameters
+		The driver supports two methods for CC node allocation: dynamic and static.
+		Static mode was created in order to prevent runtime alloc/free
+		of FMan memory (MURAM), which may cause fragmentation; in this mode,
+		the driver automatically allocates the memory according to
+		'max_num_of_keys' parameter. The driver calculates the maximal memory
+		size that may be used for this CC-Node taking into consideration
+		'mask_support' and 'statistics_mode' parameters.
+		When 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+		parameters of this node, 'max_num_of_keys' must be equal to 'num_of_keys'.
+		In dynamic mode, 'max_num_of_keys' must be zero. At initialization,
+		all required structures are allocated according to 'num_of_keys'
+		parameter. During runtime modification, these structures are
+		re-allocated according to the updated number of keys.
+
+		Please note that 'action' and 'ic_indx_mask' mentioned in the
+		specific parameter explanations are passed in the extraction
+		parameters of the node (fields of extractccparams.extractnonhdr).
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+	uint16_t			max_num_of_keys;/**< Maximum number of keys that will (ever) be used in this CC-Node;
+							A value of zero may be used for dynamic memory allocation. */
+	bool			mask_support;   /**< This parameter is relevant only if a node is initialized with
+							action = e_IOC_FM_PCD_ACTION_EXACT_MATCH and max_num_of_keys > 0;
+							Should be TRUE to reserve table memory for key masks, even if
+							initial keys do not contain masks, or if the node was initialized
+							as 'empty' (without keys); this will allow user to add keys with
+							masks at runtime. */
+	ioc_fm_pcd_cc_stats_mode	statistics_mode;/**< Determines the supported statistics mode for all node's keys.
+							To enable statistics gathering, statistics should be enabled per
+							every key, using 'statistics_en' in next engine parameters structure
+							of that key;
+							If 'max_num_of_keys' is set, all required structures will be
+							preallocated for all keys. */
+#if (DPAA_VERSION >= 11)
+	uint16_t			frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+						/**< Relevant only for 'RMON' statistics mode
+							(this feature is supported only on B4860 device);
+							Holds a list of programmable thresholds. For each received frame,
+							its length in bytes is examined against these range thresholds and
+							the appropriate counter is incremented by 1. For example, to belong
+							to range i, the following should hold:
+							range i-1 threshold < frame length <= range i threshold
+							Each range threshold must be larger then its preceding range
+							threshold. Last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
+	uint16_t			num_of_keys;	/**< Number of initial keys;
+							Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
+							this field should be power-of-2 of the number of bits that are
+							set in 'ic_indx_mask'. */
+	uint8_t			key_size;	/**< Size of key - for extraction of type FULL_FIELD, 'key_size' has
+							to be the standard size of the selected key; For other extraction
+							types, 'key_size' has to be as size of extraction; When 'action' =
+							e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+	ioc_fm_pcd_cc_key_params_t  key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+						/**< An array with 'num_of_keys' entries, each entry specifies the
+							corresponding key parameters;
+							When 'action' = e_IOC_FM_PCD_ACTION_EXACT_MATCH, this value must not
+							exceed 255 (IOC_FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+							for the 'miss' entry. */
+	ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+						/**< Parameters for defining the next engine when a key is not matched;
+							Not relevant if action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP. */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+	ioc_fm_pcd_extract_entry_t	extract_cc_params;  /**< Extraction parameters */
+	ioc_keys_params_t		keys_params;	/**< Keys definition matching the selected extraction */
+	void				*id;		/**< Output parameter; returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a hash table
+		(Must match struct ioc_fm_pcd_hash_table_params_t defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_params_t {
+	uint16_t			max_num_of_keys;		/**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+	ioc_fm_pcd_cc_stats_mode	statistics_mode;		/**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+								requested statistics mode will be allocated according to max_num_of_keys. */
+	uint8_t			kg_hash_shift;		/**< KG-Hash-shift as it was configured in the KG-scheme
+								that leads to this hash-table. */
+	uint16_t			hash_res_mask;		/**< Mask that will be used on the hash-result;
+								The number-of-sets for this hash will be calculated
+								as (2^(number of bits set in 'hash_res_mask'));
+								The 4 lower bits must be cleared. */
+	uint8_t			hash_shift;		/**< Byte offset from the beginning of the KeyGen hash result to the
+								2-bytes to be used as hash index. */
+	uint8_t			match_key_size;		/**< Size of the exact match keys held by the hash buckets */
+
+	ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
+								/**< Parameters for defining the next engine when a key is not matched */
+	void			*id;
+} ioc_fm_pcd_hash_table_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableAddKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
+	void			*p_hash_tbl;
+	uint8_t			key_size;
+	ioc_fm_pcd_cc_key_params_t  key_params;
+} ioc_fm_pcd_hash_table_add_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC tree group.
+
+		This structure defines a CC group in terms of NetEnv units
+		and the action to be taken in each case. The unit_ids list must
+		be given in order from low to high indices.
+
+		ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+		structures where each defines the next action to be taken for
+		each units combination. for example:
+		num_of_distinction_units = 2
+		unit_ids = {1,3}
+		next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+							unit 1 - not found; unit 3 - not found;
+		next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+							unit 1 - not found; unit 3 - found;
+		next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+							unit 1 - found; unit 3 - not found;
+		next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+							unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+	uint8_t				num_of_distinction_units;   /**< Up to 4 */
+	uint8_t				unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+								/**< Indexes of the units as defined in
+								FM_PCD_NetEnvCharacteristicsSet() */
+	ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+								/**< Maximum entries per group is 16 */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the CC tree groups
+		(Must match struct ioc_fm_pcd_cc_tree_params_t defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+	void				*net_env_id;	/**< Id of the Network Environment as returned
+								by FM_PCD_NetEnvCharacteristicsSet() */
+	uint8_t			num_of_groups;  /**< Number of CC groups within the CC tree */
+	ioc_fm_pcd_cc_grp_params_t	fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+							/**< Parameters for each group. */
+	void				*id;		/**< Output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining policer byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+	ioc_fm_pcd_plcr_frame_length_select	frame_length_selection;	/**< Frame length selection */
+	ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+								e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile (based on
+		RFC-2698 or RFC-4115 attributes).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+	ioc_fm_pcd_plcr_rate_mode		rate_mode;			/**< Byte / Packet */
+	ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;		/**< Valid for Byte NULL for Packet */
+	uint32_t				committed_info_rate;		/**< KBits/Sec or Packets/Sec */
+	uint32_t				committed_burst_size;	/**< KBits or Packets */
+	uint32_t				peak_or_excess_info_rate;	/**< KBits/Sec or Packets/Sec */
+	uint32_t				peak_or_excess_burst_size;	/**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after policer
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+	ioc_fm_pcd_done_action	action;		/**< Action - when next engine is BMI (done) */
+	void			*p_profile;	/**< Policer profile handle -  used when next engine
+								is PLCR, must be a SHARED profile */
+	void			*p_direct_scheme;	/**< Direct scheme select - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct ioc_fm_pcd_port_params_t {
+	ioc_fm_port_type			port_type;	/**< Type of port for this profile */
+	uint8_t				port_id;		/**< FM-Port id of port for this profile */
+} ioc_fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile entry
+		(Must match struct ioc_fm_pcd_plcr_profile_params_t defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+	bool					modify;			/**< TRUE to change an existing profile */
+	union {
+	struct {
+		ioc_fm_pcd_profile_type_selection   profile_type;		/**< Type of policer profile */
+		ioc_fm_pcd_port_params_t		*p_fm_port;		/**< Relevant for per-port profiles only */
+		uint16_t				relative_profile_id;	/**< Profile id - relative to shared group or to port */
+	} new_params;							/**< Use it when modify = FALSE */
+	void					*p_profile;		/**< A handle to a profile - use it when modify=TRUE */
+	} profile_select;
+	ioc_fm_pcd_plcr_algorithm_selection	alg_selection;		/**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
+	ioc_fm_pcd_plcr_color_mode		color_mode;		/**< COLOR_BLIND, COLOR_AWARE */
+
+	union {
+	ioc_fm_pcd_plcr_color		dflt_color;		/**< For Color-Blind Pass-Through mode; the policer will re-color
+								any incoming packet with the default value. */
+	ioc_fm_pcd_plcr_color		override;		/**< For Color-Aware modes; the profile response to a
+								pre-color value of 2'b11. */
+	} color;
+
+	ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 parameters */
+
+	ioc_fm_pcd_engine			next_engine_on_green;	/**< Next engine for green-colored frames */
+	ioc_fm_pcd_plcr_next_engine_params_u	params_on_green;		/**< Next engine parameters for green-colored frames  */
+
+	ioc_fm_pcd_engine			next_engine_on_yellow;	/**< Next engine for yellow-colored frames */
+	ioc_fm_pcd_plcr_next_engine_params_u	params_on_yellow;	/**< Next engine parameters for yellow-colored frames  */
+
+	ioc_fm_pcd_engine			next_engine_on_red;	/**< Next engine for red-colored frames */
+	ioc_fm_pcd_plcr_next_engine_params_u	params_on_red;		/**< Next engine parameters for red-colored frames  */
+
+	bool					trap_profile_on_flow_A;	/**< Obsolete - do not use */
+	bool					trap_profile_on_flow_B;	/**< Obsolete - do not use */
+	bool					trap_profile_on_flow_C;	/**< Obsolete - do not use */
+
+	void					*id;			/**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC tree next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+	void				*id;		/**< CC tree Id to be used */
+	uint8_t				grp_indx;	/**< A Group index in the tree */
+	uint8_t				indx;		/**< Entry index in the group defined by grp_index */
+	ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+								/**< Parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+	void				*id;		/**< CC node Id to be used */
+	uint16_t				key_indx;	/**< Key index for Next Engine Params modifications;
+								NOTE: This parameter is IGNORED for miss-key!  */
+	uint8_t				key_size;	/**< Key size of added key */
+	ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+								/**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for remove CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+	void				*id;		/**< CC node Id to be used */
+	uint16_t				key_indx;	/**< Key index for Next Engine Params modifications;
+								NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key and next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+	void				*id;		/**< CC node Id to be used */
+	uint16_t				key_indx;	/**< Key index for Next Engine Params modifications;
+								NOTE: This parameter is IGNORED for miss-key!  */
+	uint8_t				key_size;	/**< Key size of added key */
+	ioc_fm_pcd_cc_key_params_t	key_params;	/**< it's array with numOfKeys entries each entry in
+								the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+	void				*id;		/**< CC node Id to be used */
+	uint16_t				key_indx;	/**< Key index for Next Engine Params modifications;
+								NOTE: This parameter is IGNORED for miss-key!  */
+	uint8_t				key_size;	/**< Key size of added key */
+	uint8_t				*p_key;		/**< Pointer to the key of the size defined in key_size */
+	uint8_t				*p_mask;		/**< Pointer to the Mask per key of the size defined
+								in keySize. p_Key and p_Mask (if defined) have to be
+								of the same size as defined in the key_size */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableRemoveKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
+	void	*p_hash_tbl;	/**< The id of the hash table */
+	uint8_t	key_size;	/**< The size of the key to remove */
+	uint8_t	*p_key;	/**< Pointer to the key to remove */
+} ioc_fm_pcd_hash_table_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for selecting a location for requested manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_manip_hdr_info_t {
+	ioc_net_header_type		hdr;		/**< Header selection */
+	ioc_fm_pcd_hdr_index		hdr_index;	/**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+	bool				by_field;	/**< TRUE if the location of manipulation is according to some field in the specific header*/
+	ioc_fm_pcd_fields_u		full_field;	/**< Relevant only when by_field = TRUE: Extract field */
+} ioc_fm_manip_hdr_info_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
+	ioc_fm_pcd_manip_hdr_rmv_by_hdr_type	type;  /**< Selection of header removal location */
+	union {
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+	struct {
+		bool				include;/**< If FALSE, remove until the specified header (not including the header);
+								If TRUE, remove also the specified header. */
+		ioc_fm_manip_hdr_info_t		hdr_info;
+	} from_start_by_hdr;			/**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+	ioc_fm_manip_hdr_info_t		hdr_info;	/**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
+	ioc_fm_pcd_manip_hdr_rmv_specific_l2	specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+								Defines which L2 headers to remove. */
+	} u;
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
+	uint16_t			size_for_fragmentation;	/**< If length of the frame is greater than this value,
+								IP fragmentation will be executed.*/
+#if DPAA_VERSION == 10
+	uint8_t			scratch_bpid;		/**< Absolute buffer pool id according to BM configuration.*/
+#endif /* DPAA_VERSION == 10 */
+	bool			sg_bpid_en;		/**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+								If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+								received frame's buffer. */
+	uint8_t			sg_bpid;			/**< Scatter/Gather buffer pool id;
+								This parameter is relevant when 'sg_bpid_en=TRUE';
+								Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+								of this pool need to be allocated in the same memory area as the received buffers.
+								If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+								mutual to all these sources. */
+	ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;	/**< Dont Fragment Action - If an IP packet is larger
+								than MTU and its DF bit is set, then this field will
+								determine the action to be taken.*/
+} ioc_fm_pcd_manip_frag_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+		This is a common structure for both IPv4 and IPv6 reassembly
+		manipulation. For reassembly of both IPv4 and IPv6, make sure to
+		set the 'hdr' field in ioc_fm_pcd_manip_reassem_params_t to IOC_HEADER_TYPE_IPv6.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
+	uint8_t			relative_scheme_id[2];	/**< Partition relative scheme id:
+								relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+								relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+								NOTE: The following comment is relevant only for FMAN v2 devices:
+								Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+								the user schemes id to ensure that the reassembly's schemes will be first match.
+								The remaining schemes, if defined, should have higher relative scheme ID. */
+#if DPAA_VERSION >= 11
+	uint32_t			non_consistent_sp_fqid; /**< In case that other fragments of the frame corresponds to different storage
+								profile than the opening fragment (Non-Consistent-SP state)
+								then one of two possible scenarios occurs:
+								if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+								this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
+	uint8_t			sg_bpid;		/**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* DPAA_VERSION >= 11 */
+	uint8_t			data_mem_id;		/**< Memory partition ID for the IPR's external tables structure */
+	uint16_t			data_liodn_offset;	/**< LIODN offset for access the IPR's external tables structure. */
+	uint16_t			min_frag_size[2];	/**< Minimum fragment size:
+								minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+	ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
+								/**< Number of frames per hash entry needed for reassembly process:
+								numOfFramesPerHashEntry[0] - for ipv4 (max value is e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+								numOfFramesPerHashEntry[1] - for ipv6 (max value is e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH). */
+	uint16_t			max_num_frames_in_process;/**< Number of frames which can be processed by Reassembly in the same time;
+								Must be power of 2;
+								In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 4 - 512;
+								In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 8 - 2048. */
+	ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;  /**< Expiration delay initialized by Reassembly process */
+	uint32_t			fqid_for_time_out_frames;/**< FQID in which time out frames will enqueue during Time Out Process  */
+	uint32_t			timeout_threshold_for_reassm_process;
+								/**< Represents the time interval in microseconds which defines
+								if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining IPSEC manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
+	bool	decryption;			/**< TRUE if being used in decryption direction;
+						FALSE if being used in encryption direction. */
+	bool	ecn_copy;			/**< TRUE to copy the ECN bits from inner/outer to outer/inner
+						(direction depends on the 'decryption' field). */
+	bool	dscp_copy;			/**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+						(direction depends on the 'decryption' field). */
+	bool	variable_ip_hdr_len;		/**< TRUE for supporting variable IP header length in decryption. */
+	bool	variable_ip_version;		/**< TRUE for supporting both IP version on the same SA in encryption */
+	uint8_t outer_ip_hdr_len;		/**< If 'variable_ip_version == TRUE' than this field must be set to non-zero value;
+						It is specifies the length of the outer IP header that was configured in the
+						corresponding SA. */
+	uint16_t	arw_size;		/**< if <> '0' then will perform ARW check for this SA;
+						The value must be a multiplication of 16 */
+	void	*arw_addr;			/**< if arwSize <> '0' then this field must be set to non-zero value;
+						MUST be allocated from FMAN's MURAM that the post-sec op-port belong
+						Must be 4B aligned. Required MURAM size is '(NEXT_POWER_OF_2(arwSize+32))/8+4' Bytes */
+} ioc_fm_pcd_manip_special_offload_ipsec_params_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+	- Maximum number of fragments per frame is 16.
+	- Transmit confirmation is not supported.
+	- Fragmentation nodes must be set as the last PCD action (i.e. the
+	corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+	- Only BMan buffers shall be used for frames to be fragmented.
+	- NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+	does not support VSP. Therefore, on the same port where we have IPF we
+	cannot support VSP.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_capwap_params_t {
+	uint16_t			size_for_fragmentation;   /**< If length of the frame is greater than this value,
+								CAPWAP fragmentation will be executed.*/
+	bool			sg_bpid_en;		/**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+								If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+								received frame's buffer. */
+	uint8_t			sg_bpid;		/**< Scatter/Gather buffer pool id;
+								This parameters is relevant when 'sgBpidEn=TRUE';
+								Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+								of this pool need to be allocated in the same memory area as the received buffers.
+								If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+								mutual to all these sources. */
+	bool			compress_mode_en;	/**< CAPWAP Header Options Compress Enable mode;
+								When this mode is enabled then only the first fragment include the CAPWAP header options
+								field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+								options field (CAPWAP header is updated accordingly).*/
+} ioc_fm_pcd_manip_frag_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+	- Application must define one scheme to catch the reassembled frames.
+	- Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_capwap_params_t {
+	uint8_t			relative_scheme_id;	/**< Partition relative scheme id;
+								NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+								Rest schemes, if defined, should have higher relative scheme ID. */
+	uint8_t			data_mem_id;		/**< Memory partition ID for the IPR's external tables structure */
+	uint16_t			data_liodn_offset;	/**< LIODN offset for access the IPR's external tables structure. */
+	uint16_t			max_reassembled_frame_length;/**< The maximum CAPWAP reassembled frame length in bytes;
+								If maxReassembledFrameLength == 0, any successful reassembled frame length is
+								considered as a valid length;
+								if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+								exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+	ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+								/**< Number of frames per hash entry needed for reassembly process */
+	uint16_t			max_num_frames_in_process;  /**< Number of frames which can be processed by reassembly in the same time;
+								Must be power of 2;
+								In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 4 - 512;
+								In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 8 - 2048. */
+	ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;		/**< Expiration delay initialized by Reassembly process */
+	uint32_t			fqid_for_time_out_frames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+								Recommended value for this field is 0; in this way timed-out frames will be discarded */
+	uint32_t			timeout_threshold_for_reassm_process;
+								/**< Represents the time interval in microseconds which defines
+								if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_capwap_params_t {
+	bool			dtls;   /**< TRUE if continue to SEC DTLS encryption */
+	ioc_fm_pcd_manip_hdr_qos_src   qos_src; /**< TODO */
+} ioc_fm_pcd_manip_special_offload_capwap_params_t;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_params_t {
+	ioc_fm_pcd_manip_special_offload_type		type;	/**< Type of special offload manipulation */
+	union
+	{
+	ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;	/**< Parameters for IPSec; Relevant when
+								type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_special_offload_capwap_params_t  capwap;	/**< Parameters for CAPWAP; Relevant when
+								type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+	} u;
+} ioc_fm_pcd_manip_special_offload_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
+	uint8_t			offset;	/**< Offset from beginning of header to the start
+							location of the removal */
+	uint8_t			size;	/**< Size of removed section */
+} ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_t {
+	uint8_t size;	/**< size of inserted section */
+	uint8_t *p_data;	/**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
+	uint8_t			offset;	/**< Offset from beginning of header to the start
+							location of the insertion */
+	uint8_t			size;	/**< Size of inserted section */
+	bool				replace;	/**< TRUE to override (replace) existing data at
+							'offset', FALSE to insert */
+	uint8_t			*p_data;	/**< Pointer to data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t {
+	uint8_t			dscp_to_vpri_table[IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+							/**< A table of VPri values for each DSCP value;
+							The index is the D_SCP value (0-0x3F) and the
+							value is the corresponding VPRI (0-15). */
+	uint8_t			vpri_def_val;   /**< 0-7, Relevant only if if update_type =
+							e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+							this field is the Q Tag default value if the
+							IP header is not found. */
+} ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_t {
+	ioc_fm_pcd_manip_hdr_field_update_vlan  update_type;	/**< Selects VLAN update type */
+	union {
+	uint8_t					vpri;   /**< 0-7, Relevant only if If update_type =
+								e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+								is the new VLAN pri. */
+	ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t	dscp_to_vpri;
+								/**<  Parameters structure, Relevant only if update_type =
+								e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+	} u;
+} ioc_fm_pcd_manip_hdr_field_update_vlan_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv4_t {
+	ioc_ipv4_hdr_manip_update_flags_t	valid_updates;  /**< ORed flag, selecting the required updates */
+	uint8_t				tos;		/**< 8 bit New TOS; Relevant if valid_updates contains
+								IOC_HDR_MANIP_IPV4_TOS */
+	uint16_t				id;		/**< 16 bit New IP ID; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_IPV4_ID */
+	uint32_t				src;		/**< 32 bit New IP SRC; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_IPV4_SRC */
+	uint32_t				dst;		/**< 32 bit New IP DST; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_IPV4_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv4_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv6_t {
+	ioc_ipv6_hdr_manip_update_flags_t	valid_updates;  /**< ORed flag, selecting the required updates */
+	uint8_t				traffic_class;  /**< 8 bit New Traffic Class; Relevant if valid_updates contains
+								IOC_HDR_MANIP_IPV6_TC */
+	uint8_t				src[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+								/**< 16 byte new IP SRC; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_IPV6_SRC */
+	uint8_t				dst[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+								/**< 16 byte new IP DST; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_IPV6_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv6_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t {
+	ioc_tcp_udp_hdr_manip_update_flags_t	valid_updates;  /**< ORed flag, selecting the required updates */
+	uint16_t				src;		/**< 16 bit New TCP/UDP SRC; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_TCP_UDP_SRC */
+	uint16_t				dst;		/**< 16 bit New TCP/UDP DST; Relevant only if valid_updates
+								contains IOC_HDR_MANIP_TCP_UDP_DST */
+} ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_params_t {
+	ioc_fm_pcd_manip_hdr_field_update_type	type;   /**< Type of header field update manipulation */
+	union {
+	ioc_fm_pcd_manip_hdr_field_update_vlan_t	vlan;   /**< Parameters for VLAN update. Relevant when
+								type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+	ioc_fm_pcd_manip_hdr_field_update_ipv4_t	ipv4;   /**< Parameters for IPv4 update. Relevant when
+								type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+	ioc_fm_pcd_manip_hdr_field_update_ipv6_t	ipv6;   /**< Parameters for IPv6 update. Relevant when
+								type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+	ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t tcp_udp;/**< Parameters for TCP/UDP update. Relevant when
+								type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+	} u;
+} ioc_fm_pcd_manip_hdr_field_update_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t {
+	ioc_fm_pcd_manip_hdr_custom_ip_replace  replace_type;   /**< Selects replace update type */
+	bool					dec_ttl_hl;	/**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1 */
+	bool					update_ipv4_id; /**< Relevant when replace_type =
+								e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+	uint16_t				id;		/**< 16 bit New IP ID; Relevant only if
+								update_ipv4_id = TRUE */
+	uint8_t				hdr_size;	/**< The size of the new IP header */
+	uint8_t				hdr[IOC_FM_PCD_MANIP_MAX_HDR_SIZE];
+								/**< The new IP header */
+} ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_params_t {
+	ioc_fm_pcd_manip_hdr_custom_type		type;   /**< Type of header field update manipulation */
+	union {
+	ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t	ip_hdr_replace;
+								/**< Parameters IP header replacement */
+	} u;
+} ioc_fm_pcd_manip_hdr_custom_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
+	ioc_fm_pcd_manip_hdr_insrt_specific_l2  specific_l2;	/**< Selects which L2 headers to insert */
+	bool					update;	/**< TRUE to update MPLS header */
+	uint8_t				size;	/**< size of inserted section */
+	uint8_t				*p_data;	/**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_ip_params_t {
+	bool	calc_l4_checksum; /**< Calculate L4 checksum. */
+	ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
+	uint8_t last_pid_offset;	/**< the offset of the last Protocol within
+				the inserted header */
+	uint16_t  id;	/**< 16 bit New IP ID */
+	bool				dont_frag_overwrite;
+	/**< IPv4 only. DF is overwritten with the hash-result next-to-last byte.
+	* This byte is configured to be overwritten when RPD is set. */
+	uint8_t			last_dst_offset;
+	/**< IPv6 only. if routing extension exist, user should set the offset of the destination address
+	* in order to calculate UDP checksum pseudo header;
+	* Otherwise set it to '0'. */
+	ioc_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_fm_pcd_manip_hdr_insrt_ip_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
+	ioc_fm_pcd_manip_hdr_insrt_by_hdr_type	type;   /**< Selects manipulation type */
+	union {
+	ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
+								/**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+								Selects which L2 headers to remove */
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_hdr_insrt_ip_params_t	ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+	ioc_fm_pcd_manip_hdr_insrt_t		insrt;	/**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+								e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+								e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+	} u;
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
+	ioc_fm_pcd_manip_hdr_insrt_type			type;   /**< Type of insertion manipulation */
+	union {
+	ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t	by_hdr; /**< Parameters for defining header insertion manipulation by header type,
+								relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
+	ioc_fm_pcd_manip_hdr_insrt_generic_params_t	generic;/**< Parameters for defining generic header insertion manipulation,
+								relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+	ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
+								/**< Parameters for defining header insertion manipulation by template,
+								relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+#endif /* FM_CAPWAP_SUPPORT */
+	} u;
+} ioc_fm_pcd_manip_hdr_insrt_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
+	ioc_fm_pcd_manip_hdr_rmv_type		type;	/**< Type of header removal manipulation */
+	union {
+	ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t   by_hdr;	/**< Parameters for defining header removal manipulation by header type,
+								relevant if type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR */
+	ioc_fm_pcd_manip_hdr_rmv_generic_params_t  generic;	/**< Parameters for defining generic header removal manipulation,
+								relevant if type = e_IOC_FM_PCD_MANIP_RMV_GENERIC */
+	} u;
+} ioc_fm_pcd_manip_hdr_rmv_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_params_t {
+	bool					rmv;		/**< TRUE, to define removal manipulation */
+	ioc_fm_pcd_manip_hdr_rmv_params_t	rmv_params;	/**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
+
+	bool					insrt;		/**< TRUE, to define insertion manipulation */
+	ioc_fm_pcd_manip_hdr_insrt_params_t	insrt_params;	/**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
+
+	bool					field_update;	/**< TRUE, to define field update manipulation */
+	ioc_fm_pcd_manip_hdr_field_update_params_t  field_update_params;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
+
+	bool					custom;		/**< TRUE, to define custom manipulation */
+	ioc_fm_pcd_manip_hdr_custom_params_t	custom_params;	/**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
+
+	bool					dont_parse_after_manip;/**< FALSE to activate the parser a second time after
+								completing the manipulation on the frame */
+} ioc_fm_pcd_manip_hdr_params_t;
+
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_params_t {
+	ioc_net_header_type			hdr;		/**< Header selection */
+	union {
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_frag_capwap_params_t	capwap_frag;   /**< Parameters for defining CAPWAP fragmentation,
+							relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+	ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;	/**< Parameters for defining IP fragmentation,
+								relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+	} u;
+} ioc_fm_pcd_manip_frag_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining reassemble manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_params_t {
+	ioc_net_header_type			hdr;	/**< Header selection */
+	union {
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_reassem_capwap_params_t capwap_reassem;  /**< Parameters for defining CAPWAP reassembly,
+							relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+	ioc_fm_pcd_manip_reassem_ip_params_t	ip_reassem; /**< Parameters for defining IP reassembly,
+								relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+	} u;
+} ioc_fm_pcd_manip_reassem_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_params_t {
+	ioc_fm_pcd_manip_type			type;   /**< Selects type of manipulation node */
+	union {
+	ioc_fm_pcd_manip_hdr_params_t		hdr;	/**< Parameters for defining header manipulation node */
+	ioc_fm_pcd_manip_reassem_params_t	reassem;/**< Parameters for defining reassembly manipulation node */
+	ioc_fm_pcd_manip_frag_params_t		frag;   /**< Parameters for defining fragmentation manipulation node */
+	ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
+	} u;
+	void						*p_next_manip;/**< Handle to another (previously defined) manipulation node;
+								Allows concatenation of manipulation actions
+								This parameter is optional and may be NULL. */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+	bool						frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
+	ioc_fm_pcd_manip_frag_or_reasm_params_t	frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
+								relevant if frag_or_reasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+	void					*id;
+} ioc_fm_pcd_manip_params_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
+	/* common counters for both IPv4 and IPv6 */
+	uint32_t	timeout;			/**< Counts the number of TimeOut occurrences */
+	uint32_t	rfd_pool_busy;			/**< Counts the number of failed attempts to allocate
+							a Reassembly Frame Descriptor */
+	uint32_t	internal_buffer_busy;		/**< Counts the number of times an internal buffer busy occurred */
+	uint32_t	external_buffer_busy;		/**< Counts the number of times external buffer busy occurred */
+	uint32_t	sg_fragments;			/**< Counts the number of Scatter/Gather fragments */
+	uint32_t	dma_semaphore_depletion;	/**< Counts the number of failed attempts to allocate a DMA semaphore */
+#if (DPAA_VERSION >= 11)
+	uint32_t	non_consistent_sp;		/**< Counts the number of Non Consistent Storage Profile events for
+							successfully reassembled frames */
+#endif /* (DPAA_VERSION >= 11) */
+struct {
+	uint32_t	successfully_reassembled;	/**< Counts the number of successfully reassembled frames */
+	uint32_t	valid_fragments;		/**< Counts the total number of valid fragments that
+							have been processed for all frames */
+	uint32_t	processed_fragments;	/**< Counts the number of processed fragments
+							(valid and error fragments) for all frames */
+	uint32_t	malformed_fragments;	/**< Counts the number of malformed fragments processed for all frames */
+	uint32_t	discarded_fragments;	/**< Counts the number of fragments discarded by the reassembly process */
+	uint32_t	auto_learn_busy;		/**< Counts the number of times a busy condition occurs when attempting
+							to access an IP-Reassembly Automatic Learning Hash set */
+	uint32_t	more_than16fragments;	/**< Counts the fragment occurrences in which the number of fragments-per-frame
+							exceeds 16 */
+	} specific_hdr_statistics[2];		/**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} ioc_fm_pcd_manip_reassem_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
+	uint32_t	total_frames;		/**< Number of frames that passed through the manipulation node */
+	uint32_t	fragmented_frames;	/**< Number of frames that were fragmented */
+	uint32_t	generated_fragments;	/**< Number of fragments that were generated */
+} ioc_fm_pcd_manip_frag_ip_stats_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_capwap_stats_t {
+	uint32_t	timeout;			/**< Counts the number of timeout occurrences */
+	uint32_t	rfd_pool_busy;		/**< Counts the number of failed attempts to allocate
+						a Reassembly Frame Descriptor */
+	uint32_t	internal_buffer_busy;	/**< Counts the number of times an internal buffer busy occurred */
+	uint32_t	external_buffer_busy;	/**< Counts the number of times external buffer busy occurred */
+	uint32_t	sg_fragments;		/**< Counts the number of Scatter/Gather fragments */
+	uint32_t	dma_semaphore_depletion;	/**< Counts the number of failed attempts to allocate a DMA semaphore */
+	uint32_t	successfully_reassembled;	/**< Counts the number of successfully reassembled frames */
+	uint32_t	valid_fragments;		/**< Counts the total number of valid fragments that
+						have been processed for all frames */
+	uint32_t	processed_fragments;	/**< Counts the number of processed fragments
+						(valid and error fragments) for all frames */
+	uint32_t	malformed_fragments;	/**< Counts the number of malformed fragments processed for all frames */
+	uint32_t	autoLearn_busy;		/**< Counts the number of times a busy condition occurs when attempting
+						to access an Reassembly Automatic Learning Hash set */
+	uint32_t	discarded_fragments;	/**< Counts the number of fragments discarded by the reassembly process */
+	uint32_t	more_than16fragments;	/**< Counts the fragment occurrences in which the number of fragments-per-frame
+						exceeds 16 */
+	uint32_t	exceed_max_reassembly_frame_len;/**< ounts the number of times that a successful reassembled frame
+						length exceeds MaxReassembledFrameLength value */
+} ioc_fm_pcd_manip_reassem_capwap_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_capwap_stats_t {
+	uint32_t	total_frames;		/**< Number of frames that passed through the manipulation node */
+	uint32_t	fragmented_frames;	/**< Number of frames that were fragmented */
+	uint32_t	generated_fragments;	/**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	uint8_t	sg_allocation_failure;	/**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} ioc_fm_pcd_manip_frag_capwap_stats_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_stats_t {
+	union {
+	ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
+	} u;
+} ioc_fm_pcd_manip_reassem_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for retrieving fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_stats_t {
+	union {
+	ioc_fm_pcd_manip_frag_ip_stats_t	ip_frag;	/**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+	ioc_fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
+	} u;
+} ioc_fm_pcd_manip_frag_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_stats_t {
+	union {
+	ioc_fm_pcd_manip_reassem_stats_t  reassem;	/**< Structure for reassembly statistics */
+	ioc_fm_pcd_manip_frag_stats_t	frag;	/**< Structure for fragmentation statistics */
+	} u;
+} ioc_fm_pcd_manip_stats_t;
+
+/**************************************************************************//**
+ @Description   Parameters for acquiring manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_get_stats_t {
+	void				*id;
+	ioc_fm_pcd_manip_stats_t	stats;
+} ioc_fm_pcd_manip_get_stats_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_frm_replic_group_params_t {
+	uint8_t			max_num_of_entries;	/**< Maximal number of members in the group  - must be at least two */
+	uint8_t			num_of_entries;	/**< Number of members in the group - must be at least 1 */
+	ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+							/**< Array of members' parameters */
+	void			*id;
+} ioc_fm_pcd_frm_replic_group_params_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_t {
+	void *h_replic_group;
+	uint16_t member_index;
+} ioc_fm_pcd_frm_replic_member_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_params_t {
+	ioc_fm_pcd_frm_replic_member_t member;
+	ioc_fm_pcd_cc_next_engine_params_t next_engine_params;
+} ioc_fm_pcd_frm_replic_member_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+
+typedef struct ioc_fm_pcd_cc_key_statistics_t {
+	uint32_t	byte_count;	/**< This counter reflects byte count of frames that
+					were matched by this key. */
+	uint32_t	frame_count;	/**< This counter reflects count of frames that
+					were matched by this key. */
+#if (DPAA_VERSION >= 11)
+	uint32_t	frame_length_range_count[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+				/**< These counters reflect how many frames matched
+					this key in 'RMON' statistics mode:
+					Each counter holds the number of frames of a
+					specific frames length range, according to the
+					ranges provided at initialization. */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_cc_key_statistics_t;
+
+
+typedef struct ioc_fm_pcd_cc_tbl_get_stats_t {
+	void				*id;
+	uint16_t			key_index;
+	ioc_fm_pcd_cc_key_statistics_t  statistics;
+} ioc_fm_pcd_cc_tbl_get_stats_t;
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+		in a CC Node.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames passed that were matched
+		this key; The total frames count will be returned in the counter
+		of the first range (as only one frame length range was defined).
+		If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+		frame count will be separated to frame length counters, based on
+		provided frame length ranges.
+
+ @Param[in]	h_CcNode	A handle to the node
+ @Param[in]	keyIndex	Key index for adding
+ @Param[out]	p_KeyStatistics Key statistics counters
+
+ @Return	The specific key statistics.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of miss entry
+		in a CC Node.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames were not matched to any
+		existing key and therefore passed through the miss entry; The
+		total frames count will be returned in the counter of the
+		first range (as only one frame length range was defined).
+
+ @Param[in]	h_CcNode		A handle to the node
+ @Param[out]	p_MissStatistics	Statistics counters for 'miss'
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of 'miss'
+		entry of the a hash table.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames were not matched to any
+		existing key and therefore passed through the miss entry;
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+ @Param[out]	p_MissStatistics	Statistics counters for 'miss'
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+
+/**************************************************************************//**
+ @Function	FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
+
+		When setting an environment it is important to understand its
+		application. It is not meant to describe the flows that will run
+		on the ports using this environment, but what the user means TO DO
+		with the PCD mechanisms in order to parse-classify-distribute those
+		frames.
+		By specifying a distinction unit, the user means it would use that option
+		for distinction between frames at either a KeyGen scheme or a coarse
+		classification action descriptor. Using interchangeable headers to define a
+		unit means that the user is indifferent to which of the interchangeable
+		headers is present in the frame, and wants the distinction to be based
+		on the presence of either one of them.
+
+		Depending on context, there are limitations to the use of environments. A
+		port using the PCD functionality is bound to an environment. Some or even
+		all ports may share an environment but also an environment per port is
+		possible. When initializing a scheme, a classification plan group (see below),
+		or a coarse classification tree, one of the initialized environments must be
+		stated and related to. When a port is bound to a scheme, a classification
+		plan group, or a coarse classification tree, it MUST be bound to the same
+		environment.
+
+		The different PCD modules, may relate (for flows definition) ONLY on
+		distinction units as defined by their environment. When initializing a
+		scheme for example, it may not choose to select IPV4 as a match for
+		recognizing flows unless it was defined in the relating environment. In
+		fact, to guide the user through the configuration of the PCD, each module's
+		characterization in terms of flows is not done using protocol names, but using
+		environment indexes.
+
+		In terms of HW implementation, the list of distinction units sets the LCV vectors
+		and later used for match vector, classification plan vectors and coarse classification
+		indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   A structure defining the distiction units for this configuration.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_NetEnvCharacteristicsDelete
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]	ioc_fm_obj_t - The id of a Network Environment object.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeSet
+
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
+		This routine should be called for adding or modifying a scheme.
+		When a scheme needs modifying, the API requires that it will be
+		rewritten. In such a case 'modify' should be TRUE. If the
+		routine is called for a valid scheme and 'modify' is FALSE,
+		it will return error.
+
+ @Param[in,out] ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_SET_COMPAT	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_SET	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeDelete
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]	ioc_fm_obj_t	scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_DELETE	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootBuild
+
+ @Description   This routine must be called to define a complete coarse
+		classification tree. This is the way to define coarse
+		classification to a certain flow - the KeyGen schemes
+		may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t	A structure of parameters to define the tree.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_BUILD	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootDelete
+
+ @Description   Deleting a built tree.
+
+ @Param[in]	ioc_fm_obj_t - The id of a CC tree.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_DELETE	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableSet
+
+ @Description   This routine should be called for each CC (coarse classification)
+		node. The whole CC tree should be built bottom up so that each
+		node points to already defined nodes. p_NodeId returns the node
+		Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t	A structure for defining the CC node params
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_SET_COMPAT	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_SET	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableDelete
+
+ @Description   Deleting a built node.
+
+ @Param[in]	ioc_fm_obj_t - The id of a CC node.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]	ioc_fm_pcd_cc_tree_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_CcRootBuild().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]	ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]	ioc_fm_pcd_cc_node_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+		defined by the index of the relevant node.
+
+ @Param[in]	ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only after FM_PCD_MatchTableSet() has been called for this
+		node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableAddKey
+
+ @Description   Add the key (including next engine parameters of this key in the
+		index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+		may be used when the user doesn't care about the position of the
+		key in the table - in that case, the key will be automatically
+		added by the driver in the last available entry.
+
+ @Param[in]	ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only after FM_PCD_MatchTableSet() has been called for this
+		node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by key_index.
+
+ @Param[in]	ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() not only of the relevnt node but also
+		the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyKey
+
+ @Description   Modify the key at the index defined by key_index.
+
+ @Param[in]	ioc_fm_pcd_cc_node_modify_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only after FM_PCD_MatchTableSet() has been called for this
+		node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+		KeyGen hash result determines the hash bucket.
+		Next, KeyGen key is compared against all keys of this
+		bucket (exact match).
+		Number of sets (number of buckets) of the hash equals to the
+		number of 1-s in 'hash_res_mask' in the provided parameters.
+		Number of hash table ways is then calculated by dividing
+		'max_num_of_keys' equally between the hash sets. This is the maximal
+		number of keys that a hash bucket may hold.
+		The hash table is initialized empty and keys may be
+		added to it following the initialization. Keys masks are not
+		supported in current hash table implementation.
+		The initialized hash table can be integrated as a node in a
+		CC tree.
+
+ @Param[in,out] ioc_fm_pcd_hash_table_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_hash_table_params_t)
+
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableDelete
+
+ @Description   This routine deletes the provided hash table and released all
+		its allocated resources.
+
+ @Param[in]	ioc_fm_obj_t - The ID of a hash table.
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_DELETE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableAddKey
+
+ @Description   This routine adds the provided key (including next engine
+		parameters of this key) to the hash table.
+		The key is added as the last key of the bucket that it is
+		mapped to.
+
+ @Param[in]	ioc_fm_pcd_hash_table_add_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_hash_table_add_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableRemoveKey
+
+ @Description   This routine removes the requested key (including next engine
+		parameters of this key) from the hash table.
+
+ @Param[in]	ioc_fm_pcd_hash_table_remove_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return	0 on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_pcd_hash_table_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileSet
+
+ @Description   Sets a profile entry in the policer profile table.
+		The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t	A structure of parameters for defining a
+							policer profile entry.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_SET	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileDelete
+
+ @Description   Delete a profile entry in the policer profile table.
+		The routine set entry to invalid.
+
+ @Param[in]	ioc_fm_obj_t	The id of a policer profile.
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+		node. A manipulation node must be defined before the CC node
+		that precedes it.
+
+ @Param[in]	ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_SET_COMPAT	_IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+		(Here, it's implemented as a variant of the same IOCTL as for
+		FM_PCD_ManipNodeSet(), and one that when called, the 'id' member
+		in its 'ioc_fm_pcd_manip_params_t' argument is set to contain
+		the manip node's handle)
+
+ @Param[in]	ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_REPLACE_COMPAT	FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#endif
+#define FM_PCD_IOC_MANIP_NODE_REPLACE	FM_PCD_IOC_MANIP_NODE_SET
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]	ioc_fm_obj_t	The id of the manipulation node to delete.
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_DELETE	_IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipGetStatistics
+
+ @Description   Retrieve the manipulation statistics.
+
+ @Param[in]	h_ManipNode	A handle to a manipulation node.
+ @Param[out]	p_FmPcdManipStats   A structure for retrieving the manipulation statistics
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_GET_STATS_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(50), ioc_compat_fm_pcd_manip_get_stats_t)
+#endif
+#define FM_PCD_IOC_MANIP_GET_STATS   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(50), ioc_fm_pcd_manip_get_stats_t)
+
+/**************************************************************************//**
+@Function	FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+		IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]	h_FmPcd	FM PCD module descriptor.
+
+@Return	0 on success; error code otherwise.
+
+@Cautions	Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]	h_FmPcd		FM PCD module descriptor.
+ @Param[in]	p_FrmReplicGroupParam  A structure of parameters for the initialization of
+					the frame replicator group.
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_compat_fm_pcd_frm_replic_group_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_fm_pcd_frm_replic_group_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]	h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return	E_OK on success;  Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]	h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]	memberIndex	member index for adding.
+ @Param[in]	p_MemberParams	A pointer to the new member parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_compat_fm_pcd_frm_replic_member_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_fm_pcd_frm_replic_member_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]	h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]	memberIndex	member index for removing.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_compat_fm_pcd_frm_replic_member_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_fm_pcd_frm_replic_member_t)
+
+#endif
+
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+/**************************************************************************//**
+ @Function	FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in,out] ioc_fm_pcd_stats_params_t A structure of parameters defining the statistics
+
+ @Return	0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+#endif
+#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+
+#endif /* FM_CAPWAP_SUPPORT */
+
+
+/**************************************************************************//**
+ @Group	FM_grp Frame Manager API
+
+ @Description   Frame Manager Application Programming Interface
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group	FM_PCD_grp FM PCD
+
+ @Description   Frame Manager PCD (Parse-Classify-Distribute) API.
+
+		The FM PCD module is responsible for the initialization of all
+		global classifying FM modules. This includes the parser general and
+		common registers, the key generator global and common registers,
+		and the policer global and common registers.
+		In addition, the FM PCD SW module will initialize all required
+		key generator schemes, coarse classification flows, and policer
+		profiles. When FM module is configured to work with one of these
+		entities, it will register to it using the FM PORT API. The PCD
+		module will manage the PCD resources - i.e. resource management of
+		KeyGen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection	General PCD defines
+*//***************************************************************************/
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS		2		/**< Number of units/headers saved for user */
+
+#define FM_PCD_PRS_NUM_OF_HDRS			16		/**< Number of headers supported by HW parser */
+#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS	(32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+								/**< Number of distinction units is limited by
+								register size (32 bits) minus reserved bits
+								for private headers. */
+#define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS	4		/**< Maximum number of interchangeable headers
+								in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS		FM_KG_NUM_OF_GENERIC_REGS /**< Total number of generic KeyGen registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY	35		/**< Max number allowed on any configuration;
+								For HW implementation reasons, in most
+								cases less than this will be allowed; The
+								driver will return an initialization error
+								if resource is unavailable. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS		4		/**< Total number of masks allowed on KeyGen extractions. */
+#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS		16		/**< Number of default value logical groups */
+
+#define FM_PCD_PRS_NUM_OF_LABELS			32		/**< Maximum number of SW parser labels */
+#define FM_SW_PRS_MAX_IMAGE_SIZE		(FM_PCD_SW_PRS_SIZE /*- FM_PCD_PRS_SW_OFFSET -FM_PCD_PRS_SW_TAIL_SIZE*/-FM_PCD_PRS_SW_PATCHES_SIZE)
+								/**< Maximum size of SW parser code */
+
+#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE	128		/**< Maximum size of insertion template for
+								insert manipulation */
+
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES	64		/**< Maximum possible entries for frame replicator group */
+#endif /* (DPAA_VERSION >= 11) */
+/* @} */
+
+
+/**************************************************************************//**
+ @Group	FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+		exception passing the exception identification.
+
+ @Param[in]	h_App	- User's application descriptor.
+ @Param[in]	exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPcdExceptionCallback) (t_Handle h_App, ioc_fm_pcd_exceptions exception);
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an exception
+		passing the exception identification.
+
+ @Param[in]	h_App	- User's application descriptor.
+ @Param[in]	exception	- The exception.
+ @Param[in]	index	- id of the relevant source (may be scheme or profile id).
+ *//***************************************************************************/
+typedef void (t_FmPcdIdExceptionCallback) ( t_Handle	h_App,
+						ioc_fm_pcd_exceptions  exception,
+						uint16_t	index);
+
+/**************************************************************************//**
+ @Description   A callback for enqueuing frame onto a QM queue.
+
+ @Param[in]	h_QmArg	- Application's handle passed to QM module on enqueue.
+ @Param[in]	p_Fd		- Frame descriptor for the frame.
+
+ @Return	E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef uint32_t (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
+
+/**************************************************************************//**
+ @Description   Host-Command parameters structure.
+
+		When using Host command for PCD functionalities, a dedicated port
+		must be used. If this routine is called for a PCD in a single partition
+		environment, or it is the Master partition in a Multi-partition
+		environment, The port will be initialized by the PCD driver
+		initialization routine.
+ *//***************************************************************************/
+typedef struct t_FmPcdHcParams {
+	uintptr_t		portBaseAddr;	/**< Virtual Address of Host-Command Port memory mapped registers.*/
+	uint8_t			portId;		/**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports);
+							NOTE: When configuring Host Command port for
+							FMANv3 devices (DPAA_VERSION 11 and higher),
+							portId=0 MUST be used. */
+	uint16_t			liodnBase;	/**< LIODN base for this port, to be used together with LIODN offset
+							(irrelevant for P4080 revision 1.0) */
+	uint32_t			errFqid;		/**< Host-Command Port error queue Id. */
+	uint32_t			confFqid;	/**< Host-Command Port confirmation queue Id. */
+	uint32_t			qmChannel;	/**< QM channel dedicated to this Host-Command port;
+							will be used by the FM for dequeue. */
+	t_FmPcdQmEnqueueCallback	*f_QmEnqueue;	/**< Callback routine for enqueuing a frame to the QM */
+	t_Handle			h_QmArg;		/**< Application's handle passed to QM module on enqueue */
+} t_FmPcdHcParams;
+
+/**************************************************************************//**
+ @Description   The main structure for PCD initialization
+ *//***************************************************************************/
+typedef struct t_FmPcdParams {
+	bool			prsSupport;		/**< TRUE if Parser will be used for any of the FM ports. */
+	bool			ccSupport;		/**< TRUE if Coarse Classification will be used for any
+								of the FM ports. */
+	bool			kgSupport;		/**< TRUE if KeyGen will be used for any of the FM ports. */
+	bool			plcrSupport;		/**< TRUE if Policer will be used for any of the FM ports. */
+	t_Handle		h_Fm;		/**< A handle to the FM module. */
+	uint8_t			numOfSchemes;	/**< Number of schemes dedicated to this partition.
+							this parameter is relevant if 'kgSupport'=TRUE. */
+	bool			useHostCommand;	/**< Optional for single partition, Mandatory for Multi partition */
+	t_FmPcdHcParams		hc;			/**< Host Command parameters, relevant only if 'useHostCommand'=TRUE;
+								Relevant when FM not runs in "guest-mode". */
+
+	t_FmPcdExceptionCallback	*f_Exception;	/**< Callback routine for general PCD exceptions;
+								Relevant when FM not runs in "guest-mode". */
+	t_FmPcdIdExceptionCallback	*f_ExceptionId;	/**< Callback routine for specific KeyGen scheme or
+								Policer profile exceptions;
+								Relevant when FM not runs in "guest-mode". */
+	t_Handle		h_App;		/**< A handle to an application layer object; This handle will
+								be passed by the driver upon calling the above callbacks;
+								Relevant when FM not runs in "guest-mode". */
+	uint8_t			partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
+								this parameter is relevant if 'plcrSupport'=TRUE.
+								NOTE: this parameter relevant only when working with multiple partitions. */
+	uint16_t		partNumOfPlcrProfiles;  /**< Number of policer-profiles dedicated to this partition.
+								this parameter is relevant if 'plcrSupport'=TRUE.
+								NOTE: this parameter relevant only when working with multiple partitions. */
+} t_FmPcdParams;
+
+
+/**************************************************************************//**
+ @Function	FM_PCD_Config
+
+ @Description   Basic configuration of the PCD module.
+		Creates descriptor for the FM PCD module.
+
+ @Param[in]	p_FmPcdParams	A structure of parameters for the initialization of PCD.
+
+ @Return	A handle to the initialized module.
+*//***************************************************************************/
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_Init
+
+ @Description   Initialization of the PCD module.
+
+ @Param[in]	h_FmPcd - FM PCD module descriptor.
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PCD_Init(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+		Calling this routine invalidates the descriptor.
+
+ @Param[in]	h_FmPcd - FM PCD module descriptor.
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PCD_Free(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Group	FM_PCD_advanced_cfg_grp	FM PCD Advanced Configuration Unit
+
+ @Description   Frame Manager PCD Advanced Configuration API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function	FM_PCD_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+		from its default selection of exceptions enabling.
+		[DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	exception	The exception to be selected.
+ @Param[in]	enable	TRUE to enable interrupt, FALSE to mask it.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_ConfigException(t_Handle h_FmPcd, ioc_fm_pcd_exceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ConfigHcFramesDataMemory
+
+ @Description   Configures memory-partition-id for FMan-Controller Host-Command
+		frames. Calling this routine changes the internal driver data
+		base from its default configuration [0].
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	memId	Memory partition ID.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	This routine may be called only if 'useHostCommand' was TRUE
+		when FM_PCD_Config() routine was called.
+*//***************************************************************************/
+uint32_t FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+		from its default selection of exceptions enablement.
+		[DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]	h_FmPcd			FM PCD module descriptor.
+ @Param[in]	numOfSharedPlcrProfiles	Number of profiles to
+						be shared between ports on this partition
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ConfigPlcrAutoRefreshMode
+
+ @Description   Calling this routine changes the internal driver data base
+		from its default selection of exceptions enablement.
+		By default auto-refresh is [DEFAULT_plcrAutoRefresh].
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	enable	TRUE to enable, FALSE to disable
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ConfigPrsMaxCycleLimit
+
+ @Description   Calling this routine changes the internal data structure for
+		the maximum parsing time from its default value
+		[DEFAULT_MAX_PRS_CYC_LIM].
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	value	0 to disable the mechanism, or new
+				maximum parsing time.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
+
+/** @} */ /* end of FM_PCD_advanced_cfg_grp group */
+/** @} */ /* end of FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group	FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   Frame Manager PCD Runtime Unit API
+
+		The runtime control allows creation of PCD infrastructure modules
+		such as Network Environment Characteristics, Classification Plan
+		Groups and Coarse Classification Trees.
+		It also allows on-the-fly initialization, modification and removal
+		of PCD modules such as KeyGen schemes, coarse classification nodes
+		and Policer profiles.
+
+		In order to explain the programming model of the PCD driver interface
+		a few terms should be explained, and will be used below.
+		- Distinction Header - One of the 16 protocols supported by the FM parser,
+			or one of the SHIM headers (1 or 2). May be a header with a special
+			option (see below).
+		- Interchangeable Headers Group - This is a group of Headers recognized
+			by either one of them. For example, if in a specific context the user
+			chooses to treat IPv4 and IPV6 in the same way, they may create an
+			interchangeable Headers Unit consisting of these 2 headers.
+		- A Distinction Unit - a Distinction Header or an Interchangeable Headers
+			Group.
+		- Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+			IPv6, includes multicast, broadcast and other protocol specific options.
+			In terms of hardware it relates to the options available in the classification
+			plan.
+		- Network Environment Characteristics - a set of Distinction Units that define
+			the total recognizable header selection for a certain environment. This is
+			NOT the list of all headers that will ever appear in a flow, but rather
+			everything that needs distinction in a flow, where distinction is made by KeyGen
+			schemes and coarse classification action descriptors.
+
+		The PCD runtime modules initialization is done in stages. The first stage after
+		initializing the PCD module itself is to establish a Network Flows Environment
+		Definition. The application may choose to establish one or more such environments.
+		Later, when needed, the application will have to state, for some of its modules,
+		to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+t_Handle FM_PCD_Open( t_FmPcdParams *p_FmPcdParams );
+void FM_PCD_Close(t_Handle h_FmPcd);
+
+
+/**************************************************************************//**
+ @Function	FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+		PCD engines according to their existing configuration.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+uint32_t FM_PCD_Enable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+		disable all PCD engines. It may be called
+		only when none of the ports in the system are using the PCD.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+uint32_t FM_PCD_Disable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	counter	The requested counter.
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		Note that it is user's responsibility to call this routine only
+		for enabled counters, and there will be no indication if a
+		disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, ioc_fm_pcd_counters counter);
+
+/**************************************************************************//**
+@Function	FM_PCD_PrsLoadSw
+
+@Description	This routine may be called in order to load software parsing code.
+
+
+@Param[in]	h_FmPcd	FM PCD module descriptor.
+@Param[in]	p_SwPrs	A pointer to a structure of software
+				parser parameters, including the software
+				parser image.
+
+@Return	E_OK on success; Error code otherwise.
+
+@Cautions	Allowed only following FM_PCD_Init() and when PCD is disabled.
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_PrsLoadSw(t_Handle h_FmPcd, ioc_fm_pcd_prs_sw_params_t *p_SwPrs);
+
+/**************************************************************************//**
+@Function	FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+		IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]	h_FmPcd	FM PCD module descriptor.
+
+@Return	E_OK on success; Error code otherwise.
+
+@Cautions	Allowed only following FM_PCD_Init() and when PCD is disabled.
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+		by the KeyGen when parser does not recognize a required
+		field/header.
+		By default default values are 0.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	valueId	0,1 - one of 2 global default values.
+ @Param[in]	value	The requested default value.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() and when PCD is disabled.
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the KeyGen to access data past
+		the parser finishing point.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	payloadOffset   the number of bytes beyond the parser location.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() and when PCD is disabled.
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
+
+/**************************************************************************//**
+ @Function	FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	exception	The exception to be selected.
+ @Param[in]	enable	TRUE to enable interrupt, FALSE to mask it.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_SetException(t_Handle h_FmPcd, ioc_fm_pcd_exceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	counter	The requested counter.
+ @Param[in]	value	The requested value to be written into the counter.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_ModifyCounter(t_Handle h_FmPcd, ioc_fm_pcd_counters counter, uint32_t value);
+
+/**************************************************************************//**
+ @Function	FM_PCD_SetPlcrStatistics
+
+ @Description   This routine may be used to enable/disable policer statistics
+		counter. By default the statistics is enabled.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor
+ @Param[in]	enable	TRUE to enable, FALSE to disable.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PCD_SetPrsStatistics
+
+ @Description   Defines whether to gather parser statistics including all ports.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	enable	TRUE to enable, FALSE to disable.
+
+ @Return	None
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		This routine should NOT be called from guest-partition
+		(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function	FM_PCD_DumpRegs
+
+ @Description   Dumps all PCD registers
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+		are mapped.
+*//***************************************************************************/
+uint32_t FM_PCD_DumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgDumpRegs
+
+ @Description   Dumps all PCD KG registers
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+		are mapped.
+*//***************************************************************************/
+uint32_t FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Policer registers
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+		are mapped.
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileDumpRegs
+
+ @Description   Dumps all PCD Policer profile registers
+
+ @Param[in]	h_Profile	A handle to a Policer profile.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+		are mapped.
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PrsDumpRegs
+
+ @Description   Dumps all PCD Parser registers
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+		are mapped.
+*//***************************************************************************/
+uint32_t FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HcDumpRegs
+
+ @Description   Dumps HC Port registers
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+		NOTE: this routine may be called only for FM in master mode
+		(i.e. 'guestId'=NCSW_MASTER_ID).
+*//***************************************************************************/
+uint32_t	FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+
+/**************************************************************************//**
+ KeyGen	FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
+
+ @Description   Frame Manager PCD Runtime Building API
+
+		This group contains routines for setting, deleting and modifying
+		PCD resources, for defining the total PCD tree.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection	Definitions of coarse classification
+		parameters as required by KeyGen (when coarse classification
+		is the next engine after this scheme).
+*//***************************************************************************/
+#define FM_PCD_MAX_NUM_OF_CC_TREES		8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS		16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS		4
+#define FM_PCD_MAX_NUM_OF_KEYS		256
+#define FM_PCD_MAX_NUM_OF_FLOWS		(4*KILOBYTE)
+#define FM_PCD_MAX_SIZE_OF_KEY		56
+#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP	16
+#define FM_PCD_LAST_KEY_INDEX		0xffff
+
+#define FM_PCD_MAX_NUM_OF_CC_NODES		255 /* Obsolete, not used - will be removed in the future */
+/* @} */
+
+/**************************************************************************//**
+ @Collection	A set of definitions to allow protocol
+		special option description.
+*//***************************************************************************/
+typedef uint32_t	protocolOpt_t;	/**< A general type to define a protocol option. */
+
+typedef protocolOpt_t   ethProtocolOpt_t;	/**< Ethernet protocol options. */
+#define ETH_BROADCAST		0x80000000  /**< Ethernet Broadcast. */
+#define ETH_MULTICAST		0x40000000  /**< Ethernet Multicast. */
+
+typedef protocolOpt_t   vlanProtocolOpt_t;	/**< VLAN protocol options. */
+#define VLAN_STACKED		0x20000000  /**< Stacked VLAN. */
+
+typedef protocolOpt_t   mplsProtocolOpt_t;	/**< MPLS protocol options. */
+#define MPLS_STACKED		0x10000000  /**< Stacked MPLS. */
+
+typedef protocolOpt_t   ipv4ProtocolOpt_t;	/**< IPv4 protocol options. */
+#define IPV4_BROADCAST_1		0x08000000  /**< IPv4 Broadcast. */
+#define IPV4_MULTICAST_1		0x04000000  /**< IPv4 Multicast. */
+#define IPV4_UNICAST_2		0x02000000  /**< Tunneled IPv4 - Unicast. */
+#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+#define IPV4_FRAG_1		0x00000008  /**< IPV4 reassembly option.
+							IPV4 Reassembly manipulation requires network
+							environment with IPV4 header and IPV4_FRAG_1 option  */
+
+typedef protocolOpt_t   ipv6ProtocolOpt_t;	/**< IPv6 protocol options. */
+#define IPV6_MULTICAST_1	0x00800000  /**< IPv6 Multicast. */
+#define IPV6_UNICAST_2		0x00400000  /**< Tunneled IPv6 - Unicast. */
+#define IPV6_MULTICAST_2	0x00200000  /**< Tunneled IPv6 - Multicast. */
+
+#define IPV6_FRAG_1		0x00000004  /**< IPV6 reassembly option.
+							IPV6 Reassembly manipulation requires network
+							environment with IPV6 header and IPV6_FRAG_1 option;
+							in case where fragment found, the fragment-extension offset
+							may be found at 'shim2' (in parser-result). */
+#if (DPAA_VERSION >= 11)
+typedef protocolOpt_t   capwapProtocolOpt_t;	/**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1		0x00000008  /**< CAPWAP reassembly option.
+							CAPWAP Reassembly manipulation requires network
+							environment with CAPWAP header and CAPWAP_FRAG_1 option;
+							in case where fragment found, the fragment-extension offset
+							may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+
+/* @} */
+
+#define FM_PCD_MANIP_MAX_HDR_SIZE	256
+#define FM_PCD_MANIP_DSCP_TO_VLAN_TRANS	64
+
+/**************************************************************************//**
+ @Collection	A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t		hdrManipFlags_t;		/**< A general type to define a HMan update command flags. */
+
+typedef hdrManipFlags_t	ipv4HdrManipUpdateFlags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV4_TOS	0x80000000		/**< update TOS with the given value ('tos' field
+								of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_ID	0x40000000		/**< update IP ID with the given value ('id' field
+								of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_TTL	0x20000000		/**< Decrement TTL by 1 */
+#define HDR_MANIP_IPV4_SRC	0x10000000		/**< update IP source address with the given value
+								('src' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_DST	0x08000000		/**< update IP destination address with the given value
+								('dst' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+
+typedef hdrManipFlags_t	ipv6HdrManipUpdateFlags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV6_TC	0x80000000		/**< update Traffic Class address with the given value
+								('trafficClass' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_HL	0x40000000		/**< Decrement Hop Limit by 1 */
+#define HDR_MANIP_IPV6_SRC	0x20000000		/**< update IP source address with the given value
+								('src' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_DST	0x10000000		/**< update IP destination address with the given value
+								('dst' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+
+typedef hdrManipFlags_t	tcpUdpHdrManipUpdateFlags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define HDR_MANIP_TCP_UDP_SRC	0x80000000		/**< update TCP/UDP source address with the given value
+								('src' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_DST	0x40000000		/**< update TCP/UDP destination address with the given value
+								('dst' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000		/**< update TCP/UDP checksum */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+		each value in this array represents the index of the extraction
+		command as defined by the user in the initialization extraction array.
+		The valid size of this array is the user define number of extractions
+		required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef	uint8_t	t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_stats_type_t {
+	e_FM_PCD_STATS_PER_FLOWID = 0	/**< Flow ID is used as index for getting statistics */
+} ioc_fm_pcd_stats_type_t;
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
+/**************************************************************************//**
+ @Collection	Definitions for CC statistics
+*//***************************************************************************/
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_CC_STATS_MAX_NUM_OF_FLR	10  /* Maximal supported number of frame length ranges */
+#define FM_PCD_CC_STATS_FLR_SIZE		2   /* Size in bytes of a frame length range limit */
+#endif /* (DPAA_VERSION >= 11) */
+#define FM_PCD_CC_STATS_COUNTER_SIZE	4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC keys parameters
+		The driver supports two methods for CC node allocation: dynamic and static.
+		Static mode was created in order to prevent runtime alloc/free
+		of FMan memory (MURAM), which may cause fragmentation; in this mode,
+		the driver automatically allocates the memory according to
+		'maxNumOfKeys' parameter. The driver calculates the maximal memory
+		size that may be used for this CC-Node taking into consideration
+		'maskSupport' and 'statisticsMode' parameters.
+		When 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+		parameters of this node, 'maxNumOfKeys' must be equal to 'numOfKeys'.
+		In dynamic mode, 'maxNumOfKeys' must be zero. At initialization,
+		all required structures are allocated according to 'numOfKeys'
+		parameter. During runtime modification, these structures are
+		re-allocated according to the updated number of keys.
+
+		Please note that 'action' and 'icIndxMask' mentioned in the
+		specific parameter explanations are passed in the extraction
+		parameters of the node (fields of extractCcParams.extractNonHdr).
+*//***************************************************************************/
+typedef struct t_KeysParams {
+	uint16_t			maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
+							A value of zero may be used for dynamic memory allocation. */
+	bool			maskSupport;	/**< This parameter is relevant only if a node is initialized with
+							'action' = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+							Should be TRUE to reserve table memory for key masks, even if
+							initial keys do not contain masks, or if the node was initialized
+							as 'empty' (without keys); this will allow user to add keys with
+							masks at runtime.
+							NOTE that if user want to use only global-masks (i.e. one common mask
+							for all the entries within this table, this parameter should set to 'FALSE'. */
+	ioc_fm_pcd_cc_stats_mode	statisticsMode; /**< Determines the supported statistics mode for all node's keys.
+							To enable statistics gathering, statistics should be enabled per
+							every key, using 'statisticsEn' in next engine parameters structure
+							of that key;
+							If 'maxNumOfKeys' is set, all required structures will be
+							preallocated for all keys. */
+#if (DPAA_VERSION >= 11)
+	uint16_t			frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+						/**< Relevant only for 'RMON' statistics mode
+							(this feature is supported only on B4860 device);
+							Holds a list of programmable thresholds - for each received frame,
+							its length in bytes is examined against these range thresholds and
+							the appropriate counter is incremented by 1 - for example, to belong
+							to range i, the following should hold:
+							range i-1 threshold < frame length <= range i threshold
+							Each range threshold must be larger then its preceding range
+							threshold, and last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
+	uint16_t			numOfKeys;	/**< Number of initial keys;
+							Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
+							this field should be power-of-2 of the number of bits that are
+							set in 'icIndxMask'. */
+	uint8_t			keySize;	/**< Size of key - for extraction of type FULL_FIELD, 'keySize' has
+							to be the standard size of the selected key; For other extraction
+							types, 'keySize' has to be as size of extraction; When 'action' =
+							e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+	ioc_fm_pcd_cc_key_params_t	keyParams[FM_PCD_MAX_NUM_OF_KEYS];
+						/**< An array with 'numOfKeys' entries, each entry specifies the
+							corresponding key parameters;
+							When 'action' = e_FM_PCD_ACTION_EXACT_MATCH, this value must not
+							exceed 255 (FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+							for the 'miss' entry. */
+	ioc_fm_pcd_cc_next_engine_params_t   ccNextEngineParamsForMiss;
+						/**< Parameters for defining the next engine when a key is not matched;
+							Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
+} t_KeysParams;
+
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+/**************************************************************************//**
+ @Description   Parameters for defining an insertion manipulation
+		of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_by_template_params_t {
+	uint8_t	size;				/**< Size of insert template to the start of the frame. */
+	uint8_t	hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
+							/**< Array of the insertion template. */
+
+	bool		modifyOuterIp;			/**< TRUE if user want to modify some fields in outer IP. */
+	struct {
+	uint16_t	ipOuterOffset;			/**< Offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
+	uint16_t	dscpEcn;				/**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
+								in IPV4 dscpEcn only byte - it has to be adjusted to the right*/
+	bool	udpPresent;			/**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
+	uint8_t	udpOffset;			/**< Offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
+	uint8_t	ipIdentGenId;			/**< Used by FMan-CTRL to calculate IP-identification field,relevant if modifyOuterIp = TRUE.*/
+	bool	recalculateLength;		/**< TRUE if recalculate length has to be performed due to the engines in the path which can change the frame later, relevant if modifyOuterIp = TRUE.*/
+	struct {
+		uint8_t blockSize;			/**< The CAAM block-size; Used by FMan-CTRL to calculate the IP Total Length field.*/
+		uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length*/
+		uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length.*/
+	} recalculateLengthParams;			/**< Recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
+	} modifyOuterIpParams;				/**< Outer IP modification parameters - ignored if modifyOuterIp is FALSE */
+
+	bool		modifyOuterVlan;			/**< TRUE if user wants to modify VPri field in the outer VLAN header*/
+	struct {
+	uint8_t	vpri;				/**< Value of VPri, relevant if modifyOuterVlan = TRUE
+								VPri only 3 bits, it has to be adjusted to the right*/
+	} modifyOuterVlanParams;
+} ioc_fm_pcd_manip_hdr_insrt_by_template_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CAPWAP fragmentation
+*//***************************************************************************/
+typedef struct ioc_capwap_fragmentation_params {
+	uint16_t	sizeForFragmentation;		/**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
+	bool		headerOptionsCompr;		/**< TRUE - first fragment include the CAPWAP header options field,
+								and all other fragments exclude the CAPWAP options field,
+								FALSE - all fragments include CAPWAP header options field. */
+} ioc_capwap_fragmentation_params;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CAPWAP reassembly
+*//***************************************************************************/
+typedef struct ioc_capwap_reassembly_params {
+	uint16_t			maxNumFramesInProcess;  /**< Number of frames which can be reassembled concurrently; must be power of 2.
+								In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 4 - 512,
+								In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+								maxNumFramesInProcess has to be in the range of 8 - 2048 */
+	bool				haltOnDuplicationFrag;  /**< If TRUE, reassembly process will be halted due to duplicated fragment,
+								and all processed fragments will be enqueued with error indication;
+								If FALSE, only duplicated fragments will be enqueued with error indication. */
+
+	e_FmPcdManipReassemTimeOutMode  timeOutMode;		/**< Expiration delay initialized by the reassembly process */
+	uint32_t			fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
+	uint32_t			timeoutRoutineRequestTime;
+								/**< Represents the time interval in microseconds between consecutive
+								timeout routine requests It has to be power of 2. */
+	uint32_t			timeoutThresholdForReassmProcess;
+								/**< Time interval (microseconds) for marking frames in process as too old;
+								Frames in process are those for which at least one fragment was received
+								but not all fragments. */
+
+	e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry (needed for the reassembly process) */
+} ioc_capwap_reassembly_params;
+
+/**************************************************************************//**
+ @Description   Parameters for defining fragmentation/reassembly manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_or_reasm_params_t {
+	bool				frag;		/**< TRUE if using the structure for fragmentation,
+								otherwise this structure is used for reassembly */
+	uint8_t				sgBpid;		/**< Scatter/Gather buffer pool id;
+								Same LIODN number is used for these buffers as for
+								the received frames buffers, so buffers of this pool
+								need to be allocated in the same memory area as the
+								received buffers. If the received buffers arrive
+								from different sources, the Scatter/Gather BP id
+								should be mutual to all these sources. */
+	ioc_net_header_type			hdr;		/**< Header selection */
+	union {
+	ioc_capwap_fragmentation_params	capwapFragParams;   /**< Structure for CAPWAP fragmentation,
+								relevant if 'frag' = TRUE, 'hdr' = HEADER_TYPE_CAPWAP */
+	ioc_capwap_reassembly_params	capwapReasmParams;  /**< Structure for CAPWAP reassembly,
+								relevant if 'frag' = FALSE, 'hdr' = HEADER_TYPE_CAPWAP */
+	} u;
+} ioc_fm_pcd_manip_frag_or_reasm_params_t;
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for generic field replacement
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_gen_field_replace {
+	uint8_t			srcOffset;	/**< Location of new data - Offset from
+								Parse Result  (>= 16, srcOffset+size <= 32, ) */
+	uint8_t			dstOffset;	/**< Location of data to be overwritten - Offset from
+								start of frame (dstOffset + size <= 256). */
+	uint8_t			size;		/**< The number of bytes (<=16) to be replaced */
+	uint8_t			mask;		/**< Optional 1 byte mask. Set to select bits for
+								replacement (1 - bit will be replaced);
+								Clear to use field as is. */
+	uint8_t			maskOffset;	/**< Relevant if mask != 0;
+								Mask offset within the replaces "size" */
+} ioc_fm_pcd_manip_hdr_custom_gen_field_replace;
+
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+/**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_stats_params_t {
+	ioc_fm_pcd_stats_type_t	type;   /**< type of statistics node */
+} ioc_fm_pcd_stats_params_t;
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
+/**************************************************************************//**
+ @Function	FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
+
+		When setting an environment it is important to understand its
+		application. It is not meant to describe the flows that will run
+		on the ports using this environment, but what the user means TO DO
+		with the PCD mechanisms in order to parse-classify-distribute those
+		frames.
+		By specifying a distinction unit, the user means it would use that option
+		for distinction between frames at either a KeyGen scheme or a coarse
+		classification action descriptor. Using interchangeable headers to define a
+		unit means that the user is indifferent to which of the interchangeable
+		headers is present in the frame, and wants the distinction to be based
+		on the presence of either one of them.
+
+		Depending on context, there are limitations to the use of environments. A
+		port using the PCD functionality is bound to an environment. Some or even
+		all ports may share an environment but also an environment per port is
+		possible. When initializing a scheme, a classification plan group (see below),
+		or a coarse classification tree, one of the initialized environments must be
+		stated and related to. When a port is bound to a scheme, a classification
+		plan group, or a coarse classification tree, it MUST be bound to the same
+		environment.
+
+		The different PCD modules, may relate (for flows definition) ONLY on
+		distinction units as defined by their environment. When initializing a
+		scheme for example, it may not choose to select IPV4 as a match for
+		recognizing flows unless it was defined in the relating environment. In
+		fact, to guide the user through the configuration of the PCD, each module's
+		characterization in terms of flows is not done using protocol names, but using
+		environment indexes.
+
+		In terms of HW implementation, the list of distinction units sets the LCV vectors
+		and later used for match vector, classification plan vectors and coarse classification
+		indexing.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	p_NetEnvParams  A structure of parameters for the initialization of
+				the network environment.
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle,
+					ioc_fm_pcd_net_env_params_t *);
+
+/**************************************************************************//**
+ @Function	FM_PCD_NetEnvCharacteristicsDelete
+
+ @Description   Deletes a set of Network Environment Characteristics.
+
+ @Param[in]	h_NetEnv	A handle to the Network environment.
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeSet
+
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
+		This routine should be called for adding or modifying a scheme.
+		When a scheme needs modifying, the API requires that it will be
+		rewritten. In such a case 'modify' should be TRUE. If the
+		routine is called for a valid scheme and 'modify' is FALSE,
+		it will return error.
+
+ @Param[in]	h_FmPcd	If this is a new scheme - A handle to an FM PCD Module.
+				Otherwise NULL (ignored by driver).
+ @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
+
+ @Return	A handle to the initialized scheme on success; NULL code otherwise.
+		When used as "modify" (rather than for setting a new scheme),
+		p_SchemeParams->id.h_Scheme will return NULL if action fails due to scheme
+		BUSY state.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,
+			 ioc_fm_pcd_kg_scheme_params_t *p_SchemeParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeDelete
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]	h_Scheme	scheme handle as returned by FM_PCD_KgSchemeSet()
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+uint32_t	FM_PCD_KgSchemeDelete(t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeGetCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]	h_Scheme	scheme handle as returned by FM_PCD_KgSchemeSet().
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function	FM_PCD_KgSchemeSetCounter
+
+ @Description   Writes scheme packet counter.
+
+ @Param[in]	h_Scheme	scheme handle as returned by FM_PCD_KgSchemeSet().
+ @Param[in]	value	New scheme counter value - typically '0' for
+				resetting the counter.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileSet
+
+ @Description   Sets a profile entry in the policer profile table.
+		The routine overrides any existing value.
+
+ @Param[in]	h_FmPcd	A handle to an FM PCD Module.
+ @Param[in]	p_Profile	A structure of parameters for defining a
+				policer profile entry.
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+		When used as "modify" (rather than for setting a new profile),
+		p_Profile->id.h_Profile will return NULL if action fails due to profile
+		BUSY state.
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_PlcrProfileSet(t_Handle		h_FmPcd,
+				ioc_fm_pcd_plcr_profile_params_t  *p_Profile);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileDelete
+
+ @Description   Delete a profile entry in the policer profile table.
+		The routine set entry to invalid.
+
+ @Param[in]	h_Profile	A handle to the profile.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileDelete(t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileGetCounter
+
+ @Description   Sets an entry in the classification plan.
+		The routine overrides any existing value.
+
+ @Param[in]	h_Profile	A handle to the profile.
+ @Param[in]	counter	Counter selector.
+
+ @Return	specific counter value.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle			h_Profile,
+					ioc_fm_pcd_plcr_profile_counters	counter);
+
+/**************************************************************************//**
+ @Function	FM_PCD_PlcrProfileSetCounter
+
+ @Description   Sets an entry in the classification plan.
+		The routine overrides any existing value.
+
+ @Param[in]	h_Profile	A handle to the profile.
+ @Param[in]	counter	Counter selector.
+ @Param[in]	value	value to set counter with.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileSetCounter(t_Handle		h_Profile,
+					ioc_fm_pcd_plcr_profile_counters counter,
+					uint32_t		value);
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootBuild
+
+ @Description   This routine must be called to define a complete coarse
+		classification tree. This is the way to define coarse
+		classification to a certain flow - the KeyGen schemes
+		may point only to trees defined in this way.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	p_Params	A structure of parameters to define the tree.
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_CcRootBuild (t_Handle		h_FmPcd,
+				ioc_fm_pcd_cc_tree_params_t  *p_Params);
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootDelete
+
+ @Description   Deleting an built tree.
+
+ @Param[in]	h_CcTree	A handle to a CC tree.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_CcRootDelete(t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function	FM_PCD_CcRootModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]	h_CcTree			A handle to the tree
+ @Param[in]	grpId			A Group index in the tree
+ @Param[in]	index			Entry index in the group defined by grpId
+ @Param[in]	p_FmPcdCcNextEngineParams   Pointer to new next engine parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+uint32_t FM_PCD_CcRootModifyNextEngine(t_Handle		h_CcTree,
+					uint8_t		grpId,
+					uint8_t		index,
+					ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableSet
+
+ @Description   This routine should be called for each CC (coarse classification)
+		node. The whole CC tree should be built bottom up so that each
+		node points to already defined nodes.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	p_Param	A structure of parameters defining the CC node
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, ioc_fm_pcd_cc_node_params_t *p_Param);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableDelete
+
+ @Description   Deleting an built node.
+
+ @Param[in]	h_CcNode	A handle to a CC node.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableDelete(t_Handle h_CcNode);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet();
+		Not relevant in the case the node is of type 'INDEXED_LOOKUP'.
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableModifyMissNextEngine(t_Handle		h_CcNode,
+						ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+		defined by the index of the relevant node.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keyIndex			Key index for removing
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableAddKey
+
+ @Description   Add the key (including next engine parameters of this key in the
+		index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+		may be used by user that don't care about the position of the
+		key in the table - in that case, the key will be automatically
+		added by the driver in the last available entry.
+
+ @Param[in]	h_CcNode	A handle to the node
+ @Param[in]	keyIndex	Key index for adding.
+ @Param[in]	keySize	Key size of added key
+ @Param[in]	p_KeyParams  A pointer to the parameters includes
+				new key with Next Engine Parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableAddKey(t_Handle		h_CcNode,
+				uint16_t		keyIndex,
+				uint8_t		keySize,
+				ioc_fm_pcd_cc_key_params_t  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keyIndex			Key index for Next Engine modifications
+ @Param[in]	p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableModifyNextEngine(t_Handle		h_CcNode,
+					uint16_t		keyIndex,
+					ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the
+		index defined by the keyIndex.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keyIndex			Key index for adding
+ @Param[in]	keySize			Key size of added key
+ @Param[in]	p_KeyParams		A pointer to the parameters includes
+						modified key and modified Next Engine Parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle		h_CcNode,
+						uint16_t		keyIndex,
+						uint8_t		keySize,
+						ioc_fm_pcd_cc_key_params_t  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableModifyKey
+
+ @Description   Modify the key in the index defined by the keyIndex.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keyIndex			Key index for adding
+ @Param[in]	keySize			Key size of added key
+ @Param[in]	p_Key			A pointer to the new key
+ @Param[in]	p_Mask			A pointer to the new mask if relevant,
+						otherwise pointer to NULL
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
+				uint16_t keyIndex,
+				uint8_t  keySize,
+				uint8_t  *p_Key,
+				uint8_t  *p_Mask);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableFindNRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+		defined by the key and mask. Note that this routine will search
+		the node to locate the index of the required key (& mask) to remove.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keySize			Key size of the one to remove.
+ @Param[in]	p_Key			A pointer to the requested key to remove.
+ @Param[in]	p_Mask			A pointer to the mask if relevant,
+						otherwise pointer to NULL
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
+					uint8_t  keySize,
+					uint8_t  *p_Key,
+					uint8_t  *p_Mask);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableFindNModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of
+		the node. Note that this routine will search the node to locate
+		the index of the required key (& mask) to modify.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keySize			Key size of the one to modify.
+ @Param[in]	p_Key			A pointer to the requested key to modify.
+ @Param[in]	p_Mask			A pointer to the mask if relevant,
+						otherwise pointer to NULL
+ @Param[in]	p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableFindNModifyNextEngine(t_Handle		h_CcNode,
+						uint8_t		keySize,
+						uint8_t		*p_Key,
+						uint8_t		*p_Mask,
+						ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableFindNModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the
+		index defined by the keyIndex. Note that this routine will search
+		the node to locate the index of the required key (& mask) to modify.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keySize			Key size of the one to modify.
+ @Param[in]	p_Key			A pointer to the requested key to modify.
+ @Param[in]	p_Mask			A pointer to the mask if relevant,
+						otherwise pointer to NULL
+ @Param[in]	p_KeyParams		A pointer to the parameters includes
+						modified key and modified Next Engine Parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle		h_CcNode,
+							uint8_t		keySize,
+							uint8_t		*p_Key,
+							uint8_t		*p_Mask,
+							ioc_fm_pcd_cc_key_params_t  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableFindNModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex. Note that
+		this routine will search the node to locate the index of the
+		required key (& mask) to modify.
+
+ @Param[in]	h_CcNode			A handle to the node
+ @Param[in]	keySize			Key size of the one to modify.
+ @Param[in]	p_Key			A pointer to the requested key to modify.
+ @Param[in]	p_Mask			A pointer to the mask if relevant,
+						otherwise pointer to NULL
+ @Param[in]	p_NewKey			A pointer to the new key
+ @Param[in]	p_NewMask		A pointer to the new mask if relevant,
+						otherwise pointer to NULL
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet() was called for this
+		node and the nodes that lead to it.
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
+					uint8_t  keySize,
+					uint8_t  *p_Key,
+					uint8_t  *p_Mask,
+					uint8_t  *p_NewKey,
+					uint8_t  *p_NewMask);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableGetKeyCounter
+
+ @Description   This routine may be used to get a counter of specific key in a CC
+		Node; This counter reflects how many frames passed that were matched
+		this key.
+
+ @Param[in]	h_CcNode	A handle to the node
+ @Param[in]	keyIndex	Key index for adding
+
+ @Return	The specific key counter.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+		in a CC Node.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames passed that were matched
+		this key; The total frames count will be returned in the counter
+		of the first range (as only one frame length range was defined).
+		If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+		frame count will be separated to frame length counters, based on
+		provided frame length ranges.
+
+ @Param[in]	h_CcNode	A handle to the node
+ @Param[in]	keyIndex	Key index for adding
+ @Param[out]	p_KeyStatistics Key statistics counters
+
+ @Return	The specific key statistics.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetKeyStatistics(t_Handle		h_CcNode,
+					uint16_t		keyIndex,
+					ioc_fm_pcd_cc_key_statistics_t	*p_KeyStatistics);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of miss entry
+		in a CC Node.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames were not matched to any
+		existing key and therefore passed through the miss entry; The
+		total frames count will be returned in the counter of the
+		first range (as only one frame length range was defined).
+
+ @Param[in]	h_CcNode		A handle to the node
+ @Param[out]	p_MissStatistics	Statistics counters for 'miss'
+
+ @Return	The statistics for 'miss'.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetMissStatistics(t_Handle		h_CcNode,
+					ioc_fm_pcd_cc_key_statistics_t	*p_MissStatistics);
+
+/**************************************************************************//**
+ @Function	FM_PCD_MatchTableFindNGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+		in a CC Node.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames passed that were matched
+		this key; The total frames count will be returned in the counter
+		of the first range (as only one frame length range was defined).
+		If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+		frame count will be separated to frame length counters, based on
+		provided frame length ranges.
+		Note that this routine will search the node to locate the index
+		of the required key based on received key parameters.
+
+ @Param[in]	h_CcNode	A handle to the node
+ @Param[in]	keySize	Size of the requested key
+ @Param[in]	p_Key	A pointer to the requested key
+ @Param[in]	p_Mask	A pointer to the mask if relevant,
+				otherwise pointer to NULL
+ @Param[out]	p_KeyStatistics Key statistics counters
+
+ @Return	The specific key statistics.
+
+ @Cautions	Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle		h_CcNode,
+						uint8_t		keySize,
+						uint8_t		*p_Key,
+						uint8_t		*p_Mask,
+						ioc_fm_pcd_cc_key_statistics_t   *p_KeyStatistics);
+
+/**************************************************************************//*
+ @Function	FM_PCD_MatchTableGetNextEngine
+
+ @Description   Gets NextEngine of the relevant keyIndex.
+
+ @Param[in]	h_CcNode			A handle to the node.
+ @Param[in]	keyIndex			keyIndex in the relevant node.
+ @Param[out]	p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
+						the relevant keyIndex of the CC Node
+						received as parameter to this function
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetNextEngine(t_Handle			h_CcNode,
+					uint16_t			keyIndex,
+					ioc_fm_pcd_cc_next_engine_params_t	*p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function	FM_PCD_MatchTableGetIndexedHashBucket
+
+ @Description   This routine simulates KeyGen operation on the provided key and
+		calculates to which hash bucket it will be mapped.
+
+ @Param[in]	h_CcNode		A handle to the node.
+ @Param[in]	kgKeySize		Key size as it was configured in the KG
+					scheme that leads to this hash.
+ @Param[in]	p_KgKey		Pointer to the key; must be like the key
+					that the KG is generated, i.e. the same
+					extraction and with mask if exist.
+ @Param[in]	kgHashShift		Hash-shift as it was configured in the KG
+					scheme that leads to this hash.
+ @Param[out]	p_CcNodeBucketHandle	Pointer to the bucket of the provided key.
+ @Param[out]	p_BucketIndex	Index to the bucket of the provided key
+ @Param[out]	p_LastIndex		Pointer to last index in the bucket of the
+					provided key.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet()
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetIndexedHashBucket(t_Handle	h_CcNode,
+						uint8_t	kgKeySize,
+						uint8_t	*p_KgKey,
+						uint8_t	kgHashShift,
+						t_Handle	*p_CcNodeBucketHandle,
+						uint8_t	*p_BucketIndex,
+						uint16_t	*p_LastIndex);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+		KeyGen hash result determines the hash bucket.
+		Next, KeyGen key is compared against all keys of this
+		bucket (exact match).
+		Number of sets (number of buckets) of the hash equals to the
+		number of 1-s in 'hashResMask' in the provided parameters.
+		Number of hash table ways is then calculated by dividing
+		'maxNumOfKeys' equally between the hash sets. This is the maximal
+		number of keys that a hash bucket may hold.
+		The hash table is initialized empty and keys may be
+		added to it following the initialization. Keys masks are not
+		supported in current hash table implementation.
+		The initialized hash table can be integrated as a node in a
+		CC tree.
+
+ @Param[in]	h_FmPcd	FM PCD module descriptor.
+ @Param[in]	p_Param	A structure of parameters defining the hash table
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, ioc_fm_pcd_hash_table_params_t *p_Param);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableDelete
+
+ @Description   This routine deletes the provided hash table and released all
+		its allocated resources.
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableDelete(t_Handle h_HashTbl);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableAddKey
+
+ @Description   This routine adds the provided key (including next engine
+		parameters of this key) to the hash table.
+		The key is added as the last key of the bucket that it is
+		mapped to.
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+ @Param[in]	keySize	Key size of added key
+ @Param[in]	p_KeyParams  A pointer to the parameters includes
+				new key with next engine parameters; The pointer
+				to the key mask must be NULL, as masks are not
+				supported in hash table implementation.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableAddKey(t_Handle		h_HashTbl,
+				uint8_t		keySize,
+				ioc_fm_pcd_cc_key_params_t  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableRemoveKey
+
+ @Description   This routine removes the requested key (including next engine
+		parameters of this key) from the hash table.
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+ @Param[in]	keySize	Key size of the one to remove.
+ @Param[in]	p_Key	A pointer to the requested key to remove.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
+				uint8_t  keySize,
+				uint8_t  *p_Key);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableModifyNextEngine
+
+ @Description   This routine modifies the next engine for the provided key. The
+		key should be previously added to the hash table.
+
+ @Param[in]	h_HashTbl		A handle to a hash table
+ @Param[in]	keySize			Key size of the key to modify.
+ @Param[in]	p_Key			A pointer to the requested key to modify.
+ @Param[in]	p_FmPcdCcNextEngineParams   A structure for defining new next engine
+						parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableModifyNextEngine(t_Handle		h_HashTbl,
+					uint8_t		keySize,
+					uint8_t		*p_Key,
+					ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableModifyMissNextEngine
+
+ @Description   This routine modifies the next engine on key match miss.
+
+ @Param[in]	h_HashTbl		A handle to a hash table
+ @Param[in]	p_FmPcdCcNextEngineParams   A structure for defining new next engine
+						parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+		When configuring nextEngine = e_FM_PCD_CC, note that
+		p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+		from the currently changed table.
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableModifyMissNextEngine(t_Handle		h_HashTbl,
+						ioc_fm_pcd_cc_next_engine_params_t *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function	FM_PCD_HashTableGetMissNextEngine
+
+ @Description   Gets NextEngine in case of key match miss.
+
+ @Param[in]	h_HashTbl		A handle to a hash table
+ @Param[out]	p_FmPcdCcNextEngineParams   Next engine parameters for the specified
+						hash table.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableGetMissNextEngine(t_Handle			h_HashTbl,
+					ioc_fm_pcd_cc_next_engine_params_t	*p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableFindNGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+		in a hash table.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames passed that were matched
+		this key; The total frames count will be returned in the counter
+		of the first range (as only one frame length range was defined).
+		If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+		frame count will be separated to frame length counters, based on
+		provided frame length ranges.
+		Note that this routine will identify the bucket of this key in
+		the hash table and will search the bucket to locate the index
+		of the required key based on received key parameters.
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+ @Param[in]	keySize	Size of the requested key
+ @Param[in]	p_Key	A pointer to the requested key
+ @Param[out]	p_KeyStatistics Key statistics counters
+
+ @Return	The specific key statistics.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableFindNGetKeyStatistics(t_Handle		h_HashTbl,
+						uint8_t		keySize,
+						uint8_t		*p_Key,
+						ioc_fm_pcd_cc_key_statistics_t   *p_KeyStatistics);
+
+/**************************************************************************//**
+ @Function	FM_PCD_HashTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of 'miss'
+		entry of the a hash table.
+
+		If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+		'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+		these counters reflect how many frames were not matched to any
+		existing key and therefore passed through the miss entry;
+
+ @Param[in]	h_HashTbl	A handle to a hash table
+ @Param[out]	p_MissStatistics	Statistics counters for 'miss'
+
+ @Return	The statistics for 'miss'.
+
+ @Cautions	Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_HashTableGetMissStatistics(t_Handle		h_HashTbl,
+					ioc_fm_pcd_cc_key_statistics_t   *p_MissStatistics);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+		node. A manipulation node must be defined before the CC node
+		that precedes it.
+
+ @Param[in]	h_FmPcd		FM PCD module descriptor.
+ @Param[in]	p_FmPcdManipParams  A structure of parameters defining the manipulation
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, ioc_fm_pcd_manip_params_t *p_FmPcdManipParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]	h_ManipNode	A handle to a manipulation node.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+uint32_t  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipGetStatistics
+
+ @Description   Retrieve the manipulation statistics.
+
+ @Param[in]	h_ManipNode	A handle to a manipulation node.
+ @Param[out]	p_FmPcdManipStats   A structure for retrieving the manipulation statistics
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+uint32_t FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, ioc_fm_pcd_manip_stats_t *p_FmPcdManipStats);
+
+/**************************************************************************//**
+ @Function	FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+
+ @Param[in]	h_ManipNode	A handle to a manipulation node.
+ @Param[out]	p_ManipParams	A structure of parameters defining the change requirement
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+uint32_t FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, ioc_fm_pcd_manip_params_t *p_ManipParams);
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]	h_FmPcd		FM PCD module descriptor.
+ @Param[in]	p_FrmReplicGroupParam  A structure of parameters for the initialization of
+					the frame replicator group.
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, ioc_fm_pcd_frm_replic_group_params_t *p_FrmReplicGroupParam);
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]	h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return	E_OK on success;  Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+uint32_t FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup);
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]	h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]	memberIndex	member index for adding.
+ @Param[in]	p_MemberParams	A pointer to the new member parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+uint32_t FM_PCD_FrmReplicAddMember(t_Handle		h_FrmReplicGroup,
+				uint16_t		memberIndex,
+				ioc_fm_pcd_cc_next_engine_params_t *p_MemberParams);
+
+/**************************************************************************//**
+ @Function	FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]	h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]	memberIndex	member index for removing.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+uint32_t FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
+					uint16_t memberIndex);
+#endif /* (DPAA_VERSION >= 11) */
+
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+/**************************************************************************//**
+ @Function	FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in]	h_FmPcd		FM PCD module descriptor.
+ @Param[in]	p_FmPcdstatsParams  A structure of parameters defining the statistics
+
+ @Return	A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions	Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, ioc_fm_pcd_stats_params_t *p_FmPcdstatsParams);
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
+/** @} */ /* end of FM_PCD_Runtime_build_grp group */
+/** @} */ /* end of FM_PCD_Runtime_grp group */
+/** @} */ /* end of FM_PCD_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_PCD_EXT_H */
diff --git a/drivers/net/dpaa/fmlib/fm_port_ext.h b/drivers/net/dpaa/fmlib/fm_port_ext.h
new file mode 100644
index 000000000000..b4b005fc3bd2
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/fm_port_ext.h
@@ -0,0 +1,3448 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_PORT_EXT_H
+#define __FM_PORT_EXT_H
+
+#include <errno.h>
+#include "ncsw_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_ext.h"
+#include "net_ext.h"
+#include "dpaa_integration.h"
+
+/******************************************************************************
+ @Description   FM Port routines
+*//***************************************************************************/
+
+/**************************************************************************//**
+
+ @Group		lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group		lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+	The FM uses a general module called "port" to represent a Tx port
+	(MAC), an Rx port (MAC), offline parsing flow or host command
+	flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+	ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+	Host command/Offline parsing ports. The SW driver manages these
+	ports as sub-modules of the FM, i.e. after an FM is initialized,
+	its ports may be initialized and operated upon.
+
+	The port is initialized aware of its type, but other functions on
+	a port may be indifferent to its type. When necessary, the driver
+	verifies coherency and returns error if applicable.
+
+	On initialization, user specifies the port type and it's index
+	(relative to the port's type). Host command and Offline parsing
+	ports share the same id range, I.e user may not initialized host
+	command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+	(Must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
+
+	This enum defines the superset of PCD engines support - i.e. not
+	all engines have to be used, but all have to be enabled. The real
+	flow of a specific frame depends on the PCD configuration and the
+	frame headers and payload.
+	Note: the first engine and the first engine after the parser (if
+	exists) should be in order, the order is important as it will
+	define the flow of the port. However, as for the rest engines
+	(the ones that follows), the order is not important anymore as
+	it is defined by the PCD graph itself.
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+	e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0				/**< BMI to BMI, PCD is not used */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY				/**< Use only Parser */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY			/**< Use only Policer */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR			/**< Use Parser and Policer */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG			/**< Use Parser and Keygen */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC	/**< Use Parser, Keygen and Coarse Classification */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+								/**< Use all PCD engines */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR	/**< Use Parser, Keygen and Policer */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC			/**< Use Parser and Coarse Classification */
+	, e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR	/**< Use Parser and Coarse Classification and Policer */
+	, e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY				/**< Use only Coarse Classification */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+	, e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG			/**< Use Coarse Classification,and Keygen */
+	, e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR	/**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_port_pcd_support;
+
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t	ioc_fm_port_frame_err_select_t;	/**< typedef for defining Frame Descriptor errors */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   An enum for defining Dual Tx rate limiting scale.
+				(Must match e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_dual_rate_limiter_scale_down {
+	e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,		/**< Use only single rate limiter  */
+	e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,	/**< Divide high rate limiter by 2 */
+	e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,	/**< Divide high rate limiter by 4 */
+	e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8	/**< Divide high rate limiter by 8 */
+} ioc_fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+				(Must match struct t_FmPortRateLimit defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit_t {
+	uint16_t							max_burst_size;		/**< in KBytes for Tx ports, in frames
+								for offline parsing ports. (note that
+								for early chips burst size is
+								rounded up to a multiply of 1000 frames).*/
+	uint32_t							rate_limit;			/**< in Kb/sec for Tx ports, in frame/sec for
+								offline parsing ports. Rate limit refers to
+								data rate (rather than line rate). */
+	ioc_fm_port_dual_rate_limiter_scale_down rate_limit_divider;	/**< For offline parsing ports only. Not-valid
+								for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+
+/**************************************************************************//**
+ @Group		lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining FM Port counters.
+				(Must match enum e_FmPortCounters defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_counters {
+	e_IOC_FM_PORT_COUNTERS_CYCLE,					/**< BMI performance counter */
+	e_IOC_FM_PORT_COUNTERS_TASK_UTIL,				/**< BMI performance counter */
+	e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,				/**< BMI performance counter */
+	e_IOC_FM_PORT_COUNTERS_DMA_UTIL,					/**< BMI performance counter */
+	e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,				/**< BMI performance counter */
+	e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,		/**< BMI Rx only performance counter */
+	e_IOC_FM_PORT_COUNTERS_FRAME,					/**< BMI statistics counter */
+	e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,			/**< BMI statistics counter */
+	e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,				/**< BMI deallocate buffer statistics counter */
+	e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,				/**< BMI Rx only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,			/**< BMI Rx only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,			/**< BMI Rx & OP only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,			/**< BMI Rx, OP & HC only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+	e_IOC_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,				/**< BMI OP & HC only statistics counter */
+	e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,				/**< BMI non-Rx statistics counter */
+	e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,		/**< BMI non-Rx statistics counter */
+	e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,				/**< QMI total QM dequeues counter */
+	e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,				/**< QMI total QM enqueues counter */
+	e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,			/**< QMI counter */
+	e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM				/**< QMI counter */
+} ioc_fm_port_counters;
+
+typedef struct ioc_fm_port_bmi_stats_t {
+	uint32_t cnt_cycle;
+	uint32_t cnt_task_util;
+	uint32_t cnt_queue_util;
+	uint32_t cnt_dma_util;
+	uint32_t cnt_fifo_util;
+	uint32_t cnt_rx_pause_activation;
+	uint32_t cnt_frame;
+	uint32_t cnt_discard_frame;
+	uint32_t cnt_dealloc_buf;
+	uint32_t cnt_rx_bad_frame;
+	uint32_t cnt_rx_large_frame;
+	uint32_t cnt_rx_filter_frame;
+	uint32_t cnt_rx_list_dma_err;
+	uint32_t cnt_rx_out_of_buffers_discard;
+	uint32_t cnt_wred_discard;
+	uint32_t cnt_length_err;
+	uint32_t cnt_unsupported_format;
+} ioc_fm_port_bmi_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+				(Description may be inaccurate;
+				must match struct t_FmPortCongestionGrps defined in fm_port_ext.h)
+
+				Fields commented 'IN' are passed by the port module to be used
+				by the FM module.
+				Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+	uint16_t	num_of_congestion_grps_to_consider;	/**< The number of required congestion groups
+								to define the size of the following array */
+	uint8_t	congestion_grps_to_consider [FM_PORT_NUM_OF_CONGESTION_GRPS];
+								/**< An array of CG indexes;
+								Note that the size of the array should be
+								'num_of_congestion_grps_to_consider'. */
+#if DPAA_VERSION >= 11
+	bool	pfc_priorities_enable[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+								/**< A matrix that represents the map between the CG ids
+								defined in 'congestion_grps_to_consider' to the priorities
+								mapping array. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_port_congestion_groups_t;
+
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+				tasks associated with the port are terminated.
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	This is a blocking routine, it returns after port is
+				gracefully stopped, i.e. the port will not except new frames,
+				but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function	FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+				By default, this functionality is disabled.
+				Note that rate-limit mechanism uses the FM time stamp.
+				The selected rate limit specified here would be
+				rounded DOWN to the nearest 16M.
+
+				May be used for Tx and offline parsing ports only
+
+ @Param[in]	ioc_fm_port_rate_limit A structure of rate limit parameters
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables the previously enabled rate limit.
+
+				May be used for Tx and offline parsing ports only
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_RATE_LIMIT   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+#define FM_PORT_IOC_REMOVE_RATE_LIMIT   FM_PORT_IOC_DELETE_RATE_LIMIT
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+				It should be called in order to enable pause
+				frame transmission in case of congestion in one or more
+				of the congestion groups relevant to this port.
+				Each call to this routine may add one or more congestion
+				groups to be considered relevant to this port.
+
+				May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]	ioc_fm_port_congestion_groups_t - A pointer to an array of
+									congestion group ids to consider.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_CONGESTION_GRPS	_IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(34), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+				called when congestion groups were
+				defined for this port and are no longer relevant, or pause
+				frames transmitting is not required on their behalf.
+				Each call to this routine may remove one or more congestion
+				groups to be considered relevant to this port.
+
+				May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]	ioc_fm_port_congestion_groups_t - A pointer to an array of
+									congestion group ids to consider.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_CONGESTION_GRPS	_IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(35), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+				to be enqueued to error queue.
+				Errors not selected for this routine will cause a frame with that error
+				to be enqueued to the one of the other port queues.
+				By default all errors are defined to be enqueued to error queue.
+				Errors that were configured to be discarded (at initialization)
+				may not be selected here.
+
+				May be used for Rx and offline parsing ports only
+
+ @Param[in]	ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				(szbs001: How is it possible to have one function that needs to be
+						called BEFORE FM_PORT_Init() implemented as an ioctl,
+						which will ALWAYS be called AFTER the FM_PORT_Init()
+						for that port!?!?!?!???!?!??!?!?)
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
+
+
+/**************************************************************************//**
+ @Group		lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure defining the KG scheme after the parser.
+				(Must match struct ioc_fm_pcd_kg_scheme_select_t defined in fm_port_ext.h)
+
+				This is relevant only to change scheme selection mode - from
+				direct to indirect and vice versa, or when the scheme is selected directly,
+				to select the scheme id.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+	bool	direct;					/**< TRUE to use 'scheme_id' directly, FALSE to use LCV.*/
+	void	*scheme_id;				/**< Relevant for 'direct'=TRUE only.
+									'scheme_id' selects the scheme after parser. */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description   Scheme IDs structure
+				(Must match struct ioc_fm_pcd_port_schemes_params_t defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+	uint8_t	num_of_schemes;						/**< Number of schemes for port to be bound to. */
+	void		*scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];  /**< Array of 'num_of_schemes' schemes for the
+								port to be bound to */
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   A union for defining port protocol parameters for parser
+				(Must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+	/* MPLS */
+	struct {
+		bool				label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+								interpreted as described in HW spec table. When the bit
+								is cleared, the parser will advance to MPLS next parse */
+		ioc_net_header_type next_parse;				/**< must be equal or higher than IPv4 */
+	} mpls_prs_options;
+
+	/* VLAN */
+	struct {
+		uint16_t			tag_protocol_id1;		/**< User defined Tag Protocol Identifier, to be recognized
+								on VLAN TAG on top of 0x8100 and 0x88A8 */
+		uint16_t			tag_protocol_id2;		/**< User defined Tag Protocol Identifier, to be recognized
+								on VLAN TAG on top of 0x8100 and 0x88A8 */
+	} vlan_prs_options;
+
+	/* PPP */
+	struct{
+		bool				enable_mtu_check;		/**< Check validity of MTU according to RFC2516 */
+	} pppoe_prs_options;
+
+	/* IPV6 */
+	struct {
+		bool				routing_hdr_disable;		/**< Disable routing header */
+	} ipv6_prs_options;
+
+	/* UDP */
+	struct {
+		bool				pad_ignore_checksum;		/**< TRUE to ignore pad in checksum */
+	} udp_prs_options;
+
+	/* TCP */
+	struct {
+		bool				pad_ignore_checksum;		/**< TRUE to ignore pad in checksum */
+	} tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+				(must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+	ioc_net_header_type		hdr;				/**< Selected header */
+	bool						err_disable;		/**< TRUE to disable error indication */
+	bool						soft_prs_enable;	/**< Enable jump to SW parser when this
+								header is recognized by the HW parser. */
+	uint8_t					index_per_hdr;	/**< Normally 0, if more than one sw parser
+								attachments exists for the same header,
+								(in the main sw parser code) use this
+								index to distinguish between them. */
+	bool						use_prs_opts;	/**< TRUE to use parser options. */
+	ioc_fm_pcd_hdr_prs_opts_u   prs_opts;		/**< A unuion according to header type,
+								defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+				(Must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+	uint8_t						prs_res_priv_info;	/**< The private info provides a method of inserting
+								port information into the parser result. This information
+								may be extracted by KeyGen and be used for frames
+								distribution when a per-port distinction is required,
+								it may also be used as a port logical id for analyzing
+								incoming frames. */
+	uint8_t						parsing_offset;		/**< Number of bytes from begining of packet to start parsing */
+	ioc_net_header_type			first_prs_hdr;		/**< The type of the first header axpected at 'parsing_offset' */
+	bool							include_in_prs_statistics; /**< TRUE to include this port in the parser statistics */
+	uint8_t						num_of_hdrs_with_additional_params;
+								/**< Normally 0, some headers may get special parameters */
+	ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+								/**< 'num_of_hdrs_with_additional_params' structures
+								additional parameters for each header that requires them */
+	bool							set_vlan_tpid1;		/**< TRUE to configure user selection of Ethertype to
+								indicate a VLAN tag (in addition to the TPID values
+								0x8100 and 0x88A8). */
+	uint16_t						vlan_tpid1;			/**< extra tag to use if set_vlan_tpid1=TRUE. */
+	bool							set_vlan_tpid2;		/**< TRUE to configure user selection of Ethertype to
+								indicate a VLAN tag (in addition to the TPID values
+								0x8100 and 0x88A8). */
+	uint16_t						vlan_tpid2;			/**< extra tag to use if set_vlan_tpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining coarse alassification parameters
+				(Must match t_FmPortPcdCcParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+	void				*cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining keygen parameters
+				(Must match t_FmPortPcdKgParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+	uint8_t			num_of_schemes;				/**< Number of schemes for port to be bound to. */
+	void			*scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
+								/**< Array of 'num_of_schemes' schemes for the
+								port to be bound to */
+	bool				direct_scheme;				/**< TRUE for going from parser to a specific scheme,
+								regardless of parser result */
+	void			*direct_scheme_id;			/**< Scheme id, as returned by FM_PCD_KgSetScheme;
+								relevant only if direct=TRUE. */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer parameters
+				(Must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+	void				*plcr_profile_id;			/**< Selected profile handle;
+								relevant in one of the following cases:
+								e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+								e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+								or if any flow uses a KG scheme where policer
+								profile is not generated (bypass_plcr_profile_generation selected) */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+				(Must match struct t_FmPortPcdParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+	ioc_fm_port_pcd_support		pcd_support;	/**< Relevant for Rx and offline ports only.
+								Describes the active PCD engines for this port. */
+	void				*net_env_id;	/**< HL Unused in PLCR only mode */
+	ioc_fm_port_pcd_prs_params_t	*p_prs_params;  /**< Parser parameters for this port */
+	ioc_fm_port_pcd_cc_params_t	*p_cc_params;   /**< Coarse classification parameters for this port */
+	ioc_fm_port_pcd_kg_params_t	*p_kg_params;   /**< Keygen parameters for this port */
+	ioc_fm_port_pcd_plcr_params_t	*p_plcr_params; /**< Policer parameters for this port */
+	void				*p_ip_reassembly_manip;/**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+	void				*p_capwap_reassembly_manip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+				(Must match struct ioc_fm_pcd_prs_start_t defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+	uint8_t			parsing_offset; /**< Number of bytes from begining of packet to
+								start parsing */
+	ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+								'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+	uint32_t			num_fqids;  /**< Number of fqids to be allocated for the port */
+	uint8_t			alignment;  /**< Alignment required for this port */
+	uint32_t			base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+				May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_IOC_FREE_PCD_FQIDS
+
+ @Description   Frees previously-allocated FQIDs
+
+				May be used for Rx and offline parsing ports only
+
+ @Param[in]		uint32_t	Base FQID of previously allocated range.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_FREE_PCD_FQIDS   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), uint32_t)
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+				It changes it from its default configuration which is PCD
+				disabled (BMI to BMI) and configures it according to the passed
+				parameters.
+
+				May be used for Rx and offline parsing ports only
+
+ @Param[in]	ioc_fm_port_pcd_params_t	A Structure of parameters defining the port's PCD
+								configuration.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
+#endif
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+				The port returns to its default configuration which is PCD
+				disabled (BMI to BMI) and all PCD configuration is removed.
+
+				May be used for Rx and offline parsing ports which are
+				in PCD mode only
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function	FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+				to return to the originally configured PCD support flow.
+				The couple of routines are used to allow PCD configuration changes
+				that demand that PCD will not be used while changes take place.
+
+				May be used for Rx and offline parsing ports which are
+				in PCD mode only
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function	FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+				The port returns to its default flow which is BMI to BMI.
+
+				May be used for Rx and offline parsing ports which are
+				in PCD mode only
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+				order to allocate private policer profiles.
+
+ @Param[in]	uint16_t	The number of required policer profiles
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES	_IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES	_IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+				order to change the initial scheme frame should be routed to.
+				The change may be of a scheme id (in case of direct mode),
+				from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]	ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+									a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+				e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only,
+				to change the initial Policer profile frame should be routed to.
+				The change may be of a profile and/or absolute/direct mode selection.
+
+ @Param[in]	ioc_fm_obj_t	Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return	0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called to change this port connection to
+				a pre-initializes coarse classification Tree.
+
+ @Param[in]	ioc_fm_obj_t	Id of new coarse classification tree selected for this port.
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+				to schemes. The scheme itself is not added,
+				just this specific port starts using it.
+
+ @Param[in]	ioc_fm_pcd_port_schemes_params_t	Schemes parameters structre
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+				to schemes. The scheme itself is not removed or invalidated,
+				just this specific port stops using it.
+
+ @Param[in]	ioc_fm_pcd_port_schemes_params_t	Schemes parameters structre
+
+ @Return	0 on success; error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+#define ENET_NUM_OCTETS_PER_ADDRESS 6	/**< Number of octets (8-bit bytes) in an ethernet address */
+typedef struct ioc_fm_port_mac_addr_params_t {
+	uint8_t addr[ENET_NUM_OCTETS_PER_ADDRESS];
+} ioc_fm_port_mac_addr_params_t;
+
+/**************************************************************************//**
+ @Function	FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]	ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions	Some address need to be filtered out in upper FM blocks.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(36), ioc_fm_port_mac_addr_params_t)
+
+/**************************************************************************//**
+ @Function	FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]	ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(37), ioc_fm_port_mac_addr_params_t)
+
+typedef struct ioc_fm_port_tx_pause_frames_params_t {
+	uint8_t  priority;
+	uint16_t pause_time;
+	uint16_t thresh_time;
+} ioc_fm_port_tx_pause_frames_params_t;
+
+/**************************************************************************//**
+ @Function	FM_MAC_SetTxPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+				The routine changes the default configuration:
+				pause-time - [0xf000]
+				threshold-time - [0]
+
+ @Param[in]	ioc_fm_port_tx_pause_frames_params_t A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_MAC_Init().
+				PFC is supported only on new mEMAC; i.e. in MACs that don't have
+				PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
+				in the 'priority' field.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_TX_PAUSE_FRAMES	_IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(40), ioc_fm_port_tx_pause_frames_params_t)
+
+typedef struct ioc_fm_port_mac_statistics_t {
+	/* RMON */
+		uint64_t  e_stat_pkts_64;			/**< r-10G tr-DT 64 byte frame counter */
+		uint64_t  e_stat_pkts_65_to_127;	/**< r-10G 65 to 127 byte frame counter */
+		uint64_t  e_stat_pkts_128_to_255;	/**< r-10G 128 to 255 byte frame counter */
+		uint64_t  e_stat_pkts_256_to_511;	/**< r-10G 256 to 511 byte frame counter */
+		uint64_t  e_stat_pkts_512_to_1023;   /**< r-10G 512 to 1023 byte frame counter */
+		uint64_t  e_stat_pkts_1024_to_1518;  /**< r-10G 1024 to 1518 byte frame counter */
+		uint64_t  e_stat_pkts_1519_to_1522;  /**< r-10G 1519 to 1522 byte good frame count */
+	/* */
+		uint64_t  e_stat_fragments;		/**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+		uint64_t  e_stat_jabbers;			/**< Total number of packets longer than valid maximum length octets */
+		uint64_t  e_stat_drop_events;		/**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
+		uint64_t  e_stat_CRC_align_errors;   /**< Incremented when frames of correct length but with CRC error are received.*/
+		uint64_t  e_stat_undersize_pkts;	/**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
+									This count does not include range length errors */
+		uint64_t  e_stat_oversize_pkts;	/**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
+									a valid FCS and otherwise well formed */
+	/* Pause */
+		uint64_t  te_stat_pause;			/**< Pause MAC Control received */
+		uint64_t  re_stat_pause;			/**< Pause MAC Control sent */
+	/* MIB II */
+		uint64_t  if_in_octets;			/**< Total number of byte received. */
+		uint64_t  if_in_pkts;				/**< Total number of packets received.*/
+		uint64_t  if_in_ucast_pkts;		/**< Total number of unicast frame received;
+								NOTE: this counter is not supported on dTSEC MAC */
+		uint64_t  if_in_mcast_pkts;		/**< Total number of multicast frame received*/
+		uint64_t  if_in_bcast_pkts;		/**< Total number of broadcast frame received */
+		uint64_t  if_in_discards;			/**< Frames received, but discarded due to problems within the MAC RX. */
+		uint64_t  if_in_errors;			/**< Number of frames received with error:
+									- FIFO Overflow Error
+									- CRC Error
+									- Frame Too Long Error
+									- Alignment Error
+									- The dedicated Error Code (0xfe, not a code error) was received */
+		uint64_t  if_out_octets;			/**< Total number of byte sent. */
+		uint64_t  if_out_pkts;			/**< Total number of packets sent .*/
+		uint64_t  if_out_ucast_pkts;		/**< Total number of unicast frame sent;
+								NOTE: this counter is not supported on dTSEC MAC */
+		uint64_t  if_out_mcast_pkts;		/**< Total number of multicast frame sent */
+		uint64_t  if_out_bcast_pkts;		/**< Total number of multicast frame sent */
+		uint64_t  if_out_discards;		/**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+		uint64_t  if_out_errors;			/**< Number of frames transmitted with error:
+									- FIFO Overflow Error
+									- FIFO Underflow Error
+									- Other */
+} ioc_fm_port_mac_statistics_t;
+
+/**************************************************************************//**
+ @Function	FM_MAC_GetStatistics
+
+ @Description   get all MAC statistics counters
+
+ @Param[out]	ioc_fm_port_mac_statistics_t	A structure holding the statistics
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_GET_MAC_STATISTICS	_IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(41), ioc_fm_port_mac_statistics_t)
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+				The prefix will
+				In Tx ports, if 'passPrsResult', the application
+				should set a value to their offsets in the prefix of
+				the FM will save the first 'privDataSize', than,
+				depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+				and timeStamp, and the packet itself (in this order), to the
+				application buffer, and to offset.
+				Calling this routine changes the buffer margins definitions
+				in the internal driver data base from its default
+				configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+							Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+							Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+				May be used for all ports
+
+ @Param[in]	ioc_fm_buffer_prefix_content_t  A structure holding the required parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(39), ioc_fm_buffer_prefix_content_t)
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_port_vsp_alloc_params_t {
+	uint8_t	num_of_profiles;		/**< Number of Virtual Storage Profiles */
+	uint8_t	dflt_relative_id;		/**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
+								The same default Virtual-Storage-Profile-id will be for coupled Tx port
+								if relevant function called for Rx port */
+	void	*p_fm_tx_port;			/**< Handle to coupled Tx Port; not relevant for OP port. */
+}ioc_fm_port_vsp_alloc_params_t;
+
+/**************************************************************************//**
+ @Function	FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+				in VSP mode. Note that the port is initialized by default with the
+				physical-storage-profile only.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_Params	A structure of parameters for allocation VSP's per port
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+				and also before FM_PORT_Enable() (i.e. the port should be disabled).
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_VSP_ALLOC_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_compat_fm_port_vsp_alloc_params_t)
+#endif
+#define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+				a designated structure of counters.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[out]	p_BmiStats  counters structure
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+
+#define FM_PORT_IOC_GET_BMI_COUNTERS _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(42), ioc_fm_port_bmi_stats_t)
+
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+
+
+/**************************************************************************//**
+ @Group		gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group		gen_error_id  Errors, Events and Debug
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/******************************************************************************
+The scheme below provides the bits description for error codes:
+
+ 0	1	2	3	4	5	6	7	8	9	10   11   12   13   14   15
+|	Reserved (should be zero)	|			Module ID			|
+
+ 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
+|							Error Type								|
+******************************************************************************/
+
+#define ERROR_CODE(_err)			((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
+
+#define GET_ERROR_TYPE(_errcode)	((_errcode) & 0x0000FFFF)
+								/**< Extract module code from error code (#uint32_t) */
+
+#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
+								/**< Extract error type (#e_ErrorType) from
+								error code (#uint32_t) */
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+		return ERROR_CODE(_err)
+
+/**************************************************************************//**
+ @Description	Error Type Enumeration
+*//***************************************************************************/
+typedef enum e_ErrorType	/*   Comments / Associated Message Strings					*/
+{						/* ------------------------------------------------------------ */
+	E_OK = 0				/*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"	*/
+	,E_WRITE_FAILED = EIO   /**< Write access failed on memory/device.					*/
+							/*   String: none, or device name.							*/
+	,E_NO_DEVICE = ENXIO	/**< The associated device is not initialized.				*/
+							/*   String: none.								*/
+	,E_NOT_AVAILABLE = EAGAIN
+							/**< Resource is unavailable.								*/
+							/*   String: none, unless the operation is not the main goal
+								of the function (in this case add resource description).   */
+	,E_NO_MEMORY = ENOMEM   /**< External memory allocation failed.						*/
+							/*   String: description of item for which allocation failed.   */
+	,E_INVALID_ADDRESS = EFAULT
+							/**< Invalid address.								*/
+							/*   String: description of the specific violation.			*/
+	,E_BUSY = EBUSY		/**< Resource or module is busy.								*/
+							/*   String: none, unless the operation is not the main goal
+								of the function (in this case add resource description).   */
+	,E_ALREADY_EXISTS = EEXIST
+							/**< Requested resource or item already exists.				*/
+							/*   Use when resource duplication or sharing are not allowed.
+								String: none, unless the operation is not the main goal
+								of the function (in this case add item description).	*/
+	,E_INVALID_OPERATION = ENODEV
+							/**< The operation/command is invalid (unrecognized).		*/
+							/*   String: none.								*/
+	,E_INVALID_VALUE = EDOM /**< Invalid value.								*/
+							/*   Use for non-enumeration parameters, and
+								only when other error types are not suitable.
+								String: parameter description + "(should be <attribute>)",
+								e.g: "Maximum Rx buffer length (should be divisible by 8)",
+								"Channel number (should be even)".					*/
+	,E_NOT_IN_RANGE = ERANGE/**< Parameter value is out of range.						*/
+							/*   Don't use this error for enumeration parameters.
+								String: parameter description + "(should be %d-%d)",
+								e.g: "Number of pad characters (should be 0-15)".		*/
+	,E_NOT_SUPPORTED = ENOSYS
+							/**< The function is not supported or not implemented.		*/
+							/*   String: none.								*/
+	,E_INVALID_STATE		/**< The operation is not allowed in current module state.	*/
+							/*   String: none.								*/
+	,E_INVALID_HANDLE	/**< Invalid handle of module or object.						*/
+							/*   String: none, unless the function takes in more than one
+								handle (in this case add the handle description)		*/
+	,E_INVALID_ID		/**< Invalid module ID (usually enumeration or index).		*/
+							/*   String: none, unless the function takes in more than one
+								ID (in this case add the ID description)				*/
+	,E_NULL_POINTER		/**< Unexpected NULL pointer.								*/
+							/*   String: pointer description.							*/
+	,E_INVALID_SELECTION	/**< Invalid selection or mode.								*/
+							/*   Use for enumeration values, only when other error types
+								are not suitable.
+								String: parameter description.							*/
+	,E_INVALID_COMM_MODE	/**< Invalid communication mode.								*/
+							/*   String: none, unless the function takes in more than one
+								communication mode indications (in this case add
+								parameter description).								*/
+	,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.								*/
+							/*   String: none, unless the function takes in more than one
+								memory types (in this case add memory description,
+								e.g: "Data memory", "Buffer descriptors memory").		*/
+	,E_INVALID_CLOCK		/**< Invalid clock.								*/
+							/*   String: none, unless the function takes in more than one
+								clocks (in this case add clock description,
+								e.g: "Rx clock", "Tx clock").							*/
+	,E_CONFLICT			/**< Some setting conflicts with another setting.			*/
+							/*   String: description of the conflicting settings.		*/
+	,E_NOT_ALIGNED		/**< Non-aligned address.								*/
+							/*   String: parameter description + "(should be %d-bytes aligned)",
+								e.g: "Rx data buffer (should be 32-bytes aligned)".		*/
+	,E_NOT_FOUND			/**< Requested resource or item was not found.				*/
+							/*   Use only when the resource/item is uniquely identified.
+								String: none, unless the operation is not the main goal
+								of the function (in this case add item description).	*/
+	,E_FULL				/**< Resource is full.								*/
+							/*   String: none, unless the operation is not the main goal
+								of the function (in this case add resource description).   */
+	,E_EMPTY				/**< Resource is empty.								*/
+							/*   String: none, unless the operation is not the main goal
+								of the function (in this case add resource description).   */
+	,E_ALREADY_FREE		/**< Specified resource or item is already free or deleted.	*/
+							/*   String: none, unless the operation is not the main goal
+								of the function (in this case add item description).	*/
+	,E_READ_FAILED		/**< Read access failed on memory/device.					*/
+							/*   String: none, or device name.							*/
+	,E_INVALID_FRAME		/**< Invalid frame object (NULL handle or missing buffers).	*/
+							/*   String: none.								*/
+	,E_SEND_FAILED		/**< Send operation failed on device.						*/
+							/*   String: none, or device name.							*/
+	,E_RECEIVE_FAILED	/**< Receive operation failed on device.						*/
+							/*   String: none, or device name.							*/
+	,E_TIMEOUT/* = ETIMEDOUT*/  /**< The operation timed out.								*/
+							/*   String: none.								*/
+
+	,E_DUMMY_LAST		/* NEVER USED */
+
+} e_ErrorType;
+
+/**************************************************************************//**
+
+ @Group		FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group		FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+				The FM uses a general module called "port" to represent a Tx port
+				(MAC), an Rx port (MAC) or Offline Parsing port.
+				The number of ports in an FM varies between SOCs.
+				The SW driver manages these ports as sub-modules of the FM, i.e.
+				after an FM is initialized, its ports may be initialized and
+				operated upon.
+
+				The port is initialized aware of its type, but other functions on
+				a port may be indifferent to its type. When necessary, the driver
+				verifies coherence and returns error if applicable.
+
+				On initialization, user specifies the port type and it's index
+				(relative to the port's type) - always starting at 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+				This enum defines the superset of PCD engines support - i.e. not
+				all engines have to be used, but all have to be enabled. The real
+				flow of a specific frame depends on the PCD configuration and the
+				frame headers and payload.
+				Note: the first engine and the first engine after the parser (if
+				exists) should be in order, the order is important as it will
+				define the flow of the port. However, as for the rest engines
+				(the ones that follows), the order is not important anymore as
+				it is defined by the PCD graph itself.
+*//***************************************************************************/
+typedef enum e_FmPortPcdSupport {
+	e_FM_PORT_PCD_SUPPORT_NONE = 0				/**< BMI to BMI, PCD is not used */
+	, e_FM_PORT_PCD_SUPPORT_PRS_ONLY				/**< Use only Parser */
+	, e_FM_PORT_PCD_SUPPORT_PLCR_ONLY			/**< Use only Policer */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR			/**< Use Parser and Policer */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_KG			/**< Use Parser and Keygen */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC	/**< Use Parser, Keygen and Coarse Classification */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+										/**< Use all PCD engines */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR	/**< Use Parser, Keygen and Policer */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_CC			/**< Use Parser and Coarse Classification */
+	, e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR	/**< Use Parser and Coarse Classification and Policer */
+	, e_FM_PORT_PCD_SUPPORT_CC_ONLY				/**< Use only Coarse Classification */
+#ifdef FM_CAPWAP_SUPPORT
+	, e_FM_PORT_PCD_SUPPORT_CC_AND_KG			/**< Use Coarse Classification,and Keygen */
+	, e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR	/**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPortPcdSupport;
+
+/**************************************************************************//**
+ @Description   Port interrupts
+*//***************************************************************************/
+typedef enum e_FmPortExceptions {
+	e_FM_PORT_EXCEPTION_IM_BUSY				/**< Independent-Mode Rx-BUSY */
+} e_FmPortExceptions;
+
+
+/**************************************************************************//**
+ @Collection	General FM Port defines
+*//***************************************************************************/
+#define FM_PORT_PRS_RESULT_NUM_OF_WORDS	8   /**< Number of 4 bytes words in parser result */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t	fmPortFrameErrSelect_t;						/**< typedef for defining Frame Descriptor errors */
+
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT	FM_FD_ERR_UNSUPPORTED_FORMAT	/**< Not for Rx-Port! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH				FM_FD_ERR_LENGTH				/**< Not for Rx-Port! Length Error */
+#define FM_PORT_FRM_ERR_DMA					FM_FD_ERR_DMA				/**< DMA Data error */
+#define FM_PORT_FRM_ERR_NON_FM				FM_FD_RX_STATUS_ERR_NON_FM	/**< non Frame-Manager error; probably come from SEC that
+												was chained to FM */
+
+#define FM_PORT_FRM_ERR_IPRE					(FM_FD_ERR_IPR & ~FM_FD_IPR)		/**< IPR error */
+#define FM_PORT_FRM_ERR_IPR_NCSP				(FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
+
+#define FM_PORT_FRM_ERR_IPFE					0								/**< Obsolete; will be removed in the future */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_PORT_FRM_ERR_CRE					FM_FD_ERR_CRE
+#define FM_PORT_FRM_ERR_CHE					FM_FD_ERR_CHE
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_PORT_FRM_ERR_PHYSICAL				FM_FD_ERR_PHYSICAL			/**< Rx FIFO overflow, FCS error, code error, running disparity
+												error (SGMII and TBI modes), FIFO parity error. PHY
+												Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE					FM_FD_ERR_SIZE				/**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD			FM_FD_ERR_CLS_DISCARD		/**< indicates a classifier "drop" operation */
+#define FM_PORT_FRM_ERR_EXTRACTION			FM_FD_ERR_EXTRACTION			/**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME			FM_FD_ERR_NO_SCHEME			/**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW	FM_FD_ERR_KEYSIZE_OVERFLOW	/**< Keysize Overflow */
+#define FM_PORT_FRM_ERR_COLOR_RED			FM_FD_ERR_COLOR_RED			/**< Frame color is red */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW			FM_FD_ERR_COLOR_YELLOW		/**< Frame color is yellow */
+#define FM_PORT_FRM_ERR_ILL_PLCR				FM_FD_ERR_ILL_PLCR			/**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN		FM_FD_ERR_PLCR_FRAME_LEN		/**< Policer frame length error */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT			FM_FD_ERR_PRS_TIMEOUT		/**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT	FM_FD_ERR_PRS_ILL_INSTRUCT	/**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR			FM_FD_ERR_PRS_HDR_ERR		/**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED	FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT		0x00000001					/**< FPM Frame Processing Timeout Exceeded */
+/* @} */
+
+
+
+/**************************************************************************//**
+ @Group		FM_PORT_init_grp FM Port Initialization Unit
+
+ @Description   FM Port Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+				exception passing the exception identification.
+
+ @Param[in]	h_App	- User's application descriptor.
+ @Param[in]	exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPortExceptionCallback) (t_Handle h_App, e_FmPortExceptions exception);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with received data.
+
+				User provides this function. Driver invokes it.
+
+ @Param[in]	h_App		Application's handle originally specified to
+								the API Config function
+ @Param[in]	p_Data		A pointer to data received
+ @Param[in]	length		length of received data
+ @Param[in]	status		receive status and errors
+ @Param[in]	position	position of buffer in frame
+ @Param[in]	h_BufContext	A handle of the user acossiated with this buffer
+
+ @Retval	e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+								operation for all ready data.
+ @Retval	e_RX_STORE_RESPONSE_PAUSE	- order the driver to stop Rx operation.
+*//***************************************************************************/
+typedef e_RxStoreResponse (t_FmPortImRxStoreCallback) (t_Handle h_App,
+										uint8_t  *p_Data,
+										uint16_t length,
+										uint16_t status,
+										uint8_t  position,
+										t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+				User provides this function. Driver invokes it.
+
+ @Param[in]	h_App		Application's handle originally specified to
+								the API Config function
+ @Param[in]	p_Data		A pointer to data received
+ @Param[in]	status		transmit status and errors
+ @Param[in]	lastBuffer	is last buffer in frame
+ @Param[in]	h_BufContext	A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
+								uint8_t	*p_Data,
+								uint16_t   status,
+								t_Handle   h_BufContext);
+
+/**************************************************************************//**
+ @Description   A structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortRxParams {
+	uint32_t				errFqid;			/**< Error Queue Id. */
+	uint32_t				dfltFqid;		/**< Default Queue Id.  */
+	uint16_t				liodnOffset;		/**< Port's LIODN offset. */
+	t_FmExtPools			extBufPools;		/**< Which external buffer pools are used
+										(up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
+} t_FmPortRxParams;
+
+/**************************************************************************//**
+ @Description   A structure for additional non-Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortNonRxParams {
+	uint32_t				errFqid;			/**< Error Queue Id. */
+	uint32_t				dfltFqid;		/**< For Tx - Default Confirmation queue,
+										0 means no Tx confirmation for processed
+										frames. For OP port - default Rx queue. */
+	uint32_t				qmChannel;		/**< QM-channel dedicated to this port; will be used
+										by the FM for dequeue. */
+} t_FmPortNonRxParams;
+
+/**************************************************************************//**
+ @Description   A structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortImRxTxParams {
+	t_Handle					h_FmMuram;		/**< A handle of the FM-MURAM partition */
+	uint16_t					liodnOffset;		/**< For Rx ports only. Port's LIODN Offset. */
+	uint8_t					dataMemId;		/**< Memory partition ID for data buffers */
+	uint32_t					dataMemAttributes;  /**< Memory attributes for data buffers */
+	t_BufferPoolInfo			rxPoolParams;	/**< For Rx ports only. */
+	t_FmPortImRxStoreCallback   *f_RxStore;		/**< For Rx ports only. */
+	t_FmPortImTxConfCallback	*f_TxConf;		/**< For Tx ports only. */
+} t_FmPortImRxTxParams;
+
+/**************************************************************************//**
+ @Description   A union for additional parameters depending on port type
+*//***************************************************************************/
+typedef union u_FmPortSpecificParams {
+	t_FmPortImRxTxParams	imRxTxParams;	/**< Rx/Tx Independent-Mode port parameter structure */
+	t_FmPortRxParams			rxParams;		/**< Rx port parameters structure */
+	t_FmPortNonRxParams		nonRxParams;		/**< Non-Rx port parameters structure */
+} u_FmPortSpecificParams;
+
+/**************************************************************************//**
+ @Description   A structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmPortParams {
+	uintptr_t		baseAddr;		/**< Virtual Address of memory mapped FM Port registers.*/
+	t_Handle		h_Fm;			/**< A handle to the FM object this port related to */
+	e_FmPortType		portType;		/**< Port type */
+	uint8_t			portId;			/**< Port Id - relative to type;
+								NOTE: When configuring Offline Parsing port for
+								FMANv3 devices (DPAA_VERSION 11 and higher),
+								it is highly recommended NOT to use portId=0 due to lack
+								of HW resources on portId=0. */
+	bool			independentModeEnable;
+									/**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+	uint16_t					liodnBase;		/**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
+								used together with LIODN offset. */
+	u_FmPortSpecificParams	specificParams;	/**< Additional parameters depending on port
+								type. */
+
+	t_FmPortExceptionCallback   *f_Exception;	/**< Relevant for IM only Callback routine to be called on BUSY exception */
+	t_Handle					h_App;			/**< A handle to an application layer object; This handle will
+								be passed by the driver upon calling the above callbacks */
+} t_FmPortParams;
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_Config
+
+ @Description   Creates a descriptor for the FM PORT module.
+
+				The routine returns a handle (descriptor) to the FM PORT object.
+				This descriptor must be passed as first parameter to all other
+				FM PORT function calls.
+
+				No actual initialization or configuration of FM hardware is
+				done by this routine.
+
+ @Param[in]	p_FmPortParams   - Pointer to data structure of parameters
+
+ @Retval	Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
+
+/**************************************************************************//**
+ @Function	FM_PORT_Init
+
+ @Description   Initializes the FM PORT module by defining the software structure
+				and configuring the hardware registers.
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PORT_Init(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM PORT module.
+
+				Calling this routine invalidates the descriptor.
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PORT_Free(t_Handle h_FmPort);
+
+t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams);
+void FM_PORT_Close(t_Handle h_FmPort);
+
+
+
+/**************************************************************************//**
+ @Group		FM_PORT_advanced_init_grp	FM Port Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqType {
+   e_FM_PORT_DEQ_TYPE1,			/**< Dequeue from the SP channel - with priority precedence,
+								and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE2,			/**< Dequeue from the SP channel - with active FQ precedence,
+								and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE3			/**< Dequeue from the SP channel - with active FQ precedence,
+								and override Intra-Class Scheduling */
+} e_FmPortDeqType;
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqPrefetchOption {
+   e_FM_PORT_DEQ_NO_PREFETCH,	/**< QMI preforms a dequeue action for a single frame
+								only when a dedicated portID Tnum is waiting. */
+   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
+								one dedicated portId tnum is waiting. */
+   e_FM_PORT_DEQ_FULL_PREFETCH	/**< QMI preforms a dequeue action for 3 frames when
+								no dedicated portId tnums are waiting. */
+
+} e_FmPortDeqPrefetchOption;
+
+/**************************************************************************//**
+ @Description   enum for defining port default color
+*//***************************************************************************/
+typedef enum e_FmPortColor {
+	e_FM_PORT_COLOR_GREEN,		/**< Default port color is green */
+	e_FM_PORT_COLOR_YELLOW,		/**< Default port color is yellow */
+	e_FM_PORT_COLOR_RED,			/**< Default port color is red */
+	e_FM_PORT_COLOR_OVERRIDE		/**< Ignore color */
+} e_FmPortColor;
+
+/**************************************************************************//**
+ @Description   A structure for defining Dual Tx rate limiting scale
+*//***************************************************************************/
+typedef enum e_FmPortDualRateLimiterScaleDown {
+	e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,		/**< Use only single rate limiter  */
+	e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,	/**< Divide high rate limiter by 2 */
+	e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,	/**< Divide high rate limiter by 4 */
+	e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8	/**< Divide high rate limiter by 8 */
+} e_FmPortDualRateLimiterScaleDown;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining FM port resources
+*//***************************************************************************/
+typedef struct t_FmPortRsrc {
+	uint32_t	num;				/**< Committed required resource */
+	uint32_t	extra;			/**< Extra (not committed) required resource */
+} t_FmPortRsrc;
+
+/**************************************************************************//**
+ @Description   A structure for defining observed pool depletion
+*//***************************************************************************/
+typedef struct t_FmPortObservedBufPoolDepletion {
+	t_FmBufPoolDepletion	poolDepletionParams;/**< parameters to define pool depletion */
+	t_FmExtPools			poolsParams;		/**< Which external buffer pools are observed
+										(up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
+										and their sizes. */
+} t_FmPortObservedBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct t_FmPortRateLimit {
+	uint16_t							maxBurstSize;		/**< in KBytes for Tx ports, in frames
+								for OP ports. (note that
+								for early chips burst size is
+								rounded up to a multiply of 1000 frames).*/
+	uint32_t							rateLimit;			/**< in Kb/sec for Tx ports, in frame/sec for
+								OP ports. Rate limit refers to
+								data rate (rather than line rate). */
+	e_FmPortDualRateLimiterScaleDown	rateLimitDivider;	/**< For OP ports only. Not-valid
+								for some earlier chip revisions */
+} t_FmPortRateLimit;
+
+/**************************************************************************//**
+ @Description   A structure for defining the parameters of
+				the Rx port performance counters
+*//***************************************************************************/
+typedef struct t_FmPortPerformanceCnt {
+	uint8_t	taskCompVal;			/**< Task compare value */
+	uint8_t	queueCompVal;		/**< Rx queue/Tx confirm queue compare
+								value (unused for H/O) */
+	uint8_t	dmaCompVal;			/**< Dma compare value */
+	uint32_t	fifoCompVal;			/**< Fifo compare value (in bytes) */
+} t_FmPortPerformanceCnt;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining the sizes of the Deep Sleep
+				the Auto Response tables
+*//***************************************************************************/
+typedef struct t_FmPortDsarTablesSizes
+{
+	uint16_t   maxNumOfArpEntries;
+	uint16_t   maxNumOfEchoIpv4Entries;
+	uint16_t   maxNumOfNdpEntries;
+	uint16_t   maxNumOfEchoIpv6Entries;
+	uint16_t   maxNumOfSnmpIPV4Entries;
+	uint16_t   maxNumOfSnmpIPV6Entries;
+	uint16_t   maxNumOfSnmpOidEntries;
+	uint16_t   maxNumOfSnmpOidChar; /* total amount of character needed for the snmp table */
+
+	uint16_t   maxNumOfIpProtFiltering;
+	uint16_t   maxNumOfTcpPortFiltering;
+	uint16_t   maxNumOfUdpPortFiltering;
+} t_FmPortDsarTablesSizes;
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDsarSupport
+
+ @Description   This function will allocate the amount of MURAM needed for
+				this max number of entries for Deep Sleep Auto Response.
+				it will calculate all needed MURAM for autoresponse including
+				necesary common stuff.
+
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	params	A pointer to a structure containing the maximum
+							sizes of the auto response tables
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx, t_FmPortDsarTablesSizes *params);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigNumOfOpenDmas
+
+ @Description   Calling this routine changes the max number of open DMA's
+				available for this port. It changes this parameter in the
+				internal driver data base from its default configuration
+				[OP: 1]
+				[1G-RX, 1G-TX: 1 (+1)]
+				[10G-RX, 10G-TX: 8 (+8)]
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_OpenDmas  A pointer to a structure of parameters defining
+							the open DMA allocation.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigNumOfTasks
+
+ @Description   Calling this routine changes the max number of tasks
+				available for this port. It changes this parameter in the
+				internal driver data base from its default configuration
+				[OP: 1]
+				[1G-RX, 1G-TX: 3 (+2)]
+				[10G-RX, 10G-TX: 16 (+8)]
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_NumOfTasks	A pointer to a structure of parameters defining
+								the tasks allocation.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigSizeOfFifo
+
+ @Description   Calling this routine changes the max FIFO size configured for this port.
+
+				This function changes the internal driver data base from its
+				default configuration. Please refer to the driver's User Guide for
+				information on default FIFO sizes in the various devices.
+				[OP: 2KB]
+				[1G-RX, 1G-TX: 11KB]
+				[10G-RX, 10G-TX: 12KB]
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_SizeOfFifo	A pointer to a structure of parameters defining
+								the FIFO allocation.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDeqHighPriority
+
+ @Description   Calling this routine changes the dequeue priority in the
+				internal driver data base from its default configuration
+				1G: [DEFAULT_PORT_deqHighPriority_1G]
+				10G: [DEFAULT_PORT_deqHighPriority_10G]
+
+				May be used for Non-Rx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	highPri	TRUE to select high priority, FALSE for normal operation.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDeqType
+
+ @Description   Calling this routine changes the dequeue type parameter in the
+				internal driver data base from its default configuration
+				[DEFAULT_PORT_deqType].
+
+				May be used for Non-Rx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	deqType	According to QM definition.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDeqPrefetchOption
+
+ @Description   Calling this routine changes the dequeue prefetch option parameter in the
+				internal driver data base from its default configuration
+				[DEFAULT_PORT_deqPrefetchOption]
+				Note: Available for some chips only
+
+				May be used for Non-Rx ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	deqPrefetchOption   New option
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDeqByteCnt
+
+ @Description   Calling this routine changes the dequeue byte count parameter in
+				the internal driver data base from its default configuration
+				1G:[DEFAULT_PORT_deqByteCnt_1G].
+				10G:[DEFAULT_PORT_deqByteCnt_10G].
+
+				May be used for Non-Rx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	deqByteCnt	New byte count
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+				The prefix will
+				In Tx ports, if 'passPrsResult', the application
+				should set a value to their offsets in the prefix of
+				the FM will save the first 'privDataSize', than,
+				depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+				and timeStamp, and the packet itself (in this order), to the
+				application buffer, and to offset.
+				Calling this routine changes the buffer margins definitions
+				in the internal driver data base from its default
+				configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+							Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+							Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
+
+				May be used for all ports
+
+ @Param[in]	h_FmPort						A handle to a FM Port module.
+ @Param[in,out] p_FmBufferPrefixContent		A structure of parameters describing the
+									structure of the buffer.
+									Out parameter: Start margin - offset
+									of data from start of external buffer.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigBufferPrefixContent(t_Handle					h_FmPort,
+								t_FmBufferPrefixContent	*p_FmBufferPrefixContent);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigCheksumLastBytesIgnore
+
+ @Description   Calling this routine changes the number of checksum bytes to ignore
+				parameter in the internal driver data base from its default configuration
+				[DEFAULT_PORT_cheksumLastBytesIgnore]
+
+				May be used by Tx & Rx ports only
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	cheksumLastBytesIgnore  New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigCutBytesFromEnd
+
+ @Description   Calling this routine changes the number of bytes to cut from a
+				frame's end parameter in the internal driver data base
+				from its default configuration [DEFAULT_PORT_cutBytesFromEnd]
+				Note that if the result of (frame length before chop - cutBytesFromEnd) is
+				less than 14 bytes, the chop operation is not executed.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	cutBytesFromEnd	New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+				depletion status of BM pools. It also defines the conditions to activate
+				this functionality. By default, this functionality is disabled.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	p_BufPoolDepletion	A structure of pool depletion parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigObservedPoolDepletion
+
+ @Description   Calling this routine enables a mechanism to stop port enqueue
+				depending on the depletion status of selected BM pools.
+				It also defines the conditions to activate
+				this functionality. By default, this functionality is disabled.
+
+				Note: Available for some chips only
+
+				May be used for OP ports only
+
+ @Param[in]	h_FmPort							A handle to a FM Port module.
+ @Param[in]	p_FmPortObservedBufPoolDepletion	A structure of parameters for pool depletion.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigObservedPoolDepletion(t_Handle							h_FmPort,
+								t_FmPortObservedBufPoolDepletion	*p_FmPortObservedBufPoolDepletion);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigExtBufPools
+
+ @Description   This routine should be called for OP ports
+				that internally use BM buffer pools. In such cases, e.g. for fragmentation and
+				re-assembly, the FM needs new BM buffers. By calling this routine the user
+				specifies the BM buffer pools that should be used.
+
+				Note: Available for some chips only
+
+				May be used for OP ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	p_FmExtPools	A structure of parameters for the external pools.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+				defined for this port as backup pools.
+				A pool configured to be a backup pool will be used only if all other
+				enabled non-backup pools are depleted.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	p_FmPortBackupBmPools   An array of pool id's. All pools specified here will
+								be defined as backup pools.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPortBackupBmPools);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigFrmDiscardOverride
+
+ @Description   Calling this routine changes the error frames destination parameter
+				in the internal driver data base from its default configuration:
+				override = [DEFAULT_PORT_frmDiscardOverride]
+
+				May be used for Rx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	override	TRUE to override discarding of error frames and
+							enqueueing them to error queue.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigErrorsToDiscard
+
+ @Description   Calling this routine changes the behaviour on error parameter
+				in the internal driver data base from its default configuration:
+				[DEFAULT_PORT_errorsToDiscard].
+				If a requested error was previously defined as "ErrorsToEnqueue" it's
+				definition will change and the frame will be discarded.
+				Errors that were not defined either as "ErrorsToEnqueue" nor as
+				"ErrorsToDiscard", will be forwarded to CPU.
+
+				May be used for Rx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	errs	A list of errors to discard
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data aparameter
+				in the internal driver data base from its default
+				configuration  [DEFAULT_PORT_dmaSwapData]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	swapData	New selection
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+				attribute parameter in the internal driver data base
+				from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	intContextCacheAttr	New selection
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+				attribute parameter in the internal driver data base
+				from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort					A handle to a FM Port module.
+ @Param[in]	headerCacheAttr			New selection
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+				attribute parameter in the internal driver data base
+				from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort					A handle to a FM Port module.
+ @Param[in]	scatterGatherCacheAttr	New selection
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+				parameter in the internal driver data base
+				from its default configuration:  By default optimize = [DEFAULT_PORT_dmaWriteOptimize].
+				Note:
+
+				1. For head optimization, data alignment must be >= 16 (supported by default).
+
+				3. For tail optimization, note that the optimization is performed by extending the write transaction
+				of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
+				is extended to be on 16/64 bytes aligned block (chip dependent).
+
+				Relevant for non-Tx port types
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	optimize	TRUE to enable optimization, FALSE for normal operation
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigNoScatherGather
+
+ @Description	Calling this routine changes the noScatherGather parameter in internal driver data base
+				from its default configuration.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	noScatherGather (TRUE - frame is discarded if can not be stored in single buffer,
+								FALSE - frame can be stored in scatter gather (S/G) format).
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDfltColor
+
+ @Description   Calling this routine changes the internal default color parameter
+				in the internal driver data base
+				from its default configuration  [DEFAULT_PORT_color]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	color		New selection
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigSyncReq
+
+ @Description   Calling this routine changes the synchronization attribute parameter
+				in the internal driver data base from its default configuration:
+				syncReq = [DEFAULT_PORT_syncReq]
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	syncReq		TRUE to request synchronization, FALSE otherwize.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigForwardReuseIntContext
+
+ @Description   This routine is relevant for Rx ports that are routed to OP port.
+				It changes the internal context reuse option in the internal
+				driver data base from its default configuration:
+				reuse = [DEFAULT_PORT_forwardIntContextReuse]
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	reuse		TRUE to reuse internal context on frames
+								forwarded to OP port.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigDontReleaseTxBufToBM
+
+ @Description   This routine should be called if no Tx confirmation
+				is done, and yet buffers should not be released to the BM.
+				Normally, buffers are returned using the Tx confirmation
+				process. When Tx confirmation is not used (defFqid=0),
+				buffers are typically released to the BM. This routine
+				may be called to avoid this behavior and not release the
+				buffers.
+
+				May be used for Tx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigIMMaxRxBufLength
+
+ @Description   Changes the maximum receive buffer length from its default
+				configuration: Closest rounded down power of 2 value of the
+				data buffer size.
+
+				The maximum receive buffer length directly affects the structure
+				of received frames (single- or multi-buffered) and the performance
+				of both the FM and the driver.
+
+				The selection between single- or multi-buffered frames should be
+				done according to the characteristics of the specific application.
+				The recommended mode is to use a single data buffer per packet,
+				as this mode provides the best performance. However, the user can
+				select to use multiple data buffers per packet.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	newVal		Maximum receive buffer length (in bytes).
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigIMRxBdRingLength
+
+ @Description   Changes the receive BD ring length from its default
+				configuration:[DEFAULT_PORT_rxBdRingLength]
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	newVal		The desired BD ring length.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigIMTxBdRingLength
+
+ @Description   Changes the transmit BD ring length from its default
+				configuration:[DEFAULT_PORT_txBdRingLength]
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	newVal		The desired BD ring length.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigIMFmanCtrlExternalStructsMemory
+
+ @Description   Configures memory partition and attributes for FMan-Controller
+				data structures (e.g. BD rings).
+				Calling this routine changes the internal driver data base
+				from its default configuration
+				[DEFAULT_PORT_ImfwExtStructsMemId, DEFAULT_PORT_ImfwExtStructsMemAttr].
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	memId		Memory partition ID.
+ @Param[in]	memAttributes   Memory attributes mask (a combination of MEMORY_ATTR_x flags).
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
+										uint8_t  memId,
+										uint32_t memAttributes);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigIMPolling
+
+ @Description   Changes the Rx flow from interrupt driven (default) to polling.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ConfigMaxFrameLength
+
+ @Description   Changes the definition of the max size of frame that should be
+				transmitted/received on this port from its default value [DEFAULT_PORT_maxFrameLength].
+				This parameter is used for confirmation of the minimum Fifo
+				size calculations and only for Tx ports or ports working in
+				independent mode. This should be larger than the maximum possible
+				MTU that will be used for this port (i.e. its MAC).
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	length		Max size of frame
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+				This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
+
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+				fill level parameter in the internal driver data base
+				from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
+
+				May be used for Tx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	minFillLevel	New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+				pipeline depth parameter in the internal driver data base
+
+				from its default configuration: 1G ports: [DEFAULT_PORT_fifoDeqPipelineDepth_1G],
+				10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G],
+				OP port: [DEFAULT_PORT_fifoDeqPipelineDepth_OH]
+
+				May be used for Tx/OP ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	deqPipelineDepth	New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+				parameter in internal driver data base
+				from its default configuration [DEFAULT_PORT_txFifoLowComfLevel]
+
+				May be used for Tx ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	fifoLowComfLevel	New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+				fill level parameter in the internal driver data base
+				from its default configuration [DEFAULT_PORT_rxFifoThreshold]
+
+				If the total number of buffers which are
+				currently in use and associated with the
+				specific RX port exceed this threshold, the
+				BMI will signal the MAC to send a pause frame
+				over the link.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	fifoThreshold	New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigRxFifoPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+				parameter in the internal driver data base from its default
+				configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
+
+				If the total number of buffers which are currently in use and
+				associated with the specific RX port exceed the amount specified
+				in priElevationLevel, BMI will signal the main FM's DMA to
+				elevate the FM priority on the system bus.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	priElevationLevel   New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigBCBWorkaround
+
+ @Description   Configures BCB errata workaround.
+
+				When BCB errata is applicable, the workaround is always
+				performed by FM Controller. Thus, this functions doesn't
+				actually enable errata workaround but rather allows driver
+				to perform adjustments required due to errata workaround
+				execution in FM controller.
+
+				Applying BCB workaround also configures FM_PORT_FRM_ERR_PHYSICAL
+				errors to be discarded. Thus FM_PORT_FRM_ERR_PHYSICAL can't be
+				set by FM_PORT_SetErrorsRoute() function.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort);
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//*
+ @Function	FM_PORT_ConfigInternalBuffOffset
+
+ @Description   Configures internal buffer offset.
+
+				May be used for Rx and OP ports only
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	val				New value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ConfigInternalBuffOffset(t_Handle h_FmPort, uint8_t val);
+#endif /* (DPAA_VERSION >= 11) */
+
+/** @} */ /* end of FM_PORT_advanced_init_grp group */
+/** @} */ /* end of FM_PORT_init_grp group */
+
+
+/**************************************************************************//**
+ @Group		FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum e_FmPortCounters {
+	e_FM_PORT_COUNTERS_CYCLE,					/**< BMI performance counter */
+	e_FM_PORT_COUNTERS_TASK_UTIL,				/**< BMI performance counter */
+	e_FM_PORT_COUNTERS_QUEUE_UTIL,				/**< BMI performance counter */
+	e_FM_PORT_COUNTERS_DMA_UTIL,					/**< BMI performance counter */
+	e_FM_PORT_COUNTERS_FIFO_UTIL,				/**< BMI performance counter */
+	e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,		/**< BMI Rx only performance counter */
+	e_FM_PORT_COUNTERS_FRAME,					/**< BMI statistics counter */
+	e_FM_PORT_COUNTERS_DISCARD_FRAME,			/**< BMI statistics counter */
+	e_FM_PORT_COUNTERS_DEALLOC_BUF,				/**< BMI deallocate buffer statistics counter */
+	e_FM_PORT_COUNTERS_RX_BAD_FRAME,				/**< BMI Rx only statistics counter */
+	e_FM_PORT_COUNTERS_RX_LARGE_FRAME,			/**< BMI Rx only statistics counter */
+	e_FM_PORT_COUNTERS_RX_FILTER_FRAME,			/**< BMI Rx & OP only statistics counter */
+	e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,			/**< BMI Rx, OP & HC only statistics counter */
+	e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+	e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
+	e_FM_PORT_COUNTERS_WRED_DISCARD,				/**< BMI OP & HC only statistics counter */
+	e_FM_PORT_COUNTERS_LENGTH_ERR,				/**< BMI non-Rx statistics counter */
+	e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,		/**< BMI non-Rx statistics counter */
+	e_FM_PORT_COUNTERS_DEQ_TOTAL,				/**< QMI total QM dequeues counter */
+	e_FM_PORT_COUNTERS_ENQ_TOTAL,				/**< QMI total QM enqueues counter */
+	e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,			/**< QMI counter */
+	e_FM_PORT_COUNTERS_DEQ_CONFIRM				/**< QMI counter */
+} e_FmPortCounters;
+
+typedef struct t_FmPortBmiStats {
+	uint32_t cntCycle;
+	uint32_t cntTaskUtil;
+	uint32_t cntQueueUtil;
+	uint32_t cntDmaUtil;
+	uint32_t cntFifoUtil;
+	uint32_t cntRxPauseActivation;
+	uint32_t cntFrame;
+	uint32_t cntDiscardFrame;
+	uint32_t cntDeallocBuf;
+	uint32_t cntRxBadFrame;
+	uint32_t cntRxLargeFrame;
+	uint32_t cntRxFilterFrame;
+	uint32_t cntRxListDmaErr;
+	uint32_t cntRxOutOfBuffersDiscard;
+	uint32_t cntWredDiscard;
+	uint32_t cntLengthErr;
+	uint32_t cntUnsupportedFormat;
+} t_FmPortBmiStats;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+				Fields commented 'IN' are passed by the port module to be used
+				by the FM module.
+				Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct t_FmPortCongestionGrps {
+	uint16_t	numOfCongestionGrpsToConsider;		/**< The number of required CGs
+								to define the size of the following array */
+	uint8_t	congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
+								/**< An array of CG indexes;
+								Note that the size of the array should be
+								'numOfCongestionGrpsToConsider'. */
+#if (DPAA_VERSION >= 11)
+	bool	pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+								/**< a matrix that represents the map between the CG ids
+								defined in 'congestionGrpsToConsider' to the priorties
+								mapping array. */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPortCongestionGrps;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ARP Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarArpEntry
+{
+	uint32_t  ipAddress;
+	uint8_t   mac[6];
+	bool	isVlan;
+	uint16_t  vid;
+} t_FmPortDsarArpEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ARP info
+*//***************************************************************************/
+typedef struct t_FmPortDsarArpInfo
+{
+	uint8_t		tableSize;
+	t_FmPortDsarArpEntry *p_AutoResTable;
+	bool			enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
+} t_FmPortDsarArpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response NDP Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarNdpEntry
+{
+	uint32_t  ipAddress[4];
+	uint8_t   mac[6];
+	bool	isVlan;
+	uint16_t  vid;
+} t_FmPortDsarNdpEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response NDP info
+*//***************************************************************************/
+typedef struct t_FmPortDsarNdpInfo
+{
+	uint32_t			multicastGroup;
+
+	uint8_t			tableSizeAssigned;
+	t_FmPortDsarNdpEntry  *p_AutoResTableAssigned; /* This list refer to solicitation IP addresses.
+								Note that all IP adresses must be from the same multicast group.
+								This will be checked and if not operation will fail. */
+	uint8_t			tableSizeTmp;
+	t_FmPortDsarNdpEntry  *p_AutoResTableTmp;	/* This list refer to temp IP addresses.
+								Note that all temp IP adresses must be from the same multicast group.
+								This will be checked and if not operation will fail. */
+
+	bool				enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
+
+} t_FmPortDsarNdpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ICMPV4 info
+*//***************************************************************************/
+typedef struct t_FmPortDsarEchoIpv4Info
+{
+	uint8_t			tableSize;
+	t_FmPortDsarArpEntry  *p_AutoResTable;
+} t_FmPortDsarEchoIpv4Info;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ICMPV6 info
+*//***************************************************************************/
+typedef struct t_FmPortDsarEchoIpv6Info
+{
+	uint8_t			tableSize;
+	t_FmPortDsarNdpEntry  *p_AutoResTable;
+} t_FmPortDsarEchoIpv6Info;
+
+/**************************************************************************//**
+@Description	Deep Sleep Auto Response SNMP OIDs table entry
+
+*//***************************************************************************/
+typedef struct {
+	uint16_t	oidSize;
+	uint8_t	*oidVal; /* only the oid string */
+	uint16_t	resSize;
+	uint8_t	*resVal; /* resVal will be the entire reply,
+				i.e. "Type|Length|Value" */
+} t_FmPortDsarOidsEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP IPv4 Addresses Table Entry
+				Refer to the FMan Controller spec for more details.
+*//***************************************************************************/
+typedef struct
+{
+	uint32_t ipv4Addr; /*!< 32 bit IPv4 Address. */
+	bool	isVlan;
+	uint16_t vid;   /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared					*/
+					/*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
+} t_FmPortDsarSnmpIpv4AddrTblEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP IPv6 Addresses Table Entry
+				Refer to the FMan Controller spec for more details.
+*//***************************************************************************/
+typedef struct
+{
+	uint32_t ipv6Addr[4];  /*!< 4 * 32 bit IPv6 Address.										*/
+	bool	isVlan;
+	uint16_t vid;	/*!< 12 bits VLAN ID. The 4 left-most bits should be cleared					*/
+						/*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
+} t_FmPortDsarSnmpIpv6AddrTblEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP Descriptor
+
+*//***************************************************************************/
+typedef struct
+{
+	uint16_t control;						/**< Control bits [0-15]. */
+	uint16_t maxSnmpMsgLength;				/**< Maximal allowed SNMP message length. */
+	uint16_t numOfIpv4Addresses;			/**< Number of entries in IPv4 addresses table. */
+	uint16_t numOfIpv6Addresses;			/**< Number of entries in IPv6 addresses table. */
+	t_FmPortDsarSnmpIpv4AddrTblEntry *p_Ipv4AddrTbl; /**< Pointer to IPv4 addresses table. */
+	t_FmPortDsarSnmpIpv6AddrTblEntry *p_Ipv6AddrTbl; /**< Pointer to IPv6 addresses table. */
+	uint8_t *p_RdOnlyCommunityStr;			/**< Pointer to the Read Only Community String. */
+	uint8_t *p_RdWrCommunityStr;			/**< Pointer to the Read Write Community String. */
+	t_FmPortDsarOidsEntry *p_OidsTbl;				/**< Pointer to OIDs table. */
+	uint32_t oidsTblSize;					/**< Number of entries in OIDs table. */
+} t_FmPortDsarSnmpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response filtering Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarFilteringEntry
+{
+	uint16_t	srcPort;
+	uint16_t	dstPort;
+	uint16_t	srcPortMask;
+	uint16_t	dstPortMask;
+} t_FmPortDsarFilteringEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response filtering info
+*//***************************************************************************/
+typedef struct t_FmPortDsarFilteringInfo
+{
+	/* IP protocol filtering parameters */
+	uint8_t	ipProtTableSize;
+	uint8_t	*p_IpProtTablePtr;
+	bool	ipProtPassOnHit;  /* when TRUE, miss in the table will cause the packet to be droped,
+								hit will pass the packet to UDP/TCP filters if needed and if not
+								to the classification tree. If the classification tree will pass
+								the packet to a queue it will cause a wake interupt.
+								When FALSE it the other way around. */
+	/* UDP port filtering parameters */
+	uint8_t	udpPortsTableSize;
+	t_FmPortDsarFilteringEntry *p_UdpPortsTablePtr;
+	bool	udpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+								hit will pass the packet to classification tree.
+								If the classification tree will pass the packet to a queue it
+								will cause a wake interupt.
+								When FALSE it the other way around. */
+	/* TCP port filtering parameters */
+	uint16_t	tcpFlagsMask;
+	uint8_t	tcpPortsTableSize;
+	t_FmPortDsarFilteringEntry *p_TcpPortsTablePtr;
+	bool	tcpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+								hit will pass the packet to classification tree.
+								If the classification tree will pass the packet to a queue it
+								will cause a wake interupt.
+								When FALSE it the other way around. */
+} t_FmPortDsarFilteringInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response parameters
+*//***************************************************************************/
+typedef struct t_FmPortDsarParams
+{
+	t_Handle				h_FmPortTx;
+	t_FmPortDsarArpInfo	*p_AutoResArpInfo;
+	t_FmPortDsarEchoIpv4Info  *p_AutoResEchoIpv4Info;
+	t_FmPortDsarNdpInfo	*p_AutoResNdpInfo;
+	t_FmPortDsarEchoIpv6Info  *p_AutoResEchoIpv6Info;
+	t_FmPortDsarSnmpInfo	*p_AutoResSnmpInfo;
+	t_FmPortDsarFilteringInfo *p_AutoResFilteringInfo;
+} t_FmPortDsarParams;
+
+/**************************************************************************//**
+ @Function	FM_PORT_EnterDsar
+
+ @Description   Enter Deep Sleep Auto Response mode.
+				This function write the apropriate values to in the relevant
+				tables in the MURAM.
+
+ @Param[in]	h_FmPortRx - FM PORT module descriptor
+ @Param[in]	params - Auto Response parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params);
+
+/**************************************************************************//**
+ @Function	FM_PORT_EnterDsarFinal
+
+ @Description   Enter Deep Sleep Auto Response mode.
+				This function sets the Tx port in independent mode as needed
+				and redirect the receive flow to go through the
+				Dsar Fman-ctrl code
+
+ @Param[in]	h_DsarRxPort - FM Rx PORT module descriptor
+ @Param[in]	h_DsarTxPort - FM Tx PORT module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ExitDsar
+
+ @Description   Exit Deep Sleep Auto Response mode.
+				This function reverse the AR mode and put the ports back into
+				their original wake mode
+
+ @Param[in]	h_FmPortRx - FM PORT Rx module descriptor
+ @Param[in]	h_FmPortTx - FM PORT Tx module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_EnterDsar().
+*//***************************************************************************/
+void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx);
+
+/**************************************************************************//**
+ @Function	FM_PORT_IsInDsar
+
+ @Description   This function returns TRUE if the port was set as Auto Response
+				and FALSE if not. Once Exit AR mode it will return FALSE as well
+				until re-enabled once more.
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+bool FM_PORT_IsInDsar(t_Handle h_FmPort);
+
+typedef struct t_FmPortDsarStats
+{
+	uint32_t arpArCnt;
+	uint32_t echoIcmpv4ArCnt;
+	uint32_t ndpArCnt;
+	uint32_t echoIcmpv6ArCnt;
+	uint32_t snmpGetCnt;
+	uint32_t snmpGetNextCnt;
+} t_FmPortDsarStats;
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetDsarStats
+
+ @Description   Return statistics for Deep Sleep Auto Response
+
+ @Param[in]	h_FmPortRx - FM PORT module descriptor
+ @Param[out]	stats - structure containing the statistics counters
+
+ @Return	E_OK on success; Error code otherwise.
+*//***************************************************************************/
+uint32_t FM_PORT_GetDsarStats(t_Handle h_FmPortRx, t_FmPortDsarStats *stats);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function	FM_PORT_DumpRegs
+
+ @Description   Dump all regs.
+
+				Calling this routine invalidates the descriptor.
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_DumpRegs(t_Handle h_FmPort);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBufferDataOffset
+
+ @Description   Relevant for Rx ports.
+				Returns the data offset from the beginning of the data buffer
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+
+ @Return	data offset.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBufferICInfo
+
+ @Description   Returns the Internal Context offset from the beginning of the data buffer
+
+ @Param[in]	h_FmPort - FM PORT module descriptor
+ @Param[in]	p_Data   - A pointer to the data buffer.
+
+ @Return	Internal context info pointer on success, NULL if 'allOtherInfo' was not
+				configured for this port.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+				In Rx ports this is relevant after reception, if parse
+				result is configured to be part of the data passed to the
+				application. For non Rx ports it may be used to get the pointer
+				of the area in the buffer where parse result should be
+				initialized - if so configured.
+				See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+				configuration.
+
+ @Param[in]	h_FmPort	- FM PORT module descriptor
+ @Param[in]	p_Data	- A pointer to the data buffer.
+
+ @Return	Parse result pointer on success, NULL if parse result was not
+				configured for this port.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+				Relevant for Rx ports for getting the buffer time stamp.
+				See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+				configuration.
+
+ @Param[in]	h_FmPort	- FM PORT module descriptor
+ @Param[in]	p_Data	- A pointer to the data buffer.
+
+ @Return	A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+				as a part of the buffer content (see FM_PORT_ConfigBufferPrefixContent)
+				this routine will return the pointer to the hash result location in the
+				buffer prefix.
+
+ @Param[in]	h_FmPort	- FM PORT module descriptor
+ @Param[in]	p_Data	- A pointer to the data buffer.
+
+ @Return	A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function	FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+				tasks associated with the port are terminated.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				This is a blocking routine, it returns after port is
+				gracefully stopped, i.e. the port will not except new frames,
+				but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+uint32_t FM_PORT_Disable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_Enable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+				By default, this functionality is disabled.
+				Note that rate-limit mechanism uses the FM time stamp.
+				The selected rate limit specified here would be
+				rounded DOWN to the nearest 16M.
+
+				May be used for Tx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_RateLimit	A structure of rate limit parameters
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				If rate limit is set on a port that need to send PFC frames,
+				it might violate the stop transmit timing.
+*//***************************************************************************/
+uint32_t FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
+ @Function	FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables and clears rate limit
+				initialization.
+
+				May be used for Tx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_DeleteRateLimit(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetPfcPrioritiesMappingToQmanWQ
+
+ @Description   Calling this routine maps each PFC received priority to the transmit WQ.
+				This WQ will be blocked upon receiving a PFC frame with this priority.
+
+				May be used for Tx ports only.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	prio			PFC priority (0-7).
+ @Param[in]	wq			Work Queue (0-7).
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetStatisticsCounters
+
+ @Description   Calling this routine enables/disables port's statistics counters.
+				By default, counters are enabled.
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	enable	TRUE to enable, FALSE to disable.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetFrameQueueCounters
+
+ @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
+				By default, counters are enabled.
+
+				May be used for all ports
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	enable	TRUE to enable, FALSE to disable.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PORT_AnalyzePerformanceParams
+
+ @Description   User may call this routine to so the driver will analyze if the
+				basic performance parameters are correct and also the driver may
+				suggest of improvements; The basic parameters are FIFO sizes, number
+				of DMAs and number of TNUMs for the port.
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
+
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetAllocBufCounter
+
+ @Description   Calling this routine enables/disables BM pool allocate
+				buffer counters.
+				By default, counters are enabled.
+
+				May be used for Rx ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	poolId	BM pool id.
+ @Param[in]	enable	TRUE to enable, FALSE to disable.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+				a designated structure of counters.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[out]	p_BmiStats  counters structure
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBmiCounters(t_Handle h_FmPort, t_FmPortBmiStats *p_BmiStats);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetCounter
+
+ @Description   Reads one of the FM PORT counters.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	fmPortCounter	The requested counter.
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				Note that it is user's responsibility to call this routine only
+				for enabled counters, and there will be no indication if a
+				disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	fmPortCounter	The requested counter.
+ @Param[in]	value			The requested value to be written into the counter.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetAllocBufCounter
+
+ @Description   Reads one of the FM PORT buffer counters.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	poolId			The requested pool.
+
+ @Return	Counter's current value.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				Note that it is user's responsibility to call this routine only
+				for enabled counters, and there will be no indication if a
+				disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ModifyAllocBufCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	poolId			The requested pool.
+ @Param[in]	value			The requested value to be written into the counter.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+
+/**************************************************************************//**
+ @Function	FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+				It should be called in order to enable pause
+				frame transmission in case of congestion in one or more
+				of the congestion groups relevant to this port.
+				Each call to this routine may add one or more congestion
+				groups to be considered relevant to this port.
+
+				May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	p_CongestionGrps	A pointer to an array of congestion groups
+								id's to consider.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function	FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+				called when congestion groups were
+				defined for this port and are no longer relevant, or pause
+				frames transmitting is not required on their behalf.
+				Each call to this routine may remove one or more congestion
+				groups to be considered relevant to this port.
+
+				May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	p_CongestionGrps	A pointer to an array of congestion groups
+								id's to consider.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function	FM_PORT_IsStalled
+
+ @Description   A routine for checking whether the specified port is stalled.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+
+ @Return	TRUE if port is stalled, FALSE otherwize
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+bool FM_PORT_IsStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ReleaseStalled
+
+ @Description   This routine may be called in case the port was stalled and may
+				now be released.
+				Note that this routine is available only on older FMan revisions
+				(FMan v2, DPAA v1.0 only).
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_ReleaseStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetRxL4ChecksumVerify
+
+ @Description   This routine is relevant for Rx ports (1G and 10G). The routine
+				set/clear the L3/L4 checksum verification (on RX side).
+				Note that this takes affect only if hw-parser is enabled!
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	l4Checksum	boolean indicates whether to do L3/L4 checksum
+								on frames or not.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+				to be enqueued to error queue.
+				Errors not selected for this routine will cause a frame with that error
+				to be enqueued to the one of the other port queues.
+				By default all errors are defined to be enqueued to error queue.
+				Errors that were configured to be discarded (at initialization)
+				may not be selected here.
+
+				May be used for Rx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	errs	A list of errors to enqueue to error queue
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function	FM_PORT_SetIMExceptions
+
+ @Description   Calling this routine enables/disables FM PORT interrupts.
+
+ @Param[in]	h_FmPort	FM PORT module descriptor.
+ @Param[in]	exception	The exception to be selected.
+ @Param[in]	enable		TRUE to enable interrupt, FALSE to mask it.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				This routine should NOT be called from guest-partition
+				(i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+uint32_t FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
+
+/**************************************************************************//*
+ @Function	FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+				By default, counters are enabled.
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	enable				TRUE to enable, FALSE to disable.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//*
+ @Function	FM_PORT_SetPerformanceCountersParams
+
+ @Description   Calling this routine defines port's performance
+				counters parameters.
+
+				May be used for all port types
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	p_FmPortPerformanceCnt  A pointer to a structure of performance
+								counters parameters.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
+
+/**************************************************************************//**
+ @Group		FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @Function	FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+				It changes it from its default configuration which is PCD
+				disabled (BMI to BMI) and configures it according to the passed
+				parameters.
+
+				May be used for Rx and OP ports only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_FmPortPcd	A Structure of parameters defining the port's PCD
+								configuration.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_SetPCD(t_Handle h_FmPort, ioc_fm_port_pcd_params_t *p_FmPortPcd);
+
+/**************************************************************************//**
+ @Function	FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+				The port returns to its default configuration which is PCD
+				disabled (BMI to BMI) and all PCD configuration is removed.
+
+				May be used for Rx and OP ports which are
+				in PCD mode  only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_DeletePCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+				to return to the originally configured PCD support flow.
+				The couple of routines are used to allow PCD configuration changes
+				that demand that PCD will not be used while changes take place.
+
+				May be used for Rx and OP ports which are
+				in PCD mode only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_AttachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+				The port returns to its default flow which is BMI to BMI.
+
+				May be used for Rx and OP ports which are
+				in PCD mode only
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_AttachPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_DetachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+				order to allocate private policer profiles.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	numOfProfiles	The number of required policer profiles
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+				and before FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+				and before FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function	FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+				in VSP mode. Note that the port is initialized by default with the
+				physical-storage-profile only.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_Params	A structure of parameters for allocation VSP's per port
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+				and also before FM_PORT_Enable(); i.e. the port should be disabled.
+*//***************************************************************************/
+uint32_t FM_PORT_VSPAlloc(t_Handle h_FmPort, ioc_fm_port_vsp_alloc_params_t *p_Params);
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+				order to change the initial scheme frame should be routed to.
+				The change may be of a scheme id (in case of direct mode),
+				from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	p_FmPcdKgScheme	A structure of parameters for defining whether
+								a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, ioc_fm_pcd_kg_scheme_select_t *p_FmPcdKgScheme);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+				e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
+				only, to change the initial Policer profile frame should be
+				routed to. The change may be of a profile and/or absolute/direct
+				mode selection.
+
+ @Param[in]	h_FmPort				A handle to a FM Port module.
+ @Param[in]	h_Profile			Policer profile handle
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called for ports that use coarse classification tree
+				if the user wishes to replace the tree. The routine may not be called while port
+				receives packets using the PCD functionalities, therefor port must be first detached
+				from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[in]	h_CcTree			A CC tree that was already built. The tree id as returned from
+								the BuildTree routine.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+uint32_t FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+				port to be bound to. The selected schemes are not added,
+				just this specific port starts using them.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_PortScheme	A structure defining the list of schemes to be added.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, ioc_fm_pcd_port_schemes_params_t *p_PortScheme);
+
+/**************************************************************************//**
+ @Function	FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+				port to be bound to. The selected schemes are not removed or invalidated,
+				just this specific port stops using them.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_PortScheme	A structure defining the list of schemes to be added.
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+uint32_t FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, ioc_fm_pcd_port_schemes_params_t *p_PortScheme);
+
+/**************************************************************************//**
+ @Function	FM_PORT_GetIPv4OptionsCount
+
+ @Description   TODO
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+ @Param[out]	p_Ipv4OptionsCount  will hold the counter value
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init()
+*//***************************************************************************/
+uint32_t FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
+
+/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of FM_PORT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group		FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
+
+ @Description   FM Port Runtime data unit API functions, definitions and enums.
+				This API is valid only if working in Independent-Mode.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function	FM_PORT_ImTx
+
+ @Description   Tx function, called to transmit a data buffer on the port.
+
+ @Param[in]	h_FmPort	A handle to a FM Port module.
+ @Param[in]	p_Data	A pointer to an LCP data buffer.
+ @Param[in]	length	Size of data for transmission.
+ @Param[in]	lastBuffer  Buffer position - TRUE for the last buffer
+							of a frame, including a single buffer frame
+ @Param[in]	h_BufContext  A handle of the user acossiated with this buffer
+
+ @Return	E_OK on success; Error code otherwise.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				NOTE - This routine can be used only when working in
+				Independent-Mode mode.
+*//***************************************************************************/
+uint32_t  FM_PORT_ImTx( t_Handle			h_FmPort,
+					uint8_t				*p_Data,
+					uint16_t			length,
+					bool				lastBuffer,
+					t_Handle			h_BufContext);
+
+/**************************************************************************//**
+ @Function	FM_PORT_ImTxConf
+
+ @Description   Tx port confirmation routine, optional, may be called to verify
+				transmission of all frames. The procedure performed by this
+				routine will be performed automatically on next buffer transmission,
+				but if desired, calling this routine will invoke this action on
+				demand.
+
+ @Param[in]	h_FmPort			A handle to a FM Port module.
+
+ @Cautions	Allowed only following FM_PORT_Init().
+				NOTE - This routine can be used only when working in
+				Independent-Mode mode.
+*//***************************************************************************/
+void FM_PORT_ImTxConf(t_Handle h_FmPort);
+
+uint32_t  FM_PORT_ImRx(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_runtime_data_grp group */
+/** @} */ /* end of FM_PORT_grp group */
+/** @} */ /* end of FM_grp group */
+#endif /* __FM_PORT_EXT_H */
diff --git a/drivers/net/dpaa/fmlib/ncsw_ext.h b/drivers/net/dpaa/fmlib/ncsw_ext.h
new file mode 100644
index 000000000000..7da0722c1bde
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/ncsw_ext.h
@@ -0,0 +1,190 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __NCSW_EXT_H
+#define __NCSW_EXT_H
+
+#include <stdint.h>
+
+#define PTR_TO_UINT(_ptr)	((uintptr_t)(_ptr))
+#define UINT_TO_PTR(_val)	((void*)(uintptr_t)(_val))
+
+/* physAddress_t should be uintptr_t */
+typedef uint64_t physAddress_t;
+
+/**************************************************************************//**
+ @Description   Possible RxStore callback responses.
+*//***************************************************************************/
+typedef enum e_RxStoreResponse
+{
+	e_RX_STORE_RESPONSE_PAUSE	/**< Pause invoking callback with received data;
+					in polling mode, start again invoking callback
+					only next time user invokes the receive routine;
+					in interrupt mode, start again invoking callback
+					only next time a receive event triggers an interrupt;
+					in all cases, received data that are pending are not
+					lost, rather, their processing is temporarily deferred;
+					in all cases, received data are processed in the order
+					in which they were received. */
+	, e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
+} e_RxStoreResponse;
+
+
+/**************************************************************************//**
+ @Description   General Handle
+*//***************************************************************************/
+typedef void *	t_Handle;   /**< handle, used as object's descriptor */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Function	t_GetBufFunction
+
+ @Description   User callback function called by driver to get data buffer.
+
+		User provides this function. Driver invokes it.
+
+ @Param[in]	h_BufferPool	- A handle to buffer pool manager
+ @Param[out]	p_BufContextHandle  - Returns the user's private context that
+					should be associated with the buffer
+
+ @Return	Pointer to data buffer, NULL if error
+ *//***************************************************************************/
+typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
+					t_Handle   *p_BufContextHandle);
+
+/**************************************************************************//**
+ @Function	t_PutBufFunction
+
+ @Description   User callback function called by driver to return data buffer.
+
+		User provides this function. Driver invokes it.
+
+ @Param[in]	h_BufferPool	- A handle to buffer pool manager
+ @Param[in]	p_Buffer	- A pointer to buffer to return
+ @Param[in]	h_BufContext	- The user's private context associated with
+				the returned buffer
+
+ @Return	E_OK on success; Error code otherwise
+ *//***************************************************************************/
+typedef uint32_t (t_PutBufFunction)(t_Handle h_BufferPool,
+				uint8_t  *p_Buffer,
+				t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Function	t_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]	addr - The physical address to translate.
+
+ @Return	Virtual address.
+*//***************************************************************************/
+typedef void * t_PhysToVirt(physAddress_t addr);
+
+/**************************************************************************//**
+ @Function	t_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]	addr - The virtual address to translate.
+
+ @Return	Physical address.
+*//***************************************************************************/
+typedef physAddress_t t_VirtToPhys(void *addr);
+
+/**************************************************************************//**
+ @Description   Buffer Pool Information Structure.
+*//***************************************************************************/
+typedef struct t_BufferPoolInfo
+{
+	t_Handle		h_BufferPool;   /**< A handle to the buffer pool manager */
+	t_GetBufFunction	*f_GetBuf;	/**< User callback to get a free buffer */
+	t_PutBufFunction	*f_PutBuf;	/**< User callback to return a buffer */
+	uint16_t		bufferSize;	/**< Buffer size (in bytes) */
+
+	t_PhysToVirt	*f_PhysToVirt;  /**< User callback to translate pool buffers
+						physical addresses to virtual addresses  */
+	t_VirtToPhys	*f_VirtToPhys;  /**< User callback to translate pool buffers
+						virtual addresses to physical addresses */
+} t_BufferPoolInfo;
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with receive data.
+
+		User provides this function. Driver invokes it.
+
+ @Param[in]	h_App	- Application's handle, as was provided to the
+				driver by the user
+ @Param[in]	queueId	- Receive queue ID
+ @Param[in]	p_Data	- Pointer to the buffer with received data
+ @Param[in]	h_BufContext	- The user's private context associated with
+				the given data buffer
+ @Param[in]	length	- Length of received data
+ @Param[in]	status	- Receive status and errors
+ @Param[in]	position	- Position of buffer in frame
+ @Param[in]	flags	- Driver-dependent information
+
+ @Retval	e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+						operation for all ready data.
+ @Retval	e_RX_STORE_RESPONSE_PAUSE	- order the driver to stop Rx operation.
+ *//***************************************************************************/
+typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
+						uint32_t  queueId,
+						uint8_t   *p_Data,
+						t_Handle  h_BufContext,
+						uint32_t  length,
+						uint16_t  status,
+						uint8_t   position,
+						uint32_t  flags);
+
+
+typedef struct t_Device {
+	uintptr_t   id;	/**< the device id */
+	int	fd;	/**< the device file descriptor */
+	t_Handle	h_UserPriv;
+	uint32_t	owners;
+} t_Device;
+
+t_Handle CreateDevice(t_Handle h_UserPriv, t_Handle h_DevId);
+t_Handle GetDeviceId(t_Handle h_Dev);
+
+#endif /* __NCSW_EXT_H */
diff --git a/drivers/net/dpaa/fmlib/net_ext.h b/drivers/net/dpaa/fmlib/net_ext.h
new file mode 100644
index 000000000000..a42753a2ba8f
--- /dev/null
+++ b/drivers/net/dpaa/fmlib/net_ext.h
@@ -0,0 +1,435 @@
+/*-
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ *   BSD LICENSE
+ *
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __NET_EXT_H
+#define __NET_EXT_H
+
+#include "ncsw_ext.h"
+
+/**************************************************************************//**
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID		(1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED	(IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER		(1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE		(IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE		(IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID		(IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN		(IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION	(IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID		(IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS		((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID		(1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM	(IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED		(IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS		((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF		(1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT		(IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN		(IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID		(IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID		(IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS	((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA		(1)
+#define IOC_NET_HEADER_FIELD_ETH_SA		(IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH		(IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE		(IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM	(IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING		(IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS	((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE	6
+
+typedef uint16_t ioc_header_field_ip_t;
+
+#define IOC_NET_HEADER_FIELD_IP_VER		(1)
+#define IOC_NET_HEADER_FIELD_IP_DSCP		(IOC_NET_HEADER_FIELD_IP_VER << 2)
+#define IOC_NET_HEADER_FIELD_IP_ECN		(IOC_NET_HEADER_FIELD_IP_VER << 3)
+#define IOC_NET_HEADER_FIELD_IP_PROTO		(IOC_NET_HEADER_FIELD_IP_VER << 4)
+
+#define IOC_NET_HEADER_FIELD_IP_PROTO_SIZE	1
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER		(1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN	(IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS		(IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN	(IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID		(IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D	(IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M	(IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET	(IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL		(IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO		(IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM		(IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP		(IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP		(IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS		(IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT	(IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS	((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv4_ADDR_SIZE	4
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO_SIZE	1
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER		(1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC		(IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP		(IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP		(IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR	(IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL		(IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT	(IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS	((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE	16
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE		1
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE		(1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE		(IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM		(IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID		(IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM		(IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_CODE_SIZE	1
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE_SIZE	1
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION	(1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE		(IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM		(IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA		(IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC	(1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST	(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS		(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT	(IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SIZE	2
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC	(1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST	(IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG	(IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM		(IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SIZE	2
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC	(1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST	(IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SIZE	2
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC	(1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST	(IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN		(IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM		(IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE	2
+
+typedef uint8_t ioc_header_field_udp_lite_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC		(1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_DST		(IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS		((IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SIZE		2
+
+typedef uint8_t ioc_header_field_udp_encap_esp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC		(1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST		(IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN		(IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM		(IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI		(IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM	(IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE	2
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE		4
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID		(1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE	(IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX	(IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN		(IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT		(IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS	((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE		(1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS		(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH		(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN		(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID	(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN	(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID	(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED	(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING	(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END		(IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS	((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT	(1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION	(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE		(IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS		((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT		(1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT	(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE		(IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS		((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT		(1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION		(IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID	(IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE		(IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS		((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI		(1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI		(IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID		(IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH		(IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE		(IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS	((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_VLAN_TCI		(IOC_NET_HEADER_FIELD_VLAN_VPRI | \
+				IOC_NET_HEADER_FIELD_VLAN_CFI | \
+				IOC_NET_HEADER_FIELD_VLAN_VID)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP		(1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP		(IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL		(IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS	((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID		(1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS		((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI		(1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID		(IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE	(1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS		((IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE		(1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA		(IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS	((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC		(1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID	(IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI		(IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID		(IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI	(IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX	(IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS		((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT		(1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID		(IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS		((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER	(1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE	(IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE	(IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE	(IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE	(IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE		(IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS		((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE		(1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS	((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP	(1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP	(IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE	(IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS		((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI	(1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH		(IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS		((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI	(1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM		(IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS		((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE		4
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK		(1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS	((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_macsec_t;
+
+#define IOC_NET_HEADER_FIELD_MACSEC_SECTAG	(1)
+#define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS		((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
+typedef enum {
+	HEADER_TYPE_NONE = 0,
+	HEADER_TYPE_PAYLOAD,
+	HEADER_TYPE_ETH,
+	HEADER_TYPE_VLAN,
+	HEADER_TYPE_IPv4,
+	HEADER_TYPE_IPv6,
+	HEADER_TYPE_IP,
+	HEADER_TYPE_TCP,
+	HEADER_TYPE_UDP,
+	HEADER_TYPE_UDP_LITE,
+	HEADER_TYPE_IPHC,
+	HEADER_TYPE_SCTP,
+	HEADER_TYPE_SCTP_CHUNK_DATA,
+	HEADER_TYPE_PPPoE,
+	HEADER_TYPE_PPP,
+	HEADER_TYPE_PPPMUX,
+	HEADER_TYPE_PPPMUX_SUBFRAME,
+	HEADER_TYPE_L2TPv2,
+	HEADER_TYPE_L2TPv3_CTRL,
+	HEADER_TYPE_L2TPv3_SESS,
+	HEADER_TYPE_LLC,
+	HEADER_TYPE_LLC_SNAP,
+	HEADER_TYPE_NLPID,
+	HEADER_TYPE_SNAP,
+	HEADER_TYPE_MPLS,
+	HEADER_TYPE_IPSEC_AH,
+	HEADER_TYPE_IPSEC_ESP,
+	HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+	HEADER_TYPE_MACSEC,
+	HEADER_TYPE_GRE,
+	HEADER_TYPE_MINENCAP,
+	HEADER_TYPE_DCCP,
+	HEADER_TYPE_ICMP,
+	HEADER_TYPE_IGMP,
+	HEADER_TYPE_ARP,
+	HEADER_TYPE_CAPWAP,
+	HEADER_TYPE_CAPWAP_DTLS,
+	HEADER_TYPE_RFC2684,
+	HEADER_TYPE_USER_DEFINED_L2,
+	HEADER_TYPE_USER_DEFINED_L3,
+	HEADER_TYPE_USER_DEFINED_L4,
+	HEADER_TYPE_USER_DEFINED_SHIM1,
+	HEADER_TYPE_USER_DEFINED_SHIM2,
+	MAX_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+#endif /* __NET_EXT_H */
-- 
2.14.3

